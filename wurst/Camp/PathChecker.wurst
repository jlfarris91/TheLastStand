package PathChecker
import ObjectIdGenerator
import UnitObjEditing
import UnitIds
import Bounds
import AbilityIds
import ObjectIds
import Orders
import UnitMetadata
import HashList
import ClosureTimers
import GameConstants
import Action
import UnitRecycler
import Suspend
import Preload
import Trace
import RealTime

public bool PATHCHECKER_ENABLED = true

constant int PATH_CHECKER_UNIT_ID = compiletime(UNIT_ID_GEN.next())
constant player PATH_CHECKER_OWNER = players[GetPlayerNeutralPassive()]
constant vec2 DEACTIVATED_POS = mapBounds.max
constant real MIN_DISTANCE_MOVED_THRESHOLD = 64.0
constant real MIN_DISTANCE_MOVED_THRESHOLD_SQ = MIN_DISTANCE_MOVED_THRESHOLD * MIN_DISTANCE_MOVED_THRESHOLD
constant real ARRIVAL_DISTANCE = 64.0
constant real UPDATE_INTERVAL = 0.5
constant real PATH_CHECKER_COLLISION_SIZE = 0

// When target is moving apply this to the threshold to make catching up easier
constant real THRESHOLD_RANGE_MOTION_BUFFER = 2

HashList<unit> g_activePathCheckers = new HashList<unit>()
CallbackPeriodic g_updatePathCheckerTimer

UnitRecycler g_pathCheckerRecycler = new UnitRecycler(PATH_CHECKER_OWNER, PATH_CHECKER_UNIT_ID)

public enum PathCheckerStatus
  UNDETERMINED
  TIMEDOUT
  NOT_FOUND
  FOUND

// ============================================================================
@compiletime function createUnitDef()
  new UnitDefinition(PATH_CHECKER_UNIT_ID, UnitIds.shade)
    ..setCollisionSize(PATH_CHECKER_COLLISION_SIZE)
    ..setSpeedBase(512)
    ..setNormalAbilities(commaList(AbilityIds.invulnerable, AbilityIds.ghostVisible))
    ..setShadowImageWidth(0)
    ..setShadowImageHeight(0)
    ..setShadowImageUnit("")
    ..setAttacksEnabled(0)
    ..setSelectionScale(-1)
    ..setTurnRate(999.0)
    ..setSightRadiusDay(99999)
    ..setSightRadiusNight(99999)
    ..setModelFile("")
    ..setScalingValue(0.01)
    ..setHideMinimapDisplay(true)
    ..setMovementType(MovementType.Hover)

    // Debugging
    //..setModelFile("units\\human\\Footman\\Footman")
    //..setScalingValue(1.0)
    //..setHideMinimapDisplay(false)

// ============================================================================
public class PathCheckerComponent extends UnitComponent
  private unit m_targetUnit = null
  private vec2 m_lastPos = ZERO2
  private vec2 m_targetLastPos = ZERO2
  private Action1<PathCheckerComponent> m_callback = null
  private PathCheckerStatus m_status = PathCheckerStatus.UNDETERMINED
  private real m_actualThresholdSq = 0.0
  private bool m_autoRelease = true
  private real m_timeout = 15.0
  private real m_timeoutStartTime = 0.0

  // --------------------------------------------------------------------------
  construct(IUnitMetadata owner)
    super(owner)

  // --------------------------------------------------------------------------
  function getCallback() returns Action1<PathCheckerComponent>
    return m_callback

  // --------------------------------------------------------------------------
  function setCallback(Action1<PathCheckerComponent> callback)
    if (m_callback != null)
      m_callback.release()
    m_callback = callback.acquire()

  // --------------------------------------------------------------------------
  function getTargetUnit() returns unit
    return m_targetUnit

  // --------------------------------------------------------------------------
  function setTargetUnit(unit targetUnit)
    m_targetUnit = targetUnit
    
    let combinedCollisionSize = PATH_CHECKER_COLLISION_SIZE + m_targetUnit.getCollisionSize()
    let collisionSize = combinedCollisionSize + MELEE_UNIT_ATTACK_RANGE
    m_actualThresholdSq = collisionSize * collisionSize

  // --------------------------------------------------------------------------
  function getStatus() returns PathCheckerStatus
    return m_status

  // --------------------------------------------------------------------------
  function getAutoDestroy() returns bool
    return m_autoRelease

  // --------------------------------------------------------------------------
  function setAutoDestroy(bool autoDestroy)
    m_autoRelease = autoDestroy

  // --------------------------------------------------------------------------
  function getTimeout() returns real
    return m_timeout
  
  // --------------------------------------------------------------------------
  function setTimeout(real value)
    m_timeout = value

  // --------------------------------------------------------------------------
  override function onEnabled()
    super.onEnabled()
    registerActivePathChecker(getOwnerUnit())

  // --------------------------------------------------------------------------
  override function onDisabled()
    super.onDisabled()

    let ownerUnit = getOwnerUnit()
    
    unregisterActivePathChecker(ownerUnit)

    m_targetUnit = null
    m_status = PathCheckerStatus.UNDETERMINED

    releaseCallback()

    ownerUnit.hide()
    ownerUnit.setPos(DEACTIVATED_POS)
    ownerUnit.suspend()
    
    if (m_autoRelease)
      release()

  // --------------------------------------------------------------------------
  function update()

    let timedOut = getRealTimeSeconds() > m_timeoutStartTime + m_timeout
    if (timedOut)
      onTimedOut()
      deactivate()
      return

    if (m_targetUnit == null or m_targetUnit.isAliveTrick() == false)
      onPathNotFound()
      deactivate()
      return

    let ownerUnit = getOwnerUnit()
    let currentPos = ownerUnit.getPos()
    let targetPos = m_targetUnit.getPos()

    // For moving units we increase the distance threshold to make catching up easier
    var distTargetMovedFromLastPos = targetPos.distanceTo(m_targetLastPos)

    // If the unit moved faster than sim-possible then it likely teleported, just ignore the movement
    if (distTargetMovedFromLastPos > 512)
      distTargetMovedFromLastPos = 0

    m_targetLastPos = targetPos

    let targetIsMoving = distTargetMovedFromLastPos > MIN_DISTANCE_MOVED_THRESHOLD

    // If the target is moving then reissue the move order to follow them
    if (targetIsMoving)
    //{
      // Try to anticipate where the unit will move next
      let moveToPos = targetPos.polarOffset(m_targetUnit.getFacingAngle(), distTargetMovedFromLastPos)
      ownerUnit.issuePointOrderById(OrderIds.move, moveToPos)
    //}

    let distMovedFromLastPosSq = currentPos.distanceToSq(m_lastPos)
    m_lastPos = currentPos

    let distSq = currentPos.distanceToSq(targetPos)

    // Log.info("tm: {0} td: {1} pd: {2} dist: {3} th: {4}".format(
    //   targetIsMoving.toString(),
    //   distTargetMovedFromLastPos.toString(),
    //   SquareRoot(distMovedFromLastPosSq).toString(),
    //   SquareRoot(distSq).toString(),
    //   SquareRoot(m_actualThresholdSq).toString()))
    
    // Reached target
    if (distSq < m_actualThresholdSq)
      onPathFound()
      deactivate()
      return

    // Got stuck...
    if (distMovedFromLastPosSq < MIN_DISTANCE_MOVED_THRESHOLD_SQ and
        ownerUnit.getCurrentOrder() != OrderIds.move)
    //{
      // Standing within attack range of the target, it's pathable
      if (distSq < m_actualThresholdSq)
        onPathFound()
      else
        onPathNotFound()

      deactivate()
    //}    

  // --------------------------------------------------------------------------
  function onPathFound()
    // Log.info("found path to {0}!".format(m_targetUnit.getName()))
    m_status = PathCheckerStatus.FOUND
    raiseCallback()

  // --------------------------------------------------------------------------
  function onPathNotFound()
    // Log.info("no path found to {0}".format(m_targetUnit.getName()))
    m_status = PathCheckerStatus.NOT_FOUND
    raiseCallback()

  // --------------------------------------------------------------------------
  function onTimedOut()
    // Log.info("timed out finding path to {0}".format(m_targetUnit.getName()))
    m_status = PathCheckerStatus.TIMEDOUT
    raiseCallback()

  // --------------------------------------------------------------------------
  function raiseCallback()
    if (m_callback != null)
      m_callback.call(this)
      releaseCallback()

  // --------------------------------------------------------------------------
  function activate(vec2 startPos)
    let ownerUnit = getOwnerUnit()

    ownerUnit.setXY(startPos)
    ownerUnit.show()
    ownerUnit.unsuspend()

    m_lastPos = ownerUnit.getPos()
    m_status = PathCheckerStatus.UNDETERMINED
    m_timeoutStartTime = getRealTimeSeconds()

    let targetPos = m_targetUnit.getPos()
    m_targetLastPos = targetPos
    getOwnerUnit().issuePointOrderById(OrderIds.move, targetPos)
    // if (getOwnerUnit().issuePointOrderById(OrderIds.move, targetPos))
    //   Log.debug("Started path check for unit " + m_targetUnit.getName())

    enable()

  // --------------------------------------------------------------------------
  function deactivate()
    disable()

  // --------------------------------------------------------------------------
  /** Make sure not to call anything after this since this object will be destroyed **/
  function release()
    g_pathCheckerRecycler.stock(getOwnerUnit())

  // --------------------------------------------------------------------------
  function releaseCallback()
    if (m_callback != null)
      m_callback.release()
    m_callback = null

// ============================================================================
public function IUnitMetadata.getPathCheckerComponent() returns PathCheckerComponent
  return this.getComponent(PathCheckerComponent.typeId) castTo PathCheckerComponent

// ============================================================================
public function IUnitMetadata.getOrAddPathCheckerComponent() returns PathCheckerComponent
  var component = this.getPathCheckerComponent()
  if (component == null)
    component = this.addComponent(new PathCheckerComponent(this), false) castTo PathCheckerComponent
  return component

// ============================================================================
public function unit.getPathCheckerComponent() returns PathCheckerComponent
  let metadata = this.getMetadata()
  if (metadata == null)
    return null
  return metadata.getPathCheckerComponent()

// ============================================================================
public function unit.getOrAddPathCheckerComponent() returns PathCheckerComponent
  let metadata = this.getMetadata()
  if (metadata == null)
    return null
  return metadata.getOrAddPathCheckerComponent()

// ============================================================================
public class PathChecker

  // --------------------------------------------------------------------------
  static function getPathChecker() returns unit
    let pathCheckerUnit = createPathCheckerUnit(DEACTIVATED_POS, angle(0))
    pathCheckerUnit.getOrAddPathCheckerComponent()..setAutoDestroy(false)..deactivate()
    return pathCheckerUnit

  // --------------------------------------------------------------------------
  static function findPathToUnit(vec2 fromPos, unit toUnit, Action1<PathCheckerComponent> callback)
    let pathChecker = createPathCheckerUnit(fromPos, fromPos.angleTo(toUnit.getPos()))
    pathChecker.getOrAddPathCheckerComponent()
    ..setAutoDestroy(true)
    ..setTargetUnit(toUnit)
    ..setCallback(callback)
    ..activate(fromPos)

  // // --------------------------------------------------------------------------
  // @deprecated static function startPathChecker(player targetPlayer) returns bool

  //   let spawnPointProvider = getHostileSpawnPointProviderForPlayer(targetPlayer, SpawnRange.MID)
  //   let spawnPosResult = spawnPointProvider.getSpawnPoint()
  //   if (spawnPosResult.succeeded == false)
  //     return false
    
  //   let spawnPos = spawnPosResult.spawnPoint

  //   let targetPlayerComp = targetPlayer.getHumanPlayerComponent()
  //   if (targetPlayerComp == null)
  //     return false

  //   let targetUnit = targetPlayerComp.getHQOrHero()
  //   if (targetUnit == null or not targetUnit.isAlive())
  //     return false

  //   findPathToUnit(spawnPos, targetUnit, g_pathCheckCallback)
  //   Log.debug("Started path check for player " + targetPlayer.getName())

  //   return true

  // --------------------------------------------------------------------------
  private static function createPathCheckerUnit(vec2 pos, angle facing) returns unit
    return g_pathCheckerRecycler.getUnit(PATH_CHECKER_OWNER, pos, facing)

// ============================================================================
function registerActivePathChecker(unit pathChecker)
  if (g_activePathCheckers.has(pathChecker))
    return
  g_activePathCheckers.add(pathChecker)
  if (g_activePathCheckers.size() == 1 and g_updatePathCheckerTimer == null)
    g_updatePathCheckerTimer = doPeriodically(UPDATE_INTERVAL, (CallbackPeriodic cb) -> updatePathCheckers())

// ============================================================================
function unregisterActivePathChecker(unit pathChecker)
  if (g_activePathCheckers.has(pathChecker) == false)
    return
  g_activePathCheckers.remove(pathChecker)
  if (g_activePathCheckers.size() == 0)
    destroy g_updatePathCheckerTimer
    g_updatePathCheckerTimer = null

// ============================================================================
function updatePathCheckers()

  if (not PATHCHECKER_ENABLED)
    return

  Trace.trace("updatePathCheckers")

  for u in g_activePathCheckers
    let comp = u.getOrAddPathCheckerComponent()
    if (comp != null)
      comp.update()
      Trace.trace("updatePathCheckers.active")

// ============================================================================
init
  Preload.registerUnitRecycler(PATH_CHECKER_UNIT_ID, 128)