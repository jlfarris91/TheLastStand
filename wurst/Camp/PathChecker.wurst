package PathChecker
import ObjectIdGenerator
import UnitObjEditing
import UnitIds
import Bounds
import AbilityIds
import ObjectIds
import Orders
import UnitComponent
import HashList
import ClosureTimers
import GameConstants
import Action
import UnitRecycler
import Suspend
import Preload
import Trace

constant int PATH_CHECKER_UNIT_ID = compiletime(UNIT_ID_GEN.next())
constant player PATH_CHECKER_OWNER = players[GetPlayerNeutralPassive()]
constant vec2 DEACTIVATED_POS = mapBounds.max
constant real MIN_DISTANCE_MOVED_THRESHOLD = 64.0
constant real MIN_DISTANCE_MOVED_THRESHOLD_SQ = MIN_DISTANCE_MOVED_THRESHOLD * MIN_DISTANCE_MOVED_THRESHOLD
constant real ARRIVAL_DISTANCE = 64.0
constant real UPDATE_INTERVAL = 0.5
constant real PATH_CHECKER_COLLISION_SIZE = 0

HashList<unit> g_activePathCheckers = new HashList<unit>()
CallbackPeriodic g_updatePathCheckerTimer

UnitRecycler g_pathCheckerRecycler = new UnitRecycler(PATH_CHECKER_OWNER, PATH_CHECKER_UNIT_ID)

// ============================================================================
@compiletime function createUnitDef()
  new UnitDefinition(PATH_CHECKER_UNIT_ID, UnitIds.shade)
    ..setCollisionSize(PATH_CHECKER_COLLISION_SIZE)
    ..setSpeedBase(512)
    ..setNormalAbilities(commaList(AbilityIds.invulnerable, AbilityIds.ghostVisible))
    ..setShadowImageWidth(0)
    ..setShadowImageHeight(0)
    ..setShadowImageUnit("")
    ..setAttacksEnabled(0)
    ..setSelectionScale(-1)
    ..setTurnRate(999.0)
    ..setSightRadiusDay(99999)
    ..setSightRadiusNight(99999)
    ..setModelFile("")
    ..setScalingValue(0.01)
    ..setHideMinimapDisplay(true)
    ..setMovementType(MovementType.Hover)

    // Debugging
    //..setModelFile("units\\human\\Footman\\Footman")
    //..setScalingValue(0.5)

// ============================================================================
public class PathCheckerComponent extends UnitComponent
  private unit m_targetUnit = null
  private vec2 m_lastPos = ZERO2
  private Action1<PathCheckerComponent> m_callback = null
  private bool m_foundPath = false
  private real m_arrivalDistanceSq = 0.
  private bool m_autoRelease = true
  private bool m_hasMovedBeyondThreshold = false

  // --------------------------------------------------------------------------
  construct(IUnitMetadata owner)
    super(owner)

  // --------------------------------------------------------------------------
  function getCallback() returns Action1<PathCheckerComponent>
    return m_callback

  // --------------------------------------------------------------------------
  function setCallback(Action1<PathCheckerComponent> callback)
    if (m_callback != null)
      m_callback.release()
    m_callback = callback.acquire()

  // --------------------------------------------------------------------------
  function getTargetUnit() returns unit
    return m_targetUnit

  // --------------------------------------------------------------------------
  function setTargetUnit(unit targetUnit)
    m_targetUnit = targetUnit
    
    let combinedCollisionSize = PATH_CHECKER_COLLISION_SIZE + m_targetUnit.getCollisionSize()
    let distance = combinedCollisionSize + ARRIVAL_DISTANCE + MELEE_UNIT_ATTACK_RANGE
    m_arrivalDistanceSq = distance * distance

  // --------------------------------------------------------------------------
  function getFoundPath() returns bool
    return m_foundPath

  // --------------------------------------------------------------------------
  function getAutoDestroy() returns bool
    return m_autoRelease

  // --------------------------------------------------------------------------
  function setAutoDestroy(bool autoDestroy)
    m_autoRelease = autoDestroy

  // --------------------------------------------------------------------------
  override function onEnabled()
    super.onEnabled()
    registerActivePathChecker(getOwnerUnit())

  // --------------------------------------------------------------------------
  override function onDisabled()
    super.onDisabled()

    let ownerUnit = getOwnerUnit()
    
    unregisterActivePathChecker(ownerUnit)

    m_targetUnit = null
    m_foundPath = false
    m_hasMovedBeyondThreshold = false

    releaseCallback()

    ownerUnit.hide()
    ownerUnit.setPos(DEACTIVATED_POS)
    ownerUnit.suspend()
    
    if (m_autoRelease)
      release()

  // --------------------------------------------------------------------------
  function update()
    if (m_targetUnit == null or m_targetUnit.isAlive() == false)
      onPathNotFound()
      deactivate()
      return

    let ownerUnit = getOwnerUnit()
    let currentPos = ownerUnit.getPos()
    let distMovedFromLastPosSq = currentPos.distanceToSq(m_lastPos)
    m_lastPos = currentPos
    
    if (distMovedFromLastPosSq < MIN_DISTANCE_MOVED_THRESHOLD_SQ)
      if (m_hasMovedBeyondThreshold and getOwnerUnit().getCurrentOrder() != OrderIds.move)
        onPathCheckerStuck()
    else
      m_hasMovedBeyondThreshold = true

  // --------------------------------------------------------------------------
  function onPathCheckerStuck()
    let ownerUnit = getOwnerUnit()
    let dist = ownerUnit.getPos().distanceToSq(m_targetUnit.getPos())
    
    // Standing within attack range of the target, it's pathable
    if (dist < m_arrivalDistanceSq)
      onPathFound()
    else
      onPathNotFound()

    deactivate()

  // --------------------------------------------------------------------------
  function onPathFound()
    m_foundPath = true
    raiseCallback()

  // --------------------------------------------------------------------------
  function onPathNotFound()
    m_foundPath = false
    raiseCallback()

  // --------------------------------------------------------------------------
  function raiseCallback()
    if (m_callback != null)
      m_callback.call(this)
      releaseCallback()

  // --------------------------------------------------------------------------
  function activate(vec2 startPos)
    let ownerUnit = getOwnerUnit()

    ownerUnit.setXY(startPos)
    ownerUnit.show()
    ownerUnit.unsuspend()

    m_lastPos = ownerUnit.getPos()
    m_foundPath = false
    m_hasMovedBeyondThreshold = false

    let targetPos = m_targetUnit.getPos()
    getOwnerUnit().issuePointOrderById(OrderIds.move, targetPos)
    // if (getOwnerUnit().issuePointOrderById(OrderIds.move, targetPos))
    //   Log.debug("Started path check for unit " + m_targetUnit.getName())

    enable()

  // --------------------------------------------------------------------------
  function deactivate()
    disable()

  // --------------------------------------------------------------------------
  /** Make sure not to call anything after this since this object will be destroyed **/
  function release()
    g_pathCheckerRecycler.stock(getOwnerUnit())

  // --------------------------------------------------------------------------
  function releaseCallback()
    if (m_callback != null)
      m_callback.release()
    m_callback = null

// ============================================================================
public function IUnitMetadata.getPathCheckerComponent() returns PathCheckerComponent
  return this.getComponent(PathCheckerComponent.typeId) castTo PathCheckerComponent

// ============================================================================
public function IUnitMetadata.getOrAddPathCheckerComponent() returns PathCheckerComponent
  var component = this.getPathCheckerComponent()
  if (component == null)
    component = this.addComponent(new PathCheckerComponent(this), false) castTo PathCheckerComponent
  return component

// ============================================================================
public function unit.getPathCheckerComponent() returns PathCheckerComponent
  let metadata = this.getMetadata()
  if (metadata == null)
    return null
  return metadata.getPathCheckerComponent()

// ============================================================================
public function unit.getOrAddPathCheckerComponent() returns PathCheckerComponent
  let metadata = this.getMetadata()
  if (metadata == null)
    return null
  return metadata.getOrAddPathCheckerComponent()

// ============================================================================
public class PathChecker

  // --------------------------------------------------------------------------
  static function getPathChecker() returns unit
    let pathCheckerUnit = createPathCheckerUnit(DEACTIVATED_POS, angle(0))
    pathCheckerUnit.getOrAddPathCheckerComponent()..setAutoDestroy(false)..deactivate()
    return pathCheckerUnit

  // --------------------------------------------------------------------------
  static function findPathToUnit(vec2 fromPos, unit toUnit, Action1<PathCheckerComponent> callback)
    let pathChecker = createPathCheckerUnit(fromPos, fromPos.angleTo(toUnit.getPos()))
    pathChecker.getOrAddPathCheckerComponent()
    ..setAutoDestroy(true)
    ..setTargetUnit(toUnit)
    ..setCallback(callback)
    ..activate(fromPos)

  // // --------------------------------------------------------------------------
  // @deprecated static function startPathChecker(player targetPlayer) returns bool

  //   let spawnPointProvider = getHostileSpawnPointProviderForPlayer(targetPlayer, SpawnRange.MID)
  //   let spawnPosResult = spawnPointProvider.getSpawnPoint()
  //   if (spawnPosResult.succeeded == false)
  //     return false
    
  //   let spawnPos = spawnPosResult.spawnPoint

  //   let targetPlayerComp = targetPlayer.getHumanPlayerComponent()
  //   if (targetPlayerComp == null)
  //     return false

  //   let targetUnit = targetPlayerComp.getHQOrHero()
  //   if (targetUnit == null or not targetUnit.isAlive())
  //     return false

  //   findPathToUnit(spawnPos, targetUnit, g_pathCheckCallback)
  //   Log.debug("Started path check for player " + targetPlayer.getName())

  //   return true

  // --------------------------------------------------------------------------
  private static function createPathCheckerUnit(vec2 pos, angle facing) returns unit
    return g_pathCheckerRecycler.getUnit(PATH_CHECKER_OWNER, pos, facing)

// ============================================================================
function registerActivePathChecker(unit pathChecker)
  if (g_activePathCheckers.has(pathChecker))
    return
  g_activePathCheckers.add(pathChecker)
  if (g_activePathCheckers.size() == 1 and g_updatePathCheckerTimer == null)
    g_updatePathCheckerTimer = doPeriodically(UPDATE_INTERVAL, (CallbackPeriodic cb) -> updatePathCheckers())

// ============================================================================
function unregisterActivePathChecker(unit pathChecker)
  if (g_activePathCheckers.has(pathChecker) == false)
    return
  g_activePathCheckers.remove(pathChecker)
  if (g_activePathCheckers.size() == 0)
    destroy g_updatePathCheckerTimer
    g_updatePathCheckerTimer = null

// ============================================================================
function updatePathCheckers()

  Trace.trace("updatePathCheckers")

  for u in g_activePathCheckers
    let comp = u.getOrAddPathCheckerComponent()
    if (comp != null)
      comp.update()
      Trace.trace("updatePathCheckers.active")

// ============================================================================
init
  Preload.registerUnitRecycler(PATH_CHECKER_UNIT_ID, 128)