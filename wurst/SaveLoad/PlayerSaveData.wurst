package PlayerSaveData
import Serialization
import BinaryReaderWriter
import LinkedList
import SyncSimple
import ClosureTimers
import ErrorHandling
import FileIO
import Events
import Base64
import Execute
import ByteBuffer
import DisplayTextToPlayer
import ColorUtility

@configurable constant string SAVE_DATA_FILEPATH_ROOT = "LastStand"
constant string SAVE_DATA_FILEPATH_FORMAT_STRING = "{0}/{1}/{2}.txt"

// ============================================================================
// Descending order
constant int SAVE_DATA_VERSION_COUNT = 1
constant int array SAVE_DATA_VERSIONS = [
  800   // PlayerSaveData_v800
]

// These are synced between all players
bool array g_syncedPlayerSaveDataVersions

IPlayerSaveData array g_loadedPlayerSaveData
LoadPlayerDataOperation array g_playerLoadOperations
int g_playerCount
int g_playerLoadedCount
string array g_playerLoadErrors

// ============================================================================
public interface IPlayerSaveData extends ISerializable
  function migrate(IPlayerSaveData olderData) returns bool

// ============================================================================
public class PlayerSaveData

  private static Event s_loadComplete = new Event()

  // --------------------------------------------------------------------------
  static function onLoadComplete() returns IEvent
    return s_loadComplete

  // --------------------------------------------------------------------------
  static function getLoadError(player _player) returns string
    return g_playerLoadErrors[_player.getId()]

  // --------------------------------------------------------------------------
  static function getPlayerSaveData(player _player) returns IPlayerSaveData
    return g_loadedPlayerSaveData[_player.getId()]

  // --------------------------------------------------------------------------
  static function getCurrentVersion() returns int
    return SAVE_DATA_VERSIONS[0]

  // --------------------------------------------------------------------------
  static function getNextVersion(int ver) returns int
    var lastVer = -1
    for i = 0 to SAVE_DATA_VERSION_COUNT - 1
      let currVer = SAVE_DATA_VERSIONS[i]
      if (currVer == ver)
        break
      lastVer = currVer
    return lastVer

  // --------------------------------------------------------------------------
  static function createSaveData(int ver) returns IPlayerSaveData

    if (ver == PlayerSaveData_v800.VERSION)
      return new PlayerSaveData_v800()

    return null

  // --------------------------------------------------------------------------
  static function createSerializationContext(player _player, int _ver) returns SerializationContext
    return new SerializationContext()..setPlayer(_player)

  // --------------------------------------------------------------------------
  static function makeSaveDataFilePath(player _player, int ver) returns string
    return SAVE_DATA_FILEPATH_FORMAT_STRING.format(SAVE_DATA_FILEPATH_ROOT, _player.getName(), ver.toString())

  // --------------------------------------------------------------------------
  static function getAvailableSaveDataVersionsForPlayer(player _player, LinkedList<int> outVersions)
    for i = 0 to SAVE_DATA_VERSION_COUNT - 1
      if (isSaveDataVersionAvailable(i, _player))
        outVersions.add(SAVE_DATA_VERSIONS[i])

  // --------------------------------------------------------------------------
  static function isSaveDataVersionAvailable(int versionIndex, player _player) returns bool
    if (versionIndex < 0 or versionIndex >= SAVE_DATA_VERSION_COUNT)
      error("Argument 'versionIndex' is out of bounds: " + versionIndex.toString())
    return g_syncedPlayerSaveDataVersions[_player.getId() * SAVE_DATA_VERSION_COUNT + versionIndex]

  // --------------------------------------------------------------------------
  protected static function syncAvailableSaveDataVersionsForLocalPlayer()
    for i = 0 to SAVE_DATA_VERSION_COUNT - 1
      let ver = SAVE_DATA_VERSIONS[i]
      let filePath = makeSaveDataFilePath(localPlayer, ver)
      let isVersionAvailable = Serialization.canReadFile(localPlayer, filePath)
      isVersionAvailable.sync(localPlayer) (syncedValue) ->
        g_syncedPlayerSaveDataVersions[localPlayer.getId() * SAVE_DATA_VERSION_COUNT + i] = syncedValue
        // Log.info("v{0} is {2} for player {1}".format(ver.toString(), localPlayer.getName(), syncedValue ? "available" : "unavailable"))

  // --------------------------------------------------------------------------
  static function load()
    g_playerCount = 0
    g_playerLoadedCount = 0
    for i = 0 to bj_MAX_PLAYER_SLOTS - 1
      if (players[i].isIngame())
        g_playerCount++
        let loadOperation = new LoadPlayerDataOperation(players[i])
        loadOperation.onCompleted().register(() -> onLoadOperationCompleted(players[i]))
        loadOperation.start()

  // --------------------------------------------------------------------------
  static function save()

    for i = 0 to bj_MAX_PLAYER_SLOTS - 1
      if (players[i].isIngame())
        save(players[i])

  // --------------------------------------------------------------------------
  static function save(player _player)
    let playerSaveData = getPlayerSaveData(_player)

    var buffer = new ByteBuffer()
    let writer = new BinaryWriter(buffer)
    let context = PlayerSaveData.createSerializationContext(localPlayer, playerSaveData.getVersion())
    let success = playerSaveData.serialize(context, writer)

    if (success and localPlayer == _player)
    //{
      let filepath = PlayerSaveData.makeSaveDataFilePath(localPlayer, playerSaveData.getVersion())

      // Write it out to the file
      let file = new File(filepath)
      file.write(localPlayer, buffer.encodeBase64())
      file.close()

      buffer = null

      if (not Serialization.canReadFile(localPlayer, filepath))
        Log.error("Failed to save player data to file 'Documents/Warcraft III/CustomMapData/{0}'".format(filepath))
      else
        displayMessageToPlayer(_player, "Saved data to file 'Documents/Warcraft III/CustomMapData/{0}'".format(filepath).colorize(Colors.gold))
    //}
    else
      Log.error("Failed to save player data 'v{0}'. Please let the developer know.".format(playerSaveData.getVersion().toString()))
    
    destroy context
    destroy writer
    if (buffer != null)
      destroy buffer

  // --------------------------------------------------------------------------
  private static function onLoadOperationCompleted(player _player)
    let loadOperation = g_playerLoadOperations[_player.getId()]

    g_playerLoadErrors[_player.getId()] = loadOperation.getErrorMessage()
    g_loadedPlayerSaveData[_player.getId()] = loadOperation.getLoadedSaveData()

    if (g_playerLoadErrors[_player.getId()] != "")
      g_loadedPlayerSaveData[_player.getId()] = createSaveData(getCurrentVersion())
      displayErrorToPlayer(_player, "Failed to load player data", g_playerLoadErrors[_player.getId()])
    else if (g_loadedPlayerSaveData[_player.getId()] == null)
      g_loadedPlayerSaveData[_player.getId()] = createSaveData(getCurrentVersion())
      displayMessageToPlayer(_player, "No saved player data found".colorize(Colors.gold))
    else
      let filepath = PlayerSaveData.makeSaveDataFilePath(localPlayer, g_loadedPlayerSaveData[_player.getId()].getVersion())
      displayMessageToPlayer(_player, "Successfully loaded player data from file 'Documents/Warcraft III/CustomMapData/{0}'".format(filepath).colorize(Colors.gold))

    g_playerLoadedCount++
    if (g_playerLoadedCount == g_playerCount)
      s_loadComplete.call()

  // --------------------------------------------------------------------------
  protected static function initialize()
    syncAvailableSaveDataVersionsForLocalPlayer()

// ============================================================================
class LoadPlayerDataOperation
  private player m_player
  private ChunkedString m_fileContents = null
  private int m_fileContentsVersion = 0
  private LinkedList<int> m_versions = new LinkedList<int>()
  private int m_loadVersionIndex = 0
  private Event m_completedEvent = new Event()
  private IPlayerSaveData m_loadedData
  private string m_errorMessage = ""
  private bool m_parseSucceeded

  // --------------------------------------------------------------------------
  construct (player _player)
    m_player = _player
    m_loadedData = null
    m_errorMessage = ""
    g_playerLoadOperations[_player.getId()] = this

  // --------------------------------------------------------------------------
  ondestroy
    destroy m_completedEvent
    destroy m_versions

    if (m_fileContents != null)
      destroy m_fileContents
      m_fileContents = null

    g_playerLoadOperations[m_player.getId()] = null

  // --------------------------------------------------------------------------
  function onCompleted() returns IEvent
    return m_completedEvent
    
  // --------------------------------------------------------------------------
  function getErrorMessage() returns string
    return m_errorMessage

  // --------------------------------------------------------------------------
  function getLoadedSaveData() returns IPlayerSaveData
    return m_loadedData

  // --------------------------------------------------------------------------
  function start()
    m_versions.clear()
    PlayerSaveData.getAvailableSaveDataVersionsForPlayer(m_player, m_versions)
    m_loadVersionIndex = -1
    tryLoadNextAvailableVersion()

  // --------------------------------------------------------------------------
  private function tryLoadNextAvailableVersion()
    m_loadVersionIndex++
    if (m_loadVersionIndex == m_versions.size())
      succeed()
      return

    // Log.info("[tryLoadNextAvailableVersion] loadVersionIndex: " + m_loadVersionIndex.toString())

    m_fileContentsVersion = m_versions.get(m_loadVersionIndex)

    // Log.info("[tryLoadNextAvailableVersion] fileContentsVersion: " + m_fileContentsVersion.toString())

    syncLocalFileContents(PlayerSaveData.makeSaveDataFilePath(m_player, m_fileContentsVersion))

  // --------------------------------------------------------------------------
  private function clearLocalFileContents()
    if (m_fileContents != null)
      destroy m_fileContents
    m_fileContents = new ChunkedString()

  // --------------------------------------------------------------------------
  private function syncLocalFileContents(string filepath)
    // Log.info("[syncLocalFileContents] " + filepath)
    let file = new File(filepath)
    let contents = file.read(m_player)
    contents.sync(m_player) (ChunkedString buffer) ->
      getLoadOperation(m_player).fileContentsSynced(buffer)
    destroy file

  // --------------------------------------------------------------------------
  private function fileContentsSynced(ChunkedString buffer)
    // Log.info("[fileContentsSynced]")
    clearLocalFileContents()
    for i = 0 to buffer.getChunkCount() - 1
      m_fileContents.append(buffer.getChunk(i))
    tryParseLoadedFileContents()

  // --------------------------------------------------------------------------
  private function tryParseLoadedFileContents()

    // Log.info("[tryParseLoadedFileContents] fileContentsVersion: " + m_fileContentsVersion.toString())

    let saveData = PlayerSaveData.createSaveData(m_fileContentsVersion)

    // Log.info("[tryParseLoadedFileContents] loadedData: v" + saveData.getVersion().toString())

    let context = PlayerSaveData.createSerializationContext(m_player, m_fileContentsVersion)

    let buffer = m_fileContents.decodeBase64()
    let reader = new BinaryReader(buffer)

    m_parseSucceeded = false

    try() () ->
      m_parseSucceeded = saveData.deserialize(context, reader)
      
    if (lastError != "")
      m_parseSucceeded = false
      
    if (not m_parseSucceeded and m_errorMessage == "")
      m_errorMessage = "Failed to parse save data v{0}. Please let the developer know.".format(m_fileContentsVersion.toString())

    destroy buffer
    destroy reader
    destroy context
    
    // decodeBase64() consumes the file contents for whatever reason...
    m_fileContents = null

    if (not m_parseSucceeded)
      destroy saveData
      // Log.info("[tryParseLoadedFileContents] failed, trying next available version")
      tryLoadNextAvailableVersion()
      return

    m_errorMessage = ""
    // Log.info("[tryParseLoadedFileContents] success")
    migrateLoadedToLatestVersion(saveData)

  // --------------------------------------------------------------------------
  private function migrateLoadedToLatestVersion(IPlayerSaveData saveData)
    var finalData = saveData
    while (finalData.getVersion() < PlayerSaveData.getCurrentVersion())
    //{
      let oldData = finalData
      
      let oldVersion = oldData.getVersion()
      let nextVersion = PlayerSaveData.getNextVersion(oldVersion)

      finalData = PlayerSaveData.createSaveData(nextVersion)
      // Log.info("[migrateLoadedToLatestVersion] {0} => {1}".format(oldVersion.toString(), nextVersion.toString()))

      try(() -> finalData.migrate(oldData))
      
      destroy oldData

      if (lastError != "")
        destroy finalData
        Log.info("[migrateLoadedToLatestVersion] failed! " + lastError)
        fail("Failed to migrate save data from version {0} to version {1}: {2}".format(oldVersion.toString(), nextVersion.toString(), lastError))
        return
    //}

    // Log.info("[migrateLoadedToLatestVersion] done migrating")

    m_loadedData = finalData

    succeed()

  // --------------------------------------------------------------------------
  private function fail(string message)
    // Log.info("[loadOperation] failed! " + message)
    m_errorMessage = message
    m_completedEvent.call()

  // --------------------------------------------------------------------------
  private function succeed()
    // Log.info("[loadOperation] succeeded!")
    m_completedEvent.call()

  // --------------------------------------------------------------------------
  private static function getLoadOperation(player _player) returns LoadPlayerDataOperation
    return g_playerLoadOperations[_player.getId()]

// ============================================================================
public class PlayerSaveData_v800 implements IPlayerSaveData
  static constant int VERSION = 800

  real cameraDistance

  // --------------------------------------------------------------------------
  construct()
    cameraDistance = 1650

  // --------------------------------------------------------------------------
  override function getVersion() returns int
    return VERSION

  // --------------------------------------------------------------------------
  override function serialize(SerializationContext context, BinaryWriter writer) returns bool

    writer.write(VERSION)
    writer.write(context.getPlayer().getName())

    writer.write(cameraDistance)

    return true

  // --------------------------------------------------------------------------
  override function deserialize(SerializationContext context, BinaryReader reader) returns bool

    if (not reader.readVersion(context, VERSION))
      return false

    if (not reader.readPlayerName(context, context.getPlayer().getName()))
      return false

    cameraDistance = reader.readReal()

    return true

  // --------------------------------------------------------------------------
  override function migrate(IPlayerSaveData olderData) returns bool
    return false

// ============================================================================
function BinaryReader.readPlayerName(SerializationContext context, string expectedPlayerName) returns bool
  let actualPlayerName = this.readString()
  if (actualPlayerName == expectedPlayerName)
    return true
  context.error("PlayerSaveData", "deserialize", "", "File contains unexpected content")
  return false

// ============================================================================
function BinaryReader.readVersion(SerializationContext context, int expectedVersion) returns bool
  let actualVersion = this.readInt()
  if (actualVersion == expectedVersion)
    return true
  context.error("PlayerSaveData", "deserialize", "", "File content version mismatch : expected {0} but found {1}".format(expectedVersion.toString(), actualVersion.toString()))
  return false

// ============================================================================
init
  nullTimer(() -> PlayerSaveData.initialize())
    