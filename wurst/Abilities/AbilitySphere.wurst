package AbilitySphere
import RealtimeUpdate
import Range
import Action
import GroupUtils
import Math
import Func
import ClosureTimers

let tempGroup = CreateGroup()

// ============================================================================
public class AbilitySphere implements IRealtimeListener
  private unit m_owner
  private vec2 m_startPos
  private vec2 m_endPos
  private rangeReal m_radius
  private real m_distance
  private effect m_fx
  private group m_affectedUnits
  private real m_speed
  private real m_time
  private real m_damageTime
  private real m_damageInterval
  private Func2<AbilitySphere, unit, bool> m_unitFilter
  private Action2<AbilitySphere, unit> m_callback

  // --------------------------------------------------------------------------
  construct(unit owner, effect fx, vec2 startPos, vec2 endPos, rangeReal radius, real speed,
            real damageInterval, Func2<AbilitySphere, unit, bool> unitFilter,
            Action2<AbilitySphere, unit> callback)
    m_owner = owner
    m_fx = fx
    m_startPos = startPos
    m_endPos = endPos
    m_radius = radius
    m_affectedUnits = getGroup()
    m_speed = speed
    m_damageTime = damageInterval
    m_damageInterval = damageInterval
    m_unitFilter = unitFilter.acquire()
    m_callback = callback.acquire()
    m_distance = startPos.distanceTo(endPos)
    m_time = 0.0
    this.registerForRealtimeUpdate(RealtimeUpdatePriority.Realtime)

    affectUnits(m_radius.min)

  // --------------------------------------------------------------------------
  ondestroy
    this.unregisterForRealtimeUpdate()
    m_affectedUnits.release()
    m_unitFilter.release()
    m_callback.release()
    m_fx.destr()

  // --------------------------------------------------------------------------
  function getPos() returns vec2
    return lerp(m_startPos, m_endPos, getProgress01())

  // --------------------------------------------------------------------------
  function getProgress01() returns real
    return parameterize01(0, m_distance, m_time * m_speed)

  // --------------------------------------------------------------------------
  function getRadius() returns real
    return m_radius.lerp(getProgress01())

  // --------------------------------------------------------------------------
  override function realtimeUpdate(real dt)

    m_time += dt

    let t = getProgress01()

    m_fx.setPos(getPos())

    if (t >= 1.0)
      affectUnits(m_radius.max)
      destroy this
      return

    m_damageTime -= dt

    if (m_damageTime <= 0.0)
      affectUnits(getRadius())
      m_damageTime = m_damageInterval

  // --------------------------------------------------------------------------
  private function affectUnits(real radius)
    tempGroup.enumUnitsInRange(getPos(), radius)
    for u in tempGroup
      if (not m_affectedUnits.contains(u) and m_unitFilter.call(this, u))
        m_callback.call(this, u)
        m_affectedUnits.addUnit(u)