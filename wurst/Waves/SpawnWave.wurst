package SpawnWave
import WaveSpawning
import Events
import LinkedList
import HumanPlayerComponent
import GameConstants
import ErrorHandling
import ClosureEvents
import HashMap
import UnitMetadata
import UndeadTargetingComponent
import Runnable
import ItemSet
import UnitModifiers
import Coins
import Range
import Spawning
import UnitExtensions
import TlsUnitDefinition
import SoundUtils
import MinimapIconComponent
import Elites
import UndeadTargetService
import ClosureTimers
import BuffObjEditing
import PlayerExtensions
import Jobs
import World
import SpawnUndeadUnitJob
import GroupExtensions

constant real PROCESS_SPAWN_REQUEST_INTERVAL = 0.3
constant int MAX_SPAWNS_PER_PROCESS = 1

constant real GOLD_CHANCE_MIN = 0.01
constant real GOLD_CHANCE_MAX = 1.0

HashMap<unit, SpawnWave> g_unitToSpawnWaveMap

@configurable public bool g_enableSpawnWaveLogging = false

ItemSet g_coinItemSet = new ItemSet()

// ============================================================================
public class SpawnWave extends Runnable
  private SpawnWaveDefinition m_definition
  private _handle m_onDefProgressChangedEventHandler
  private LinkedList<unit> m_aliveSpawnedUnits
  private int m_numSpawned
  private int m_maxSpawnCount
  private int m_groupId
  private string m_id
  protected player m_targetPlayer
  private SpawnWaveContext m_context
  private string m_debugState
  private Runnable m_progress

  private int m_spawnsPerGoldDrop
  private int m_spawnsPerGoldDropCounter

  private SpawnUndeadUnitJob m_spawnJob

  // --------------------------------------------------------------------------
  construct(player targetPlayer, int index, SpawnWaveDefinition def)
    if (targetPlayer == null)
      argumentNullError("targetPlayer")
    if (def == null)
      argumentNullError("def")

    m_targetPlayer = targetPlayer
    m_definition = def
    m_aliveSpawnedUnits = new LinkedList<unit>()
    m_numSpawned = 0
    m_maxSpawnCount = 0
    m_groupId = 0
    m_id = def.getName()
    m_debugState = ""

    m_context = new SpawnWaveContext()..acquire()
    m_context.definition = m_definition
    m_context.waveNumber = index

  // --------------------------------------------------------------------------
  ondestroy
    unlistenToDefProgressChangedEvent()
    
    m_aliveSpawnedUnits.clear()
    destroy m_aliveSpawnedUnits
    
    m_definition = null

    if (m_context != null)
      destroy m_context
      m_context = null

    if (m_spawnJob != null)
      destroy m_spawnJob
      m_spawnJob = null

  // --------------------------------------------------------------------------
  function getDefinition() returns SpawnWaveDefinition
    return m_definition

  // --------------------------------------------------------------------------
  function getId() returns string
    return m_id

  // --------------------------------------------------------------------------
  function getDebugState() returns string
    return m_debugState

  // --------------------------------------------------------------------------
  override function onStarted()
    super.onStarted()

    m_aliveSpawnedUnits.clear()
    m_numSpawned = 0

    // Update context
    let playerMetadata = m_targetPlayer.getHumanPlayerComponentRequired()
    m_context.setPlayerDifficulty(playerMetadata.getDifficulty())
    
    for i = 0 to MAX_ELITE_TIER-1
      m_context.setTierChance(i, playerMetadata.getTierChance(i))

    m_progress = m_definition.getProgress(m_context)
    m_maxSpawnCount = m_definition.getMaxSpawnCount(m_context)
    m_spawnsPerGoldDrop = m_definition.getSpawnsPerGoldDrop(m_context)
    m_spawnsPerGoldDropCounter = 0

    let targetProvider = getUndeadTargetProviderForPlayer(m_targetPlayer)
    if (targetProvider == null)
      cancel()
      return

    let spawnJobConfig = new SpawnUndeadUnitJobConfig()
    ..setTierSelectionMode(TierSelectionMode.Group)
    ..setTierSelector(context -> (context castTo SpawnWaveContext).getRandomTier())
    ..setUnitTypeProvider(m_definition.getUnitTypeProvider())
    ..setSpawnPointProvider(getSpawnPointProvider(m_targetPlayer, m_definition.getSpawnPointProviderType()))
    ..setTargetProvider(targetProvider)
    ..setGroupSize(m_definition.getGroupSize(m_context))
    ..setMaxSpawnCount(m_definition.getMaxSpawnCount(m_context))
    ..setMaxAliveCount(m_definition.getMaxAliveCount(m_context))
    ..setSpawnRange(m_definition.getSpawnRange().toRangeReal())
    ..setWaitForFullGroup(m_definition.getWaitForFullSpawnGroup())
    ..setPrepareUnitFunc((job, spawnedUnit) -> prepareUnit(spawnedUnit))
    ..setUseRecycler(m_definition.getUseUnitRecycler())

    m_spawnJob = new SpawnUndeadUnitJob("SUUB" + m_definition.getName(), PLAYER_UNDEAD, m_targetPlayer, spawnJobConfig)
    ..setContext(m_context)
    ..acquire()
    
    m_spawnJob.onUnitSpawned().register((j, u) -> onUnitSpawned(j, u))
    m_spawnJob.onGroupSpawned().register((j, g) -> onGroupSpawned(j, g))

    listenToDefProgressChangedEvent()

    // Do this one frame later so that all player spawn waves that share these
    // spawn def services get started
    nullTimer() () ->
    //{
      if (m_progress != null)
        m_progress.start()

      World.unitSpawnThread.enqueue(getCancellationToken(), m_spawnJob)
    //}  

  // --------------------------------------------------------------------------
  override function onCompleted()
    super.onCompleted()

    unlistenToDefProgressChangedEvent()

    // Do this one frame later so that all player spawn waves that share these
    // spawn def services get completed first
    nullTimer() () ->
      if (m_progress != null)
        m_progress.complete()

    if (m_spawnJob != null)
      m_spawnJob.complete()
      m_spawnJob.release()
      m_spawnJob = null

    // Show minimap icons for whatever units are left
    for u in m_aliveSpawnedUnits
    //{
      g_unitToSpawnWaveMap.remove(u)

      if (u.getMinimapIconComponent() == null)
        let iconPath = getMinimapIconPath(u.getTypeId())
        if (iconPath != null)
          let iconComp = u.getOrAddMinimapIconComponent()
          iconComp.update(iconPath, getMinimapIconColor(u.getTypeId()))
          iconComp.showOnlyFor(m_targetPlayer)
    //}

    let techIdToAdvance = m_definition.getTechIdToAdvance()
    if (techIdToAdvance != 0)
      m_targetPlayer.incTechResearchLevel(techIdToAdvance, 1)

  // --------------------------------------------------------------------------
  override function getProgress() returns real
    return m_progress != null ? m_progress.getProgress() : 0.0

  // --------------------------------------------------------------------------
  function getContext() returns SpawnWaveContext
    return m_context

  // --------------------------------------------------------------------------
  function debugActivate()
    start()

  // --------------------------------------------------------------------------
  function registerSpawnedUnit(unit spawnedUnit)

    if (g_unitToSpawnWaveMap.has(spawnedUnit))
      return

    g_unitToSpawnWaveMap.put(spawnedUnit, this)
    m_aliveSpawnedUnits.add(spawnedUnit)
    m_numSpawned++
  
  // --------------------------------------------------------------------------
  function unregisterSpawnedUnit(unit spawnedUnit)
    g_unitToSpawnWaveMap.remove(spawnedUnit)
    m_aliveSpawnedUnits.remove(spawnedUnit)

  // --------------------------------------------------------------------------
  function getSpawnedCount() returns int
    return m_numSpawned

  // --------------------------------------------------------------------------
  function getMaxSpawnCount() returns int
    return m_maxSpawnCount

  // --------------------------------------------------------------------------
  function getAliveCount() returns int
    return m_aliveSpawnedUnits.size()

  // --------------------------------------------------------------------------
  private function onDefProgressChanged()
    raiseProgressChangedEvent()
    if (m_progress != null)
      m_context.waveProgress = m_progress.getProgress()
    if (getProgress() == 1.0)
      // log("onDefProgressChanged", m_targetPlayer.getName() + " : progress finished!")
      complete()

  // --------------------------------------------------------------------------
  private function listenToDefProgressChangedEvent()
    if (m_progress == null)
      return

    unlistenToDefProgressChangedEvent()

    let progressChangedEvent = m_progress.onProgressChanged()
    if (progressChangedEvent != null)
      m_onDefProgressChangedEventHandler = progressChangedEvent.register((progress) -> onDefProgressChanged())

  // --------------------------------------------------------------------------
  private function unlistenToDefProgressChangedEvent()
    if (m_progress == null)
      return
    let progressChangedEvent = m_progress.onProgressChanged()
    if (progressChangedEvent != null)
      progressChangedEvent.unregister(m_onDefProgressChangedEventHandler)
    m_onDefProgressChangedEventHandler = INVALID_HANDLE

  // --------------------------------------------------------------------------
  protected function canSpawnNextUnit() returns bool
    if (getSpawnedCount() >= getMaxSpawnCount())
      return false
    let metadata = m_targetPlayer.getMetadata()
    if (metadata == null or metadata.getHasLostGame())
      return false
    return true

  // --------------------------------------------------------------------------
  private function prepareUnit(unit spawnedUnit) returns bool
    let unitMetadata = spawnedUnit.getMetadata()
    if (unitMetadata == null)
      Log.error("[SpawnWave.setTargetPlayer] : Unit has no metadata! : {0} ({1} : {2})".format(
        spawnedUnit.getName(),
        spawnedUnit.getTypeId().toString(),
        UnitId2StringBJ(spawnedUnit.getTypeId())))
      return false

    let commonUnitModifier = m_definition.getCommonUnitModifier()
    if (commonUnitModifier != null)
      commonUnitModifier.call(spawnedUnit, m_context)

    let unitModifier = m_definition.getUnitModifier(spawnedUnit.getTypeId())
    if (unitModifier != null)
      unitModifier.call(spawnedUnit, m_context)

    return true

  // --------------------------------------------------------------------------
  private function onUnitSpawned(SpawnUndeadUnitJob _job, unit spawnedUnit)

    spawnedUnit.removeAbility(g_goldCarrierBuff.abilId)
    spawnedUnit.removeAbility(g_goldCarrierBuff.buffId)

    m_spawnsPerGoldDropCounter++
    if (m_spawnsPerGoldDrop != 0 and m_spawnsPerGoldDropCounter == m_spawnsPerGoldDrop)
      m_spawnsPerGoldDropCounter = 0
      m_context.goldDrops++
      makeSpawnedUnitDropGold(spawnedUnit)

    registerSpawnedUnit(spawnedUnit)

  // --------------------------------------------------------------------------
  private function onGroupSpawned(SpawnUndeadUnitJob _job, group spawnedUnits)

    let firstUnit = spawnedUnits.getFirst()
    if (firstUnit == null)
      return

    let targetUnit = m_context.getTargetUnit()
    let targetPlayer = targetUnit.getOwner()

    for spawnedUnit in spawnedUnits
    //{
      let unitMetadata = spawnedUnit.getMetadata()

      let utc = unitMetadata.getUndeadTargetingComponent()
      if (utc != null)
        utc.setTargetUnit(targetUnit)

      let unitDef = getUnitDefinition(spawnedUnit.getTypeId())
      if (unitDef != null)
        spawnedUnit.fadeIn(unitDef.getVertexColor())
      else
        spawnedUnit.fadeIn()

      if (m_definition.getMinimapIconPath() != null)
        spawnedUnit.getOrAddMinimapIconComponent()
        ..update(m_definition.getMinimapIconPath(), m_definition.getMinimapIconColor())
        ..showOnlyFor(targetPlayer)
    //}

    if (localPlayer == targetPlayer and m_definition.getPingOnGroupSpawn())
      let color = m_definition.getPingOnGroupSpawnColor()
      PingMinimapEx(firstUnit.getX(), firstUnit.getY(), 3.0, color.red, color.green, color.blue, true)

    let playSoundOnGroupSpawn = m_definition.getPlaySoundOnGroupSpawn()
    if (playSoundOnGroupSpawn != null)
      playSoundOnGroupSpawn.playForPlayer(targetPlayer)

  // --------------------------------------------------------------------------
  private function makeSpawnedUnitDropGold(unit spawnedUnit)
    var goldDropAmount = m_definition.getGoldDropAmount(m_context)
    // spawnedUnit.awardGoldOnDeath(goldDropAmount.toRange(), 1.0)
    if (goldDropAmount == 0)
      return
    spawnedUnit.addAbility(g_goldCarrierBuff.abilId)
    goldDropAmount = min(goldDropAmount, 50) // 5 10g coins max
    while (goldDropAmount > 0)
      let coinTypeId = getCoinItemTypeFromGoldReward(goldDropAmount)
      spawnedUnit.awardItemOnDeath(g_coinItemSet, coinTypeId, 1.0)
      let coinValue = getGoldRewardFromCoinItemType(coinTypeId)
      goldDropAmount -= coinValue
      m_context.goldAvailable += coinValue

  // --------------------------------------------------------------------------
  protected function onUnitKilled(unit dyingUnit)
    unregisterSpawnedUnit(dyingUnit)

    if (m_context != null)
      m_context.incKillCount()

// ============================================================================
function onUnitDeath()
  let dyingUnit = GetDyingUnit()
  if (not g_unitToSpawnWaveMap.has(dyingUnit))
    return
  let spawnWave = g_unitToSpawnWaveMap.get(dyingUnit)
  spawnWave.onUnitKilled(dyingUnit)

// ============================================================================
init
  g_unitToSpawnWaveMap = new HashMap<unit, SpawnWave>()
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_DEATH, function onUnitDeath)