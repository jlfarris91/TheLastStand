package SpawnPointManager
import SpawnPoint
import GridList
import Bounds
import MapBounds
import Enumerable
import Linq
import LinkedListExtensions
import Unit_SpawnPoint
import TlsUnitIds
import Grid
import ClosureTimers
import FX
import ColorUtility

public SpawnPointManager g_SpawnPointManager

// ============================================================================
public interface ISpawnPointManager
  function getSpawnPoints() returns IEnumerable<ISpawnPoint>
  function getSpawnPointsInRange(vec2 pos, real range) returns IEnumerable<ISpawnPoint>

// ============================================================================
public class SpawnPointManager implements ISpawnPointManager
  private GridList<ISpawnPoint> _spawnPoints

  // --------------------------------------------------------------------------
  construct()
    let gridSize = SPAWN_POINT_COLLISION_SIZE
    let width = R2I(playableMapRect.width() / gridSize)
    let height = R2I(playableMapRect.height() / gridSize)

    Log.info("Size: " + I2S(width) + ", " + I2S(height))

    this._spawnPoints = new GridList<ISpawnPoint>(bounds(playableMin, playableMax), width, height)

    //doAfter(0.01) () ->
    //  createSpawnPoints()
    
  // --------------------------------------------------------------------------
  function createSpawnPoints()
    //let u = createUnit(Player(0), TlsUnitIds.spawnPoint, vec2(0,0), angle(0))

    Log.info("Creating spawn points...")

    let width = _spawnPoints.getWidth()
    let height = _spawnPoints.getHeight()
    let b = (width - 1) * (height - 1)

    for r = 0 to height - 1
      doAfter(0.01) () ->
        for c = 0 to width - 1
          let cell = cell(r, c)
          let cellBounds = _spawnPoints.getCellBounds(cell)
          //u.setPos(cellBounds.center())
          let u = createUnit(Player(0), TlsUnitIds.spawnPoint, cellBounds.center(), angle(0))
          let finalPos = u.getPos()
          let finalCell = _spawnPoints.getCell(finalPos)
          if (cell == finalCell)
            let sp = new SpawnPoint("SpawnPoint("+I2S(r)+","+I2S(c)+")", finalPos)
            registerSpawnPoint(sp)
            FX.createRangeEffect(finalPos, SPAWN_POINT_COLLISION_SIZE / 2.0, Colors.white)
          else
            u.setVertexColor(Colors.red)
            //u.remove()

        if (r == height - 1)
          Log.info("Created spawn points: " + I2S(_spawnPoints.size()))
          Log.info("Spawn point coverage: " + R2S((I2R(_spawnPoints.size()) / I2R(b)) * 100.0) + "%")
          //u.remove()

  // --------------------------------------------------------------------------
  function registerSpawnPointUnit(unit u)
    let sp = new SpawnPoint(u.getName(), u.getPos())
    registerSpawnPoint(sp)
    //u.remove()

  // --------------------------------------------------------------------------
  function registerSpawnPoint(SpawnPoint sp)
    this._spawnPoints.add(sp, sp.getPos())

  // --------------------------------------------------------------------------
  override function getSpawnPoints() returns IEnumerable<ISpawnPoint>
    return _spawnPoints

  // --------------------------------------------------------------------------
  override function getSpawnPointsInRange(vec2 pos, real range) returns IEnumerable<ISpawnPoint>
    return _spawnPoints.getElementsInRange(pos, range) (ISpawnPoint sp) ->
      return sp.getPos()

  // --------------------------------------------------------------------------
  protected function size() returns int
    return this._spawnPoints.size()

// ============================================================================
public function ISpawnPointManager.getClosestSpawnPoint(vec2 pos, real range) returns ISpawnPoint
  ISpawnPoint spawnPoint = null
  var closestRR = range * range

  let spawnPointsInRange = this.getSpawnPointsInRange(pos, range)
  let spawnPointsInRangeList = spawnPointsInRange.toList()

  for sp in spawnPointsInRangeList
    var dd = sp.getPos().distanceToSq(pos)
    if (dd < closestRR)
      spawnPoint = sp
      closestRR = dd

  destroy spawnPointsInRangeList
  destroy spawnPointsInRange

  return spawnPoint

// ============================================================================
public function ISpawnPointManager.getClosestSpawnPoints(vec2 pos, real range, int count) returns IEnumerable<ISpawnPoint>

  let spawnPointsInRange = this.getSpawnPointsInRange(pos, range)
  let spawnPointsInRangeList = spawnPointsInRange.toList()

  // Sort by closest distance to pos
  spawnPointsInRangeList.sortWith() (ISpawnPoint sp1, ISpawnPoint sp2) ->
    return sp1.getPos().distanceToSq(pos) < sp2.getPos().distanceToSq(pos) ? 1 : -1

  let final = spawnPointsInRangeList.asEnumerable<ISpawnPoint>().take(count)

  destroy spawnPointsInRangeList
  destroy spawnPointsInRange

  return final

// ============================================================================
public function ISpawnPointManager.getFurthestSpawnPoint(vec2 pos, real range) returns ISpawnPoint
  let rr = range * range
  ISpawnPoint spawnPoint = null
  var furthestRR = 0.0

  let spawnPointsInRange = this.getSpawnPointsInRange(pos, range)
  let spawnPointsInRangeList = spawnPointsInRange.toList()

  for sp in spawnPointsInRangeList
    var dd = sp.getPos().distanceToSq(pos)
    if (dd < rr and dd > furthestRR)
      spawnPoint = sp
      furthestRR = dd

  destroy spawnPointsInRangeList
  destroy spawnPointsInRange

  return spawnPoint

// ============================================================================
public function ISpawnPointManager.getFurthestSpawnPoints(vec2 pos, real range, int count) returns IEnumerable<ISpawnPoint>

  let spawnPointsInRange = this.getSpawnPointsInRange(pos, range)
  let spawnPointsInRangeList = spawnPointsInRange.toList()

  // Sort by furthest distance to pos
  spawnPointsInRangeList.sortWith() (ISpawnPoint sp1, ISpawnPoint sp2) ->
    return sp1.getPos().distanceToSq(pos) < sp2.getPos().distanceToSq(pos) ? -1 : 1

  let final = spawnPointsInRangeList.asEnumerable<ISpawnPoint>().take(count)

  destroy spawnPointsInRangeList
  destroy spawnPointsInRange

  return final

// ============================================================================
public function ISpawnPointManager.getRandomSpawnPointInRange(vec2 pos, real range) returns ISpawnPoint
  let spawnPointsInRange = this.getSpawnPointsInRange(pos, range)
  let spawnPointsInRangeList = spawnPointsInRange.toList()
  let spawnPoint = spawnPointsInRangeList.getRandom<ISpawnPoint>()
  destroy spawnPointsInRangeList
  destroy spawnPointsInRange
  return spawnPoint

// ============================================================================
public function ISpawnPointManager.getRandomSpawnPointsInRange(vec2 pos, real range, int count) returns IEnumerable<ISpawnPoint>
  let spawnPointsInRange = this.getSpawnPointsInRange(pos, range)
  let spawnPointsInRangeList = spawnPointsInRange.toList()

  let weightedPoints = spawnPointsInRangeList.toWeightedSet() (sp) ->
    return sp.getPos().distanceToSq(pos)

  let spawnPoints = weightedPoints.popRandom(count)

  destroy weightedPoints
  destroy spawnPointsInRangeList
  destroy spawnPointsInRange

  return spawnPoints.asEnumerable()

// ============================================================================
public function ISpawnPointManager.getRandomSpawnPoint() returns ISpawnPoint
  let spawnPointList = this.getSpawnPoints().toList()
  let spawnPoint = spawnPointList.getRandom()
  destroy spawnPointList
  return spawnPoint

// ============================================================================
/** Registers all spawn points that exist at map startup */
function registerAllSpawnPoints()
  let ug = GetUnitsOfTypeIdAll(TlsUnitIds.spawnPoint)
  Log.info("Number of units: " + I2S(CountUnitsInGroup(ug)))
  var i = 0
  for u in ug
    g_SpawnPointManager.registerSpawnPointUnit(u)
    i++
  ug.destr()
  Log.info("Number of spawn points: " + I2S(i))

// ============================================================================
init
  g_SpawnPointManager = new SpawnPointManager()
  registerAllSpawnPoints()