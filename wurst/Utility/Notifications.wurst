package Notifications
import UnitObjEditing
import ObjectIdGenerator
import UnitIds
import HashMap
import HashList

constant int UNIT_ID_NOTIFICATION = compiletime(HERO_ID_GEN.next())

HashMap<player, PlayerNotifications> g_playerToNotificationsMap
HashMap<unit, Notification> g_unitToNotificationMap

@compiletime public function createNotificationUnit()
  new HeroDefinition(UNIT_ID_NOTIFICATION, UnitIds.paladin)
    ..setAttacksEnabled(0)
    ..setScalingValue(0)
    ..setLevel(1)
    ..setName("Notification")
    ..setProperNames("Notification")
    ..setProperNamesUsed(1)
    ..setFoodCost(0)

public function showNotification(player p, string message, NotificationEventHandler callback)
  var notifications = g_playerToNotificationsMap.get(p)
  if (notifications == null)
    notifications = new PlayerNotifications(p)
    g_playerToNotificationsMap.put(p, notifications)

  var notification = notifications._messageToNotificationMap.get(message)
  if (notification == null)
    notification = notifications.createNotification(message)
  else
    notification.increaseNotificationCount()

  notification.setCallback(callback)

class PlayerNotifications
  player _player
  HashList<Notification> _notifications
  HashMap<string, Notification> _messageToNotificationMap

  construct(player p)
    this._player = p
    this._notifications = new HashList<Notification>()
    this._messageToNotificationMap = new HashMap<string, Notification>()

  ondestroy
    for notification in this._notifications
      destroy notification
    destroy this._notifications
    destroy this._messageToNotificationMap

  function createNotification(string message) returns Notification
    let pos = gg_rct_BaseUnits.randomPoint()
    var notificationUnit = CreateUnit(this._player, UNIT_ID_NOTIFICATION, pos.x, pos.y, GetRandomDirectionDeg())
    notificationUnit.setName(message)
    notificationUnit.setProperName(message)
    notificationUnit.setLevel(1, false)
    let notification = new Notification(this, notificationUnit, message)
    this._messageToNotificationMap.put(message, notification)
    return notification

  function destroyNotification(Notification notification)
    this._messageToNotificationMap.remove(notification._message)
    destroy notification

class Notification
  unit _unit
  string _message
  protected PlayerNotifications _notifications
  protected trigger _trigger
  protected conditionfunc _condition
  protected NotificationEventHandler _callback

  construct(PlayerNotifications notifications, unit u, string message)
    this._notifications = notifications
    this._unit = u
    this._message = message
    this._trigger = CreateTrigger()
    TriggerRegisterUnitEvent(this._trigger, this._unit, EVENT_UNIT_SELECTED)
    this._condition = Condition(function onNotificationSelected)
    this._trigger.addCondition(this._condition)
    g_unitToNotificationMap.put(this._unit, this)

  ondestroy
    g_unitToNotificationMap.remove(this._unit)
    this._unit.remove()
    DestroyCondition(this._condition)
    this._condition = null
    DestroyTrigger(this._trigger)
    this._trigger = null
    if (this._callback != null)
      destroy this._callback
      this._callback = null

  function increaseNotificationCount()
    this._unit.setLevel(this._unit.getLevel() + 1, true)

  function setCallback(NotificationEventHandler callback)
    this._callback = callback

  function raiseCallback()
    if (this._callback != null)
      this._callback.onNotified(this)
    this._notifications.destroyNotification(this)

public interface NotificationEventHandler
  abstract function onNotified(Notification notification)

function onNotificationSelected()
  let selectedUnit = GetTriggerUnit()
  let notification = g_unitToNotificationMap.get(selectedUnit)
  if (notification == null)
    return
  selectedUnit.getOwner().clearSelection()
  notification.raiseCallback()

init
  g_playerToNotificationsMap = new HashMap<player, PlayerNotifications>()
  g_unitToNotificationMap = new HashMap<unit, Notification>()
  