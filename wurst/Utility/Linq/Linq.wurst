package Linq
import Enumerable
import Action
import public LinqSelect
import public LinqSelectMany
import public LinqWhere
import Predicate
import Func
import ErrorHandling
import ErrorIf
import IEqualityComparer
import LinkedList
import HashList

// ============================================================================
public function IEnumerable<TSource>.forEach<TSource>(Action1<TSource> action)
  let iter = this.iterator()
  while (iter.hasNext())
    action.execute(iter.next())
  destroy iter
  destroy action

// ============================================================================
public function IEnumerable<TSource>.forEach<TSource>(Action2<int, TSource> action)
  let iter = this.iterator()
  var index = 0
  while (iter.hasNext())
    action.execute(index, iter.next())
    index++
  destroy iter
  destroy action

// ============================================================================
/** Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value. */
public function IEnumerable<TSource>.aggregate<TSource, TAccumulate, TResult>(TAccumulate seed, Func2<TAccumulate, TSource, TAccumulate> func, Func1<TAccumulate, TResult> resultSelector) returns TResult
  ErrorIf.argumentIsNull(func, "func")
  ErrorIf.argumentIsNull(resultSelector, "resultSelector")
  
  let iter = this.iterator()
  var accumulate = seed
  
  while (iter.hasNext())
    accumulate = func.execute(accumulate, iter.next())
  
  let result = resultSelector.execute(accumulate)
  
  destroy iter
  destroy func
  destroy resultSelector

  return result

// ============================================================================
/** Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value. */
public function IEnumerable<TSource>.aggregate<TSource, TAccumulate>(TAccumulate seed, Func2<TAccumulate, TSource, TAccumulate> func) returns TAccumulate
  ErrorIf.argumentIsNull(func, "func")
  
  let iter = this.iterator()
  var result = seed
  
  while (iter.hasNext())
    result = func.execute(result, iter.next())
  
  destroy iter
  destroy func

  return result

// ============================================================================
/** Applies an accumulator function over a sequence. */
public function IEnumerable<TSource>.aggregate<TSource>(Func2<TSource, TSource, TSource> func) returns TSource
  ErrorIf.argumentIsNull(func, "func")
  
  let iter = this.iterator()

  if (not iter.hasNext())
    error("Sequence contains no elements")

  var result = iter.next()
  
  while (iter.hasNext())
    result = func.execute(result, iter.next())
  
  destroy iter
  destroy func

  return result

// ============================================================================
/** Determines whether all elements of a sequence satisfy a condition. */
public function IEnumerable<TSource>.all<TSource>(Predicate<TSource> predicate) returns bool
  let iter = this.iterator()
  var result = true
  while (iter.hasNext())
    if (predicate.execute(iter.next()) == false)
      result = false
      break
  destroy iter
  destroy predicate
  return result

// ============================================================================
/** Determines whether any element of a sequence exists or satisfies a condition. */
public function IEnumerable<TSource>.any<TSource>(Predicate<TSource> predicate) returns bool
  let iter = this.iterator()
  var result = false
  while (iter.hasNext())
    if (predicate.execute(iter.next()) == true)
      result = true
      break
  destroy iter
  destroy predicate
  return result

// ============================================================================
/** Returns the LinkedList<T> typed as IEnumerable<T>. */
public function LinkedList<T>.asEnumerable<T>() returns IEnumerable<T>
  return new LinkedListEnumerableAdapter(this, false)

// ============================================================================
/** Returns the LinkedList<T> typed as IEnumerable<T>. */
public function LinkedList<T>.asEnumerable<T>(bool owner) returns IEnumerable<T>
  return new LinkedListEnumerableAdapter(this, owner)

// ============================================================================
/** Computes the average of a sequence of integer values. */
public function IEnumerable<int>.average() returns int
  let iter = this.iterator()
  var count = 0
  var result = 0
  while iter.hasNext()
    result += iter.next()
    count++
  if (count == 0)
    error("Sequence has no elements")
  result = R2I(result / count)
  destroy iter
  return result

// ============================================================================
/** Computes the average of a sequence of real values. */
public function IEnumerable<real>.average() returns real
  let iter = this.iterator()
  var count = 0
  var result = 0.0
  while iter.hasNext()
    result += iter.next()
    count++
  if (count == 0)
    error("Sequence has no elements")
  result = result / count
  destroy iter
  return result

// ============================================================================
/** Computes the average of a sequence of integer values that are obtained by invoking a transform function on each element of the input sequence. */
public function IEnumerable<TSource>.average<TSource>(Func1<TSource, int> selector) returns int
  let iter = this.iterator()
  var count = 0
  var result = 0
  while iter.hasNext()
    result += selector.execute(iter.next())
    count++
  if (count == 0)
    error("Sequence has no elements")
  result = R2I(result / count)
  destroy iter
  destroy selector
  return result

// ============================================================================
/** Computes the average of a sequence of real values that are obtained by invoking a transform function on each element of the input sequence. */
public function IEnumerable<TSource>.average<TSource>(Func1<TSource, real> selector) returns real
  let iter = this.iterator()
  var count = 0
  var result = 0.0
  while iter.hasNext()
    result += selector.execute(iter.next())
    count++
  if (count == 0)
    error("Sequence has no elements")
  result = result / count
  destroy iter
  destroy selector
  return result

// ============================================================================
/** Determines whether a sequence contains a specified element by using the default equality comparer. */
public function IEnumerable<TSource>.contains<TSource>(TSource value) returns bool
  let iter = this.iterator()
  var result = false
  while (iter.hasNext())
    if (iter.next() == value)
      result = true
      break
  destroy iter
  return result

// ============================================================================
/** Determines whether a sequence contains a specified element by using a specified IEqualityComparer<T>. */
public function IEnumerable<TSource>.contains<TSource>(TSource value, IEqualityComparer<TSource> comparer) returns bool
  ErrorIf.argumentIsNull(comparer, "comparer")
  let iter = this.iterator()
  var result = false
  while (iter.hasNext())
    if (comparer.equals(iter.next(), value))
      result = true
      break
  destroy iter
  destroy comparer
  return result

// ============================================================================
/** Returns the number of elements in a sequence. */
public function IEnumerable<TSource>.count<TSource>() returns int
  let iter = this.iterator()
  var result = 0
  while iter.hasNext()
    result++
  destroy iter
  return result

// ============================================================================
/** Returns a number that represents how many elements in the specified sequence satisfy a condition. */
public function IEnumerable<TSource>.count<TSource>(Predicate<TSource> predicate) returns int
  ErrorIf.argumentIsNull(predicate, "predicate")
  let iter = this.iterator()
  var result = 0
  while iter.hasNext()
    if (predicate.execute(iter.next()))
      result++
  destroy iter
  destroy predicate
  return result

// ============================================================================
/** Returns the elements of the specified sequence or the specified value in a singleton collection if the sequence is empty. */
public function IEnumerable<TSource>.defaultIfEmpty<TSource>(TSource defaultValue) returns IEnumerable<TSource>
  let iter = this.iterator()
  IEnumerable<TSource> result

  if (not iter.hasNext())
    let list = new LinkedList<TSource>()
    list.add(defaultValue)
    result = new LinkedListEnumerableAdapter(list, true)
  else
    result = new EnumerableAdapter(this, true)

  destroy iter

  return result

// ============================================================================
/** Returns distinct elements from a sequence by using the default equality comparer to compare values. */
public function IEnumerable<TSource>.distinct<TSource>() returns IEnumerable<TSource>
  let result = new LinkedList<TSource>()
  let hashSet = new HashList<TSource>()

  this.forEach() (TSource elem) ->
    if (not hashSet.has(elem))
      hashSet.add(elem)
      result.add(elem)

  destroy hashSet
  
  return result.asEnumerable(true)

// TODO: ElementAt  

// ============================================================================
public function IEnumerable<TSource>.min<TSource>(Func1<TSource, int> selector) returns TSource
  let iter = this.iterator()
  var min = INT_MAX
  var result = 0 castTo TSource
  var hasElements = false
  
  while (iter.hasNext())
    hasElements = true
    let element = iter.next()
    let value = selector.execute(element)
    if (value < min)
      min = value
      result = element

  if (not hasElements)
    error("Sequence contains no elements")

  destroy iter
  destroy selector

  return result

// ============================================================================
public function IEnumerable<TSource>.min<TSource>(Func1<TSource, real> selector) returns TSource
  let iter = this.iterator()
  var min = REAL_MAX
  var result = 0 castTo TSource
  var hasElements = false
  
  while (iter.hasNext())
    hasElements = true
    let element = iter.next()
    let value = selector.execute(element)
    if (value < min)
      min = value
      result = element

  if (not hasElements)
    error("Sequence contains no elements")

  destroy iter
  destroy selector

  return result

// ============================================================================
public function IEnumerable<TSource>.max<TSource>(Func1<TSource, int> selector) returns TSource
  let iter = this.iterator()
  var max = INT_MIN
  var result = 0 castTo TSource
  var hasElements = false
  
  while (iter.hasNext())
    hasElements = true
    let element = iter.next()
    let value = selector.execute(element)
    if (value > max)
      max = value
      result = element

  if (not hasElements)
    error("Sequence contains no elements")

  destroy iter
  destroy selector

  return result

// ============================================================================
public function IEnumerable<TSource>.max<TSource>(Func1<TSource, real> selector) returns TSource
  let iter = this.iterator()
  var max = REAL_MIN
  var result = 0 castTo TSource
  var hasElements = false
  
  while (iter.hasNext())
    hasElements = true
    let element = iter.next()
    let value = selector.execute(element)
    if (value > max)
      max = value
      result = element

  if (not hasElements)
    error("Sequence contains no elements")

  destroy iter
  destroy selector

  return result


// ============================================================================
class EnumerableAdapter<T> implements IEnumerable<T>
  private IEnumerable<T> _child
  private bool _ownsChild

  // --------------------------------------------------------------------------
  construct(IEnumerable<T> child, bool ownsChild)
    _child = child
    _ownsChild = ownsChild

  ondestroy
    if (_ownsChild)
      destroy _child
    _child = null

  // --------------------------------------------------------------------------
  override function iterator() returns IEnumerator<T>
    return _child.iterator()

// ============================================================================
class LinkedListEnumerableAdapter<T> implements IEnumerable<T>
  private LinkedList<T> _list
  private bool _ownsList

  // --------------------------------------------------------------------------
  construct(LinkedList<T> list, bool ownsList)
    _list = list
    _ownsList = ownsList

  ondestroy
    if (_ownsList)
      destroy _list
    _list = null

  // --------------------------------------------------------------------------
  override function iterator() returns IEnumerator<T>
    return new LinkedListEnumeratorAdapter<T>(_list.iterator())

// ============================================================================
class LinkedListEnumeratorAdapter<T> implements IEnumerator<T>
  private LLIterator<T> _iterator

  // --------------------------------------------------------------------------
  construct(LLIterator<T> iterator)
    _iterator = iterator

  // --------------------------------------------------------------------------
  ondestroy
    destroy _iterator
    _iterator = null

  // --------------------------------------------------------------------------
  override function hasNext() returns bool
    return _iterator.hasNext()

  // --------------------------------------------------------------------------
  override function next() returns T
    return _iterator.next()