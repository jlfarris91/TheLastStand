package Math

rect g_WorldBounds
constant real BOUNDARY_OFFSET = 512.0

public function clamp(int value, int min, int max) returns int
  return IMaxBJ(IMinBJ(value, max), min)

public function clamp(real value, real min, real max) returns real
  return RMaxBJ(RMinBJ(value, max), min)

public function clamp01(real value) returns real
  return RMaxBJ(RMinBJ(value, 1.0), 0.0)

public function clampToWorldBounds(vec2 pos, real radius) returns vec2
  var x = clamp(
    pos.x,
    g_WorldBounds.getMinX() + radius + BOUNDARY_OFFSET,
    (g_WorldBounds.getMaxX() - radius) - BOUNDARY_OFFSET)
  var y = clamp(
    pos.y,
    g_WorldBounds.getMinY() + radius + BOUNDARY_OFFSET,
    (g_WorldBounds.getMaxY() - radius) - BOUNDARY_OFFSET)
  return vec2(x, y)

public function wrap(int value, int min, int max) returns int
  var result = value
  let d = max - min
  if (result < min)
    result = (max + 1) - ModuloInteger(IAbsBJ(min - result), d + 1)
  if (result > max)
    result = min + ModuloInteger(IAbsBJ((max + 1) - result), d + 1)
  return result

public function wrapMaxEx(int value, int min, int max) returns int
  return wrap(value, min, max - 1)

public function passesChanceCheck(real chance) returns bool
  return GetRandomReal(0.0, 1.0) < chance

public function moveTowards(real current, real target, real maxSpeed) returns real
  let dist = target - current
  if (RAbsBJ(dist) < RAbsBJ(maxSpeed))
    return target
  return current + RAbsBJ(maxSpeed) * RSignBJ(dist)

public function lerp(real start, real _end, real t) returns real
  return start + (_end - start) * t

public function lerpInt(int start, int _end, real t) returns int
  return start + R2I(I2R(_end - start) * t)

init
  g_WorldBounds = GetPlayableMapRect()

@test public function wrap1()
  assertTrue(wrap(-5, 0, 3) == 3)
  assertTrue(wrap(-4, 0, 3) == 0)
  assertTrue(wrap(-3, 0, 3) == 1)
  assertTrue(wrap(-2, 0, 3) == 2)
  assertTrue(wrap(-1, 0, 3) == 3)
  assertTrue(wrap( 0, 0, 3) == 0)
  assertTrue(wrap( 1, 0, 3) == 1)
  assertTrue(wrap( 2, 0, 3) == 2)
  assertTrue(wrap( 3, 0, 3) == 3)
  assertTrue(wrap( 4, 0, 3) == 0)
  assertTrue(wrap( 5, 0, 3) == 1)
  assertTrue(wrap( 6, 0, 3) == 2)
  assertTrue(wrap( 7, 0, 3) == 3)

@test public function wrap2()
  assertTrue(wrap(-5, 2, 5) == 3)
  assertTrue(wrap(-4, 2, 5) == 4)
  assertTrue(wrap(-3, 2, 5) == 5)
  assertTrue(wrap(-2, 2, 5) == 2)
  assertTrue(wrap(-1, 2, 5) == 3)
  assertTrue(wrap( 0, 2, 5) == 4)
  assertTrue(wrap( 1, 2, 5) == 5)
  assertTrue(wrap( 2, 2, 5) == 2)
  assertTrue(wrap( 3, 2, 5) == 3)
  assertTrue(wrap( 4, 2, 5) == 4)
  assertTrue(wrap( 5, 2, 5) == 5)
  assertTrue(wrap( 6, 2, 5) == 2)
  assertTrue(wrap( 7, 2, 5) == 3)

@test public function wrap3()
  assertTrue(wrap(-180, 0, 359) == 180)
  assertTrue(wrap( -90, 0, 359) == 270)
  assertTrue(wrap(   0, 0, 359) == 0)
  assertTrue(wrap(  90, 0, 359) == 90)
  assertTrue(wrap( 180, 0, 359) == 180)
  assertTrue(wrap( 270, 0, 359) == 270)

@test public function wrapMaxEx()
  assertTrue(wrapMaxEx(-180, 0, 360) == 180)
  assertTrue(wrapMaxEx( -90, 0, 360) == 270)
  assertTrue(wrapMaxEx(   0, 0, 360) == 0)
  assertTrue(wrapMaxEx(  90, 0, 360) == 90)
  assertTrue(wrapMaxEx( 180, 0, 360) == 180)
  assertTrue(wrapMaxEx( 270, 0, 360) == 270)

@test public function wrapMaxEx2()
  assertTrue(wrapMaxEx( -45, 0, 360) == 315)
  assertTrue(wrapMaxEx(   0, 0, 360) == 0)
  assertTrue(wrapMaxEx( 360, 0, 360) == 0)
  assertTrue(wrapMaxEx( 405, 0, 360) == 45)