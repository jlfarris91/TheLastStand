package SpawnDirectors
import ClosureTimers
import Range
import Jobs
import Deck
import SpawnUndeadUnitJob
import Action
import HashMap
import GameConstants
import Spawning
import CancellationToken
import ErrorHandling
import GroupUtils
import SoundUtils
import Func
import Vector
import Math
import UndeadTargetService
import UnitMetadata
import BuffObjEditing
import Coins
import UnitModifiers
import WaveGeneratorCommon
import BossItemLibrary
import Elites
import TlsUpgradeIds
import LinkedList
import HumanPlayerComponent
import GroupExtensions
import UndeadTargetingComponent
import TlsUnitDefinition
import UnitExtensions
import MinimapIconComponent
import GameInstance
import RealTime
import Time
import Events
import RegisterEvents

constant real TOO_CHEAP_COEFF = 6

LinkedList<Director> g_directors = new LinkedList<Director>()
HashMap<unit, Admin> g_unitToAdminMap

SpawnUndeadUnitDirector g_nightZombieDirector
SpawnUndeadUnitDirector g_nightEliteDirector

tuple drawnCard(Card card, int tier, int cost)
constant drawnCard INVALID_CARD = drawnCard(null, -1, -1)

int array[MAX_ELITE_TIER] TIER_VALUE_MULTIPLIER = [1, 6, 36]

// ============================================================================
public class SpawnDefinition
  private string m_id
  private SpawnRange m_spawnRange
  private ITieredUnitTypeProvider m_unitTypeProvider
  private Func1<SpawnContext, int> m_maxSpawnCount
  private Func1<SpawnContext, int> m_groupSize
  private Func1<SpawnContext, int> m_goldReward
  private Action2<unit, SpawnContext> m_commonUnitModifier
  private IterableMap<int, Action2<unit, SpawnContext>> m_unitModifiers
  private Vector<string> m_tags
  private bool m_waitForFullSpawnGroup = false
  private bool m_useUnitRecycler = false
  private rangeReal m_facingAngleRange = REAL_RANGE_ZERO
  private SpawnPointProviderType m_spawnPointProviderType = SpawnPointProviderType.CACHED_HOSTILE
  private SoundDefinition m_playSoundOnGroupSpawn = null
  private string m_minimapIconPath = null
  private color m_minimapIconColor = color(255, 255, 255)
  private bool m_pingOnGroupSpawn = false
  private color m_pingOnGroupSpawnColor = color(255, 255, 255)
  private Func1<SpawnContext, int> m_spawnsPerGoldDrop
  private Func1<SpawnContext, int> m_goldDropAmount
  private int m_techIdToAdvance
  private int m_tierCount = MAX_ELITE_TIER

  // --------------------------------------------------------------------------
  construct(string id)
    m_id = id
    m_tags = new Vector<string>()

  // --------------------------------------------------------------------------
  ondestroy

    if (m_unitTypeProvider != null)
      destroy m_unitTypeProvider
      m_unitTypeProvider = null

    if (m_maxSpawnCount != null)
      m_maxSpawnCount.release()
      m_maxSpawnCount = null

    if (m_groupSize != null)
      m_groupSize.release()
      m_groupSize = null

    if (m_spawnsPerGoldDrop != null)
      m_spawnsPerGoldDrop.release()
      m_spawnsPerGoldDrop = null

    if (m_goldDropAmount != null)
      m_goldDropAmount.release()
      m_goldDropAmount = null

    if (m_commonUnitModifier != null)
      m_commonUnitModifier.release()
      m_commonUnitModifier = null

    if (m_unitModifiers != null)
      for unitTypeId in m_unitModifiers
        m_unitModifiers.get(unitTypeId).release()
      destroy m_unitModifiers
      m_unitModifiers = null

    if (m_goldReward != null)
      m_goldReward.release()
      m_goldReward = null

    destroy m_tags
    m_tags = null

  // --------------------------------------------------------------------------
  function getId() returns string
    return m_id

  // --------------------------------------------------------------------------
  function getTierCount() returns int
    return m_tierCount
  
  // --------------------------------------------------------------------------
  function setTierCount(int value)
    m_tierCount = value

  // --------------------------------------------------------------------------
  function setSpawnRange(SpawnRange spawnRange)
    m_spawnRange = spawnRange

  // --------------------------------------------------------------------------
  function getSpawnRange() returns SpawnRange
    return m_spawnRange

  // --------------------------------------------------------------------------
  function setUnitTypeProvider(ITieredUnitTypeProvider unitTypeProvider)
    m_unitTypeProvider = unitTypeProvider

  // --------------------------------------------------------------------------
  function getUnitTypeProvider() returns ITieredUnitTypeProvider
    return m_unitTypeProvider

  // --------------------------------------------------------------------------
  function setMaxSpawnCount(Func1<SpawnContext, int> value)
    value.acquire()
    if (m_maxSpawnCount != null)
      m_maxSpawnCount.release()
    m_maxSpawnCount = value

  // --------------------------------------------------------------------------
  function getMaxSpawnCount(SpawnContext context) returns int
    if (m_maxSpawnCount == null)
      return 1
    return clamp(m_maxSpawnCount.call(context), 1, UNLIMITED)

  // --------------------------------------------------------------------------
  function getGroupSize(SpawnContext context) returns int
    if (m_groupSize == null)
      return 1
    return min(m_groupSize.call(context), getMaxSpawnCount(context))

  // --------------------------------------------------------------------------
  function setGroupSize(Func1<SpawnContext, int> value)
    value.acquire()
    if (m_groupSize != null)
      m_groupSize.release()
    m_groupSize = value

  // --------------------------------------------------------------------------
  function setSpawnsPerGoldDrop(Func1<SpawnContext, int> value)
    value.acquire()
    if (m_spawnsPerGoldDrop != null)
      m_spawnsPerGoldDrop.release()
    m_spawnsPerGoldDrop = value

  // --------------------------------------------------------------------------
  function getSpawnsPerGoldDrop(SpawnContext context) returns int
    if (m_spawnsPerGoldDrop == null)
      return 0
    return max(m_spawnsPerGoldDrop.call(context), 0)

  // --------------------------------------------------------------------------
  function setGoldDropAmount(Func1<SpawnContext, int> value)
    value.acquire()
    if (m_goldDropAmount != null)
      m_goldDropAmount.release()
    m_goldDropAmount = value

  // --------------------------------------------------------------------------
  function getGoldDropAmount(SpawnContext context) returns int
    if (m_goldDropAmount == null)
      return 0
    return max(m_goldDropAmount.call(context), 0)

  // --------------------------------------------------------------------------
  function setCommonUnitModifier(Action2<unit, SpawnContext> action)
    action.acquire()
    if (m_commonUnitModifier != null)
      m_commonUnitModifier.release()
    m_commonUnitModifier = action

  // --------------------------------------------------------------------------
  function getCommonUnitModifier() returns Action2<unit, SpawnContext>
    return m_commonUnitModifier

  // --------------------------------------------------------------------------
  function setUnitModifier(int unitTypeId, Action2<unit, SpawnContext> action)
    action.acquire()
    if (m_unitModifiers == null)
      m_unitModifiers = new IterableMap<int, Action2<unit, SpawnContext>>()
    let existing = m_unitModifiers.get(unitTypeId)
    if (existing != null)
      existing.release()
    m_unitModifiers.put(unitTypeId, action)

  // --------------------------------------------------------------------------
  function getUnitModifier(int unitTypeId) returns Action2<unit, SpawnContext>
    if (m_unitModifiers == null)
      return null
    return m_unitModifiers.get(unitTypeId)

  // --------------------------------------------------------------------------
  function setTags(vararg string tags)
    m_tags.clear()
    for tag in tags
      m_tags.add(tag)

  // --------------------------------------------------------------------------
  function getTags() returns Vector<string>
    return m_tags

  // --------------------------------------------------------------------------
  function getWaitForFullSpawnGroup() returns bool
    return m_waitForFullSpawnGroup

  // --------------------------------------------------------------------------
  function setWaitForFullSpawnGroup(bool value)
    m_waitForFullSpawnGroup = value

  // --------------------------------------------------------------------------
  function getUseUnitRecycler() returns bool
    return m_useUnitRecycler

  // --------------------------------------------------------------------------
  function setUseUnitRecycler(bool value)
    m_useUnitRecycler = value

  // --------------------------------------------------------------------------
  function getGoldReward(SpawnContext context) returns int
    return m_goldReward != null ? m_goldReward.call(context) : 0

  // --------------------------------------------------------------------------
  function setGoldReward(Func1<SpawnContext, int> value)
    value.acquire()
    if (m_goldReward != null)
      m_goldReward.release()
    m_goldReward = value

  // --------------------------------------------------------------------------
  function getFacingAngleRange() returns rangeReal
    return m_facingAngleRange

  // --------------------------------------------------------------------------
  function setFacingAngleRange(rangeReal range)
    m_facingAngleRange = range
  
  // --------------------------------------------------------------------------
  function getSpawnPointProviderType() returns SpawnPointProviderType
    return m_spawnPointProviderType
  
  // --------------------------------------------------------------------------
  function setSpawnPointProviderType(SpawnPointProviderType value)
    m_spawnPointProviderType = value

  // --------------------------------------------------------------------------
  function playSoundOnGroupSpawn(SoundDefinition definition)
    m_playSoundOnGroupSpawn = definition

  // --------------------------------------------------------------------------
  function getPlaySoundOnGroupSpawn() returns SoundDefinition
    return m_playSoundOnGroupSpawn

  // --------------------------------------------------------------------------
  function showMinimapIcon(string iconPath, color color)
    m_minimapIconPath = iconPath
    m_minimapIconColor = color

  // --------------------------------------------------------------------------
  function getMinimapIconPath() returns string
    return m_minimapIconPath

  // --------------------------------------------------------------------------
  function getMinimapIconColor() returns color
    return m_minimapIconColor
  
  // --------------------------------------------------------------------------
  function pingOnGroupSpawn(color color)
    m_pingOnGroupSpawn = true
    m_pingOnGroupSpawnColor = color
  
  // --------------------------------------------------------------------------
  function getPingOnGroupSpawn() returns bool
    return m_pingOnGroupSpawn
  
  // --------------------------------------------------------------------------
  function getPingOnGroupSpawnColor() returns color
    return m_pingOnGroupSpawnColor
  
  // --------------------------------------------------------------------------
  function getTechIdToAdvance() returns int
    return m_techIdToAdvance
  
  // --------------------------------------------------------------------------
  function setTechIdToAdvance(int value)
    m_techIdToAdvance = value

// ============================================================================
public function SpawnDefinition.setupForBoss()
  this..showMinimapIcon(MINIMAP_ICON_PATH_BOSS, MINIMAP_ICON_COLOR_BOSS)
      ..pingOnGroupSpawn(MINIMAP_ICON_COLOR_BOSS)
      ..setTechIdToAdvance(TlsUpgradeIds.bossesKilled)

// ============================================================================
public class SpawnCard extends Card
  private SpawnDefinition m_spawnDefinition

  // --------------------------------------------------------------------------
  construct(SpawnDefinition spawnDefinition)
    super(spawnDefinition.getId())
    m_spawnDefinition = spawnDefinition

  // --------------------------------------------------------------------------
  function getSpawnDefinition() returns SpawnDefinition
    return m_spawnDefinition
  
  // --------------------------------------------------------------------------
  function setSpawnDefinition(SpawnDefinition value)
    m_spawnDefinition = value

// ============================================================================
public class Admin
  private string m_id
  private group m_ownedUnits = getGroup()

  private Event2<Admin, unit> m_onUnitRegistered
  private Event2<Admin, unit> m_onUnitUnregistered

  // --------------------------------------------------------------------------
  construct(string id)
    m_id = id

  // --------------------------------------------------------------------------
  ondestroy
    m_ownedUnits.release()

    if (m_onUnitRegistered != null)
      destroy m_onUnitRegistered
      m_onUnitRegistered = null

    if (m_onUnitUnregistered != null)
      destroy m_onUnitUnregistered
      m_onUnitUnregistered = null

  // --------------------------------------------------------------------------
  function getOwnedUnits() returns group
    return m_ownedUnits

  // --------------------------------------------------------------------------
  function onUnitRegistered() returns IEvent2<Admin, unit>
    if (m_onUnitRegistered == null)
      m_onUnitRegistered = new Event2<Admin, unit>()
    return m_onUnitRegistered

  // --------------------------------------------------------------------------
  function onUnitUnregistered() returns IEvent2<Admin, unit>
    if (m_onUnitUnregistered == null)
      m_onUnitUnregistered = new Event2<Admin, unit>()
    return m_onUnitUnregistered

  // --------------------------------------------------------------------------
  function registerOwnedUnit(unit _unit)

    let existingAdmin = g_unitToAdminMap.get(_unit)
    if (existingAdmin != null and existingAdmin != this)
      error("Unit belongs to a different admin")
      return

    g_unitToAdminMap.put(_unit, this)
    m_ownedUnits.addUnit(_unit)

    if (m_onUnitRegistered != null)
      m_onUnitRegistered.call(this, _unit)

  // --------------------------------------------------------------------------
  function unregisterOwnedUnit(unit _unit)

    let existingAdmin = g_unitToAdminMap.get(_unit)
    if (existingAdmin == null)
      return

    if (existingAdmin != this)
      error("Unit belongs to a different admin")
      return
    
    g_unitToAdminMap.remove(_unit)
    m_ownedUnits.removeUnit(_unit)

    if (m_onUnitUnregistered != null)
      m_onUnitUnregistered.call(this, _unit)

  // --------------------------------------------------------------------------
  protected function onOwnedUnitKilled(unit dyingUnit)
    unregisterOwnedUnit(dyingUnit)

// ============================================================================
public abstract class Director
  private int m_id
  private string m_name
  private real m_credits
  private bool m_enabled
  private Deck m_deck
  private real m_creditsOnActivation = 0.0
  private real m_creditMultiplier = 1.0
  private CallbackPeriodic m_creditGeneratorTimer
  private CancellationToken m_ct
  private Thread m_workerThread
  private Admin m_admin
  
  private static int s_directorIdGen = 0

  // --------------------------------------------------------------------------
  construct(string name)
    m_name = name

    m_workerThread = new Thread(name + "_worker")
    ..setTickInterval(0.3)
    ..setMaxWorkPerTick(1)

    m_admin = new Admin(name)

    s_directorIdGen++
    m_id = s_directorIdGen

    g_directors.add(this)

  // --------------------------------------------------------------------------
  ondestroy

    if (m_enabled)
      disable()

    g_directors.remove(this)

    if (m_ct != null)
      m_ct.cancelAndRelease()
      m_ct = null

    if (m_deck != null)
      destroy m_deck
      m_deck = null

    if (m_workerThread != null)
      destroy m_workerThread
      m_workerThread = null

    destroy m_admin
    m_admin = null

  // --------------------------------------------------------------------------
  static function getStaticDirectorIdGen() returns int
    return s_directorIdGen

  // --------------------------------------------------------------------------
  static function getAllDirectors() returns LinkedList<Director>
    return g_directors

  // --------------------------------------------------------------------------
  function getId() returns int
    return m_id

  // --------------------------------------------------------------------------
  function getName() returns string
    return m_name

  // --------------------------------------------------------------------------
  function getWorkerThread() returns Thread
    return m_workerThread

  // --------------------------------------------------------------------------
  function getAdmin() returns Admin
    return m_admin

  // --------------------------------------------------------------------------
  function getCancellationToken() returns CancellationToken
    if (m_ct == null)
      m_ct = new CancellationToken()..acquire()
    return m_ct

  // --------------------------------------------------------------------------
  function getCredits() returns real
    return m_credits

  // --------------------------------------------------------------------------
  function getCreditsInt() returns int
    return m_credits.floor()
  
  // --------------------------------------------------------------------------
  function setCredits(real value)
    m_credits = value

  // --------------------------------------------------------------------------
  function getDeck() returns Deck
    return m_deck

  // --------------------------------------------------------------------------
  function setDeck(Deck deck)
    m_deck = deck

  // --------------------------------------------------------------------------
  function getCreditsOnActivation() returns real
    return m_creditsOnActivation
  
  // --------------------------------------------------------------------------
  function setCreditsOnActivation(real value)
    m_creditsOnActivation = value

  // --------------------------------------------------------------------------
  function getCreditMultiplier() returns real
    return m_creditMultiplier
  
  // --------------------------------------------------------------------------
  function setCreditMultiplier(real value)
    m_creditMultiplier = value
  
  // --------------------------------------------------------------------------
  function getEnabled() returns bool
    return m_enabled
  
  // --------------------------------------------------------------------------
  function setEnabled(bool value)
    if (m_enabled != value)
      m_enabled = value
      if (value)
        onEnabled()
      else
        onDisabled()

  // --------------------------------------------------------------------------
  function enable()
    setEnabled(true)

  // --------------------------------------------------------------------------
  function disable()
    setEnabled(false)

  // --------------------------------------------------------------------------
  protected function onEnabled()

    if (m_ct != null)
      error("Cancellation token should be null")

    m_ct = new CancellationToken()..acquire()
  
    m_credits = m_creditsOnActivation

    m_creditGeneratorTimer = doPeriodically(1.0, cb -> generateCredits())

    m_workerThread.setEnabled(true)

  // --------------------------------------------------------------------------
  protected function onDisabled()

    if (m_ct != null)
      m_ct.cancelAndRelease()
      m_ct = null

    if (m_creditGeneratorTimer != null)
      destroy m_creditGeneratorTimer
      m_creditGeneratorTimer = null

    m_workerThread.setEnabled(false)

  // --------------------------------------------------------------------------
  function canDrawCard() returns bool
    return true

  // --------------------------------------------------------------------------
  abstract function drawCard() returns drawnCard

  // --------------------------------------------------------------------------
  abstract function activateCard(drawnCard card) returns bool

  // --------------------------------------------------------------------------
  protected function getDifficultyCoefficient() returns real
    return g_GameInstance.getGameDifficultyCoeff()

  // --------------------------------------------------------------------------
  protected function getCreditsPerSecond() returns real
    return m_creditMultiplier * (1 + 0.4 * getDifficultyCoefficient())

  // --------------------------------------------------------------------------
  protected function generateCredits()
    m_credits += getCreditsPerSecond()

  // --------------------------------------------------------------------------
  function writeDebugString(Action1<string> output)

    output.acquire()
    
    output.call("Credits per second: " + getCreditsPerSecond().toString())

    output.release()

// ============================================================================
public abstract class ContinuousDirector extends Director
  private rangeReal m_fastActivationIntervalRange
  private rangeReal m_slowActivationIntervalRange
  private ContinuousDirectorJob m_job

  // --------------------------------------------------------------------------
  construct(string name)
    super(name)

  // --------------------------------------------------------------------------
  function getFastActivationIntervalRange() returns rangeReal
    return m_fastActivationIntervalRange
  
  // --------------------------------------------------------------------------
  function setFastActivationIntervalRange(rangeReal value)
    m_fastActivationIntervalRange = value

  // --------------------------------------------------------------------------
  function getSlowActivationIntervalRange() returns rangeReal
    return m_slowActivationIntervalRange
  
  // --------------------------------------------------------------------------
  function setSlowActivationIntervalRange(rangeReal value)
    m_slowActivationIntervalRange = value

  // --------------------------------------------------------------------------
  override protected function onEnabled()
    super.onEnabled()

    m_job = new ContinuousDirectorJob(this)..acquire()
    getWorkerThread().enqueue(getCancellationToken(), m_job)

  // --------------------------------------------------------------------------
  override protected function onDisabled()
    super.onDisabled()

    if (m_job != null)
      m_job.complete()
      m_job.release()
      m_job = null

  // --------------------------------------------------------------------------
  override function writeDebugString(Action1<string> output)

    output.acquire()

    super.writeDebugString(output)

    if (m_job != null)
    //{
      let selectedCard = m_job.getSelectedCard()

      if (selectedCard.card != null)
        output.call("Selected Card: {0} t:{1} c:{2}x{3}={4}".format(
          selectedCard.card.getId(),
          selectedCard.tier.toString(),
          selectedCard.card.getCost().toString(),
          TIER_VALUE_MULTIPLIER[selectedCard.tier].toString(),
          selectedCard.cost.toString()))
      else
        output.call("Selected Card: none")

      output.call("Next Activation In: " + m_job.getActivationTimer().toString())
      output.call("Last Activation: " + (m_job.getLastActivationSucceeded() ? "succeeded" : m_job.getLastActivationFailedReason()))
    //}    
    
    output.release()

// ============================================================================
public class SpawnUndeadUnitDirector extends ContinuousDirector
  private player m_targetPlayer
  private real m_playerDifficulty
  private int m_spawnsPerGoldDropCounter
  private int m_goldAvailable
  private int m_goldDrops
  private SpawnContext m_context

  private Func1<SpawnContext, int> m_maxSpawnCount
  private Func1<SpawnContext, int> m_maxAliveCount
  private Func1<SpawnContext, int> m_goldDropAmount
  private Func1<SpawnContext, int> m_spawnsPerGoldDrop

  // --------------------------------------------------------------------------
  construct(string id, player targetPlayer)
    super(id)
    m_targetPlayer = targetPlayer

    m_playerDifficulty = m_targetPlayer.getHumanPlayerComponentRequired().getDifficulty()
    
    m_context = new SpawnContext().acquire()
    m_context.setDifficultyCoeff(getDifficultyCoefficient())

  // --------------------------------------------------------------------------
  ondestroy

    if (m_maxSpawnCount != null)
      m_maxSpawnCount.release()
      m_maxSpawnCount = null

    if (m_maxAliveCount != null)
      m_maxAliveCount.release()
      m_maxAliveCount = null

    if (m_goldDropAmount != null)
      m_goldDropAmount.release()
      m_goldDropAmount = null

    if (m_spawnsPerGoldDrop != null)
      m_spawnsPerGoldDrop.release()
      m_spawnsPerGoldDrop = null

    if (m_context != null)
      m_context.release()
      m_context = null

  // --------------------------------------------------------------------------
  function getGoldDropAmount() returns int
    return m_goldDropAmount != null ? m_goldDropAmount.call(m_context) : 0

  // --------------------------------------------------------------------------
  function setGoldDropAmount(Func1<SpawnContext, int> value)
    value.acquire()
    if (m_goldDropAmount != null)
      m_goldDropAmount.release()
    m_goldDropAmount = value

  // --------------------------------------------------------------------------
  function getSpawnsPerGoldDrop() returns int
    return m_spawnsPerGoldDrop != null ? m_spawnsPerGoldDrop.call(m_context) : 0
  
  // --------------------------------------------------------------------------
  function setSpawnsPerGoldDrop(Func1<SpawnContext, int> value)
    value.acquire()
    if (m_spawnsPerGoldDrop != null)
      m_spawnsPerGoldDrop.release()
    m_spawnsPerGoldDrop = value

  // --------------------------------------------------------------------------
  function getMaxSpawnCount() returns int
    return m_maxSpawnCount != null ? m_maxSpawnCount.call(m_context) : UNLIMITED
  
  // --------------------------------------------------------------------------
  function setMaxSpawnCount(Func1<SpawnContext, int> value)
    value.acquire()
    if (m_maxSpawnCount != null)
      m_maxSpawnCount.release()
    m_maxSpawnCount = value

  // --------------------------------------------------------------------------
  function getMaxAliveCount() returns int
    return m_maxAliveCount != null ? m_maxAliveCount.call(m_context) : UNLIMITED
  
  // --------------------------------------------------------------------------
  function setMaxAliveCount(Func1<SpawnContext, int> value)
    value.acquire()
    if (m_maxAliveCount != null)
      m_maxAliveCount.release()
    m_maxAliveCount = value 

  // --------------------------------------------------------------------------
  override protected function onEnabled()
    super.onEnabled()

    m_goldAvailable = 0
    m_spawnsPerGoldDropCounter = 0 

  // --------------------------------------------------------------------------
  override protected function getDifficultyCoefficient() returns real
    let difficultyValue = m_playerDifficulty
    let playerCount = 1
    let playerFactor = 1
    let timeFactor = 0.0506 * difficultyValue * Pow(playerCount.toReal(), 0.2)
    let stageFactor = Pow(1.15, g_GameInstance.getNightsSurvived().toReal())
    return (playerFactor + getRealTimeMinutes() * timeFactor) * stageFactor

  // --------------------------------------------------------------------------
  override function canDrawCard() returns bool
    return getAdmin().getOwnedUnits().size() < getMaxAliveCount()

  // --------------------------------------------------------------------------
  override function drawCard() returns drawnCard

    let deck = getDeck()
    if (deck == null)
      return INVALID_CARD

    let selectedCard = deck.drawCard() castTo SpawnCard
    if (selectedCard == null)
      return INVALID_CARD

    var selectedTier = 0
    var selectedCost = 0
    var foundValidTier = false

    let credits = getCredits()
    let baseCost = selectedCard.getCost()
    let _tierCount = selectedCard.getSpawnDefinition().getTierCount()

    for tier = (_tierCount - 1) downto 0
    //{
      let tierCost = TIER_VALUE_MULTIPLIER[tier] * baseCost
      if (credits > tierCost)
        selectedTier = tier
        selectedCost = tierCost
        foundValidTier = true
        break
    //}

    if (not foundValidTier)
      return INVALID_CARD

    return drawnCard(selectedCard, selectedTier, selectedCost)

  // --------------------------------------------------------------------------
  override function activateCard(drawnCard card) returns bool

    let targetProvider = getUndeadTargetProviderForPlayer(m_targetPlayer)
    if (targetProvider == null)
      return false

    let spawnCard = card.card castTo SpawnCard
    let spawnDef = spawnCard.getSpawnDefinition()

    let context = m_context.clone()

    let config = new SpawnUndeadUnitJobConfig()
    ..setTierSelector(context -> card.tier)
    ..setTierSelectionMode(TierSelectionMode.Group)
    ..setUnitTypeProvider(spawnDef.getUnitTypeProvider())
    ..setSpawnPointProvider(getSpawnPointProvider(m_targetPlayer, spawnDef.getSpawnPointProviderType()))
    ..setTargetProvider(targetProvider)
    ..setGroupSize(spawnDef.getGroupSize(context))
    ..setMaxSpawnCount(spawnDef.getMaxSpawnCount(context))
    ..setMaxAliveCount(UNLIMITED)
    ..setSpawnRange(spawnDef.getSpawnRange().toRangeReal())
    ..setWaitForFullGroup(spawnDef.getWaitForFullSpawnGroup())
    ..setPrepareUnitFunc((job, spawnedUnit) -> prepareUnit(context, spawnDef, spawnedUnit))
    ..setUseRecycler(spawnDef.getUseUnitRecycler())

    let spawnJob = new SpawnUndeadUnitJob(spawnDef.getId(), PLAYER_UNDEAD, m_targetPlayer, config)
    ..setCancellationToken(getCancellationToken())
    ..setContext(context)

    spawnJob.onUnitSpawned().register() (SpawnUndeadUnitJob job, unit spawnedUnit) ->
      onUnitSpawned(spawnedUnit)

    spawnJob.onGroupSpawned().register() (SpawnUndeadUnitJob job, group spawnedUnits) ->
      onGroupSpawned(context, spawnDef, spawnedUnits)

    getWorkerThread().enqueue(spawnJob)

    return true

  // --------------------------------------------------------------------------
  private function prepareUnit(SpawnContext context, SpawnDefinition spawnDef, unit spawnedUnit) returns bool

    let unitMetadata = spawnedUnit.getMetadata()
    if (unitMetadata == null)
      Log.error("[SpawnWave.setTargetPlayer] : Unit has no metadata! : {0} ({1} : {2})".format(
        spawnedUnit.getName(),
        spawnedUnit.getTypeId().toString(),
        UnitId2StringBJ(spawnedUnit.getTypeId())))
      return false

    let commonUnitModifier = spawnDef.getCommonUnitModifier()
    if (commonUnitModifier != null)
      commonUnitModifier.call(spawnedUnit, context)

    let unitModifier = spawnDef.getUnitModifier(spawnedUnit.getTypeId())
    if (unitModifier != null)
      unitModifier.call(spawnedUnit, context)

    return true

  // --------------------------------------------------------------------------
  private function onUnitSpawned(unit spawnedUnit)

    getAdmin().registerOwnedUnit(spawnedUnit)

    spawnedUnit.removeAbility(g_goldCarrierBuff.abilId)
    spawnedUnit.removeAbility(g_goldCarrierBuff.buffId)

    m_spawnsPerGoldDropCounter++
    let spawnsPerGoldDrop = getSpawnsPerGoldDrop()
    if (spawnsPerGoldDrop != 0 and m_spawnsPerGoldDropCounter >= spawnsPerGoldDrop)
      m_spawnsPerGoldDropCounter -= spawnsPerGoldDrop
      m_goldDrops++
      makeSpawnedUnitDropGold(spawnedUnit)

  // --------------------------------------------------------------------------
  private function onGroupSpawned(SpawnContext context, SpawnDefinition spawnDef, group spawnedUnits)

    let firstUnit = spawnedUnits.getFirst()
    if (firstUnit == null)
      return

    let targetUnit = context.getTargetUnit()
    let targetPlayer = targetUnit.getOwner()

    for spawnedUnit in spawnedUnits
    //{
      let unitMetadata = spawnedUnit.getMetadata()

      let utc = unitMetadata.getUndeadTargetingComponent()
      if (utc != null)
        utc.setTargetUnit(targetUnit)

      let unitDef = getUnitDefinition(spawnedUnit.getTypeId())
      if (unitDef != null)
        spawnedUnit.fadeIn(unitDef.getVertexColor())
      else
        spawnedUnit.fadeIn()

      if (spawnDef.getMinimapIconPath() != null)
        spawnedUnit.getOrAddMinimapIconComponent()
        ..update(spawnDef.getMinimapIconPath(), spawnDef.getMinimapIconColor())
        ..showOnlyFor(targetPlayer)
    //}

    if (localPlayer == targetPlayer and spawnDef.getPingOnGroupSpawn())
      let color = spawnDef.getPingOnGroupSpawnColor()
      PingMinimapEx(firstUnit.getX(), firstUnit.getY(), 3.0, color.red, color.green, color.blue, true)

    let playSoundOnGroupSpawn = spawnDef.getPlaySoundOnGroupSpawn()
    if (playSoundOnGroupSpawn != null)
      playSoundOnGroupSpawn.playForPlayer(targetPlayer)

  // --------------------------------------------------------------------------
  private function makeSpawnedUnitDropGold(unit spawnedUnit)
    var goldDropAmount = getGoldDropAmount()
    if (goldDropAmount == 0)
      return
    spawnedUnit.addAbility(g_goldCarrierBuff.abilId)
    goldDropAmount = min(goldDropAmount, 50) // 5 10g coins max
    while (goldDropAmount > 0)
      let coinTypeId = getCoinItemTypeFromGoldReward(goldDropAmount)
      spawnedUnit.awardItemOnDeath(g_coinItemSet, coinTypeId, 1.0)
      let coinValue = getGoldRewardFromCoinItemType(coinTypeId)
      goldDropAmount -= coinValue
      m_goldAvailable += coinValue

  // --------------------------------------------------------------------------
  override function writeDebugString(Action1<string> output)

    output.acquire()

    super.writeDebugString(output)
    
    output.call("Gold: d:{0} a:{1} c:{2}/{3}".format(
      m_goldDrops.toString(),
      m_goldAvailable.toString(),
      m_spawnsPerGoldDropCounter.toString(),
      getSpawnsPerGoldDrop().toString()))
    
    output.release()

// ============================================================================
class ContinuousDirectorJob extends Job
  private Director m_director
  private player m_targetPlayer
  private drawnCard m_selectedCard
  private rangeReal m_slowActivationIntervalRange
  private rangeReal m_fastActivationIntervalRange
  private bool m_lastActivationSucceeded
  private string m_lastActivationFailedReason
  private real m_timer

  // --------------------------------------------------------------------------
  construct (Director director)
    super(director.getName())
    m_director = director

  // --------------------------------------------------------------------------
  function getTargetPlayer() returns player
    return m_targetPlayer
  
  // --------------------------------------------------------------------------
  function setTargetPlayer(player value)
    m_targetPlayer = value

  // --------------------------------------------------------------------------
  function getSelectedCard() returns drawnCard
    return m_selectedCard

  // --------------------------------------------------------------------------
  function getActivationTimer() returns real
    return m_timer

  // --------------------------------------------------------------------------
  function getLastActivationSucceeded() returns bool
    return m_lastActivationSucceeded

  // --------------------------------------------------------------------------
  function getLastActivationFailedReason() returns string
    return m_lastActivationFailedReason

  // --------------------------------------------------------------------------
  private function restartTimerBetweenWaves()
    m_timer += m_slowActivationIntervalRange.getRandom()

  // --------------------------------------------------------------------------
  private function restartTimerDuringWave()
    m_timer += m_fastActivationIntervalRange.getRandom()

  // --------------------------------------------------------------------------
  override function next() returns int

    let dt = getThread().getTickInterval()

    m_timer = max(m_timer - dt, 0)
    if (m_timer > 0)
      return 0

    m_lastActivationSucceeded = false
    m_lastActivationFailedReason = ""

    if (getCancellationToken().isCanceled())
      m_lastActivationFailedReason = "canceled"
      return 0

    if (not m_director.canDrawCard())
      restartTimerBetweenWaves()
      m_lastActivationFailedReason = "director"
      return 0

    if (not m_lastActivationSucceeded)
      m_selectedCard = m_director.drawCard()

    if (m_selectedCard.card == null)
      restartTimerBetweenWaves()
      m_lastActivationFailedReason = "too expensive"
      return 0

    let credits = m_director.getCredits()

    // If the director can't afford the card at the current tier, drop down a tier
    while (m_selectedCard.tier > 0 and credits < m_selectedCard.cost)
      m_selectedCard.tier = m_selectedCard.tier - 1
      m_selectedCard.cost = TIER_VALUE_MULTIPLIER[m_selectedCard.tier] * m_selectedCard.card.getCost()
    
    if (m_selectedCard.tier == 0 and credits < m_selectedCard.cost)
      restartTimerBetweenWaves()
      m_lastActivationFailedReason = "too expensive"
      return 0

    if (credits > m_selectedCard.cost * TOO_CHEAP_COEFF)
      let deck = m_director.getDeck()
      if (m_selectedCard.card != deck.getMostExpensiveCard())
        restartTimerBetweenWaves()
        m_lastActivationFailedReason = "too cheap"
        return 0

    m_director.setCredits(credits - m_selectedCard.cost)

    m_lastActivationSucceeded = m_director.activateCard(m_selectedCard)

    if (m_lastActivationSucceeded)
      restartTimerDuringWave()
    else
      m_lastActivationFailedReason = "failed to activate"
      restartTimerBetweenWaves()

    return 1

  // --------------------------------------------------------------------------
  override function hasNext() returns bool
    return true

  // --------------------------------------------------------------------------
  override function getDebuggerStateString() returns string
    return ""

// ============================================================================
function onUnitDeath()
  let dyingUnit = GetDyingUnit()
  if (not g_unitToAdminMap.has(dyingUnit))
    return
  let director = g_unitToAdminMap.get(dyingUnit)
  director.onOwnedUnitKilled(dyingUnit)

// ============================================================================
function onNightStart()
  g_nightZombieDirector.enable()
  g_nightEliteDirector.enable()

// ============================================================================
function onDayStart()
  g_nightZombieDirector.disable()
  g_nightEliteDirector.disable()

// ============================================================================
init

  g_unitToAdminMap = new HashMap<unit, Admin>()

  nullTimer() () ->
    g_nightZombieDirector = new SpawnUndeadUnitDirector("0:Zombies", players[0])
    g_nightZombieDirector.setCreditsOnActivation(50)
    g_nightZombieDirector.setSlowActivationIntervalRange(rangeReal(3.0, 10.0))
    g_nightZombieDirector.setFastActivationIntervalRange(rangeReal(0.1, 1.0))
    g_nightZombieDirector.setSpawnsPerGoldDrop(context -> calculateMaxAliveCountForZombies(context))
    g_nightZombieDirector.setGoldDropAmount(context -> 1)
    g_nightZombieDirector.setMaxSpawnCount(context -> UNLIMITED)
    g_nightZombieDirector.setMaxAliveCount(context -> 10)
    g_nightZombieDirector.setDeck(createNightDirectorZombieDeck())

    g_nightEliteDirector = new SpawnUndeadUnitDirector("0:Elites", players[0])
    g_nightEliteDirector.setCreditsOnActivation(50)
    g_nightEliteDirector.setSlowActivationIntervalRange(rangeReal(3.0, 10.0))
    g_nightEliteDirector.setFastActivationIntervalRange(rangeReal(0.1, 1.0))
    g_nightEliteDirector.setSpawnsPerGoldDrop(context -> calculateSpawnsPerGoldDropForElites(context))
    g_nightEliteDirector.setGoldDropAmount(context -> calculateGoldDropAmountForElites(context))
    g_nightEliteDirector.setMaxSpawnCount(context -> calculateMaxSpawnCountForElites(context))
    g_nightEliteDirector.setMaxAliveCount(context -> calculateMaxAliveCountForElites(context))
    g_nightEliteDirector.setDeck(createNightDirectorEliteDeck())

  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_DEATH, function onUnitDeath)
  registerNightEvent(function onNightStart)
  registerDayEvent(function onDayStart)

// ============================================================================
function createNightDirectorZombieDeck() returns Deck

  let deck = new Deck()
  let categoryNormals = deck.addCategory("Normals", 9.0)

  categoryNormals.addCard(createSpawnCard_Zombie(), 1.0)

  return deck

// ============================================================================
function createNightDirectorEliteDeck() returns Deck

  let deck = new Deck()
  let categoryElites = deck.addCategory("Elites", 3.0)
  let categoryBosses = deck.addCategory("Bosses", 1.0)

  categoryElites.addCard(createSpawnCard_SkeletonArcher(), 1.0)
  categoryBosses.addCard(createSpawnCard_Abomination(), 1.0)

  return deck

// ============================================================================
function createSpawnCard_Zombie() returns SpawnCard

  let def = new SpawnDefinition("Zombie")
  ..setMaxSpawnCount(context -> 1)
  ..setSpawnsPerGoldDrop(context -> 20)
  ..setGoldDropAmount(context -> 1)
  ..setGroupSize(context -> 1)
  ..setSpawnRange(SpawnRange.CLOSE)
  ..setUseUnitRecycler(true)

  let unitTypeProvider = new TieredUnitTypeProvider()
  for i = 0 to MAX_ELITE_TIER-1
    unitTypeProvider.setUnitType(i, TlsUnitIds.Undead.zombiesNight[i])
  def.setUnitTypeProvider(unitTypeProvider)

  def.setCommonUnitModifier() (unit u, SpawnContext context) ->
  //{
    g_zombieMeleeModifiers.apply(context, u)
    u.setMoveSpeed(lerp(120, 250, context.getGameProgress01()))
    u.preferStructureTargets()
  //}

  def.setUnitModifier(TlsUnitIds.Undead.zombiesNight[0]) (u, context) ->
    u.setDefenseType(ArmorType.Unarmored)

  def.setUnitModifier(TlsUnitIds.Undead.zombiesNight[1]) (u, context) ->
    u.setDefenseType(ArmorType.Normal)

  def.setUnitModifier(TlsUnitIds.Undead.zombiesNight[2]) (u, context) ->
    u.setDefenseType(ArmorType.Large)

  return new SpawnCard(def)..setCost(3)

// ============================================================================
function createSpawnCard_SkeletonArcher() returns SpawnCard

  let def = new SpawnDefinition("Skeleton Archer")
  ..setMaxSpawnCount(context -> 1)
  ..setSpawnsPerGoldDrop(context -> calculateSpawnsPerGoldDropForElites(context))
  ..setGoldDropAmount(context -> calculateGoldDropAmountForElites(context))
  ..setGroupSize(context -> 1)
  ..setSpawnRange(SpawnRange.MID)

  let unitTypeProvider = new TieredUnitTypeProvider()
  for i = 0 to MAX_ELITE_TIER-1
    unitTypeProvider.setUnitType(i, TlsUnitIds.Undead.skeletonArchers[i])
  def.setUnitTypeProvider(unitTypeProvider)

  def.setCommonUnitModifier() (unit u, SpawnContext context) ->
    g_eliteRangedModifiers.apply(context, u)
    u.setDefenseType(ArmorType.Medium)

  return new SpawnCard(def)..setCost(10)

// ============================================================================
function createSpawnCard_Abomination() returns SpawnCard
  
  let def = new SpawnDefinition("Abominations")
  ..setMaxSpawnCount(context -> 1)
  ..setSpawnsPerGoldDrop(context -> 1) // every spawn drops gold
  ..setGoldDropAmount(context -> GOLD_PER_BOSS)
  ..setSpawnRange(SpawnRange.MID)
  ..setupForBoss()

  let unitTypeProvider = new TieredUnitTypeProvider()
  for i = 0 to MAX_ELITE_TIER-1
    unitTypeProvider.setUnitType(i, TlsUnitIds.Undead.abominations[i])
  def.setUnitTypeProvider(unitTypeProvider)

  def.setCommonUnitModifier() (unit u, SpawnContext context) ->
  //{
    g_eliteMeleeModifiers.applyHealth(context, u, 4.0)
    g_eliteMeleeModifiers.applyArmor(context, u, 3.0)
    g_eliteMeleeModifiers.applyAttack1DamageRange(context, u, 2.0)
    g_eliteMeleeModifiers.applyAttack1Cooldown(context, u, 1.0)
    u.awardXpOnDeath(100)
    u.setAcquisitionRange(ELITE_SIGHT_RANGE)
    u.setSightRadius(ELITE_SIGHT_RANGE)
    u.setMoveSpeed(125.0)
    u.awardRandomItemOnDeath(g_BossItemLibrary.rareSet, 1.0)
    u.preferStructureTargets()
  //}

  return new SpawnCard(def)..setCost(50)

@test function asdf()

  let baseCost = 10
  var credits = 450

  var selectedTier = 0
  var selectedCost = 0

  for tier = 2 downto 0
  //{
    let tierCost = TIER_VALUE_MULTIPLIER[tier] * baseCost
    if (credits >= tierCost)
      selectedTier = tier
      selectedCost = tierCost
      Log.info("t: " + selectedTier.toString() + " c: " + selectedCost.toString())
      break
  //}

  for i = 0 to 10
    
    while (selectedTier > 0 and credits < selectedCost)
      selectedTier--
      selectedCost = TIER_VALUE_MULTIPLIER[selectedTier] * baseCost
      Log.info("t: " + selectedTier.toString() + " c: " + selectedCost.toString())

    if (credits < selectedCost)
      Log.info("too expensive!")
      break

    credits -= selectedCost
    Log.info("spawned tier " + selectedTier.toString())
    Log.info("credits: " + credits.toString())

    