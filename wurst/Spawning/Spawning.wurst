package Spawning
import BuffObjEditing
import RefObject
import Action
import GameConstants
import Range
import Bounds
import ErrorHandling

public bool SPAWNING_ENABLED = true

constant int SPAWNS_MAX_PER_TICK = 1
constant int PROCESS_MAX_PER_TICK = 8 // 1 per player?
constant real PROCESS_QUEUE_INTERVAL = 0.1

constant int MAX_TIERS = 3
constant int INVALID_UNIT_TYPE = -1

public constant buffTuple g_goldCarrierBuff = compiletime(createDummyBuffObject("Gold Carrier", "This unit is carrying gold!", "ReplaceableTextures\\CommandButtons\\BTNMGExchange.blp", "Abilities\\Spells\\NightElf\\FaerieFire\\FaerieFireTarget.mdl", "chest"))

public tuple tierChances(real tier1, real tier2, real tier3)

// ============================================================================
public class UnitTypeCollection
  private int array[12] m_unitTypes
  private int m_size = 0

  // --------------------------------------------------------------------------
  function clear()
    m_size = 0

  // --------------------------------------------------------------------------
  function add(int unitType)
    m_unitTypes[m_size] = unitType
    m_size++

  // --------------------------------------------------------------------------
  function get(int index) returns int
    return m_unitTypes[index]

  // --------------------------------------------------------------------------
  function size() returns int
    return m_size

// ============================================================================
public interface ITieredUnitTypeProvider
  function getUnitTypes(SpawnContext context, int count, UnitTypeCollection output)

// ============================================================================
public class TieredUnitTypeProvider implements ITieredUnitTypeProvider
  private int array[MAX_TIERS] m_unitTypes

  // --------------------------------------------------------------------------
  construct()
    for i = 0 to MAX_TIERS - 1
      m_unitTypes[i] = INVALID_UNIT_TYPE

  // --------------------------------------------------------------------------
  function setUnitType(int tier, int unitType)
    m_unitTypes[tier] = unitType

  // --------------------------------------------------------------------------
  function getUnitType(int tier) returns int
    return m_unitTypes[tier]

  // --------------------------------------------------------------------------
  override function getUnitTypes(SpawnContext context, int count, UnitTypeCollection output)    
    let tier = context.getTier()
    let unitTypeId = getUnitType(tier)
    for i = 0 to count - 1
      output.add(unitTypeId)

// ============================================================================
public class SpawnContext
  private int m_tier = -1
  private int m_groupId = -1
  private unit m_targetUnit = null
  private real m_difficultyCoeff = 1.0
  private ISpawnDefinition m_spawnDefinition

  use RefObject

  // --------------------------------------------------------------------------
  construct()

  // --------------------------------------------------------------------------
  construct(SpawnContext other)
    m_tier = other.m_tier
    m_groupId = other.m_groupId
    m_targetUnit = other.m_targetUnit
    m_difficultyCoeff = other.m_difficultyCoeff

  // --------------------------------------------------------------------------
  function clone() returns SpawnContext
    return new SpawnContext(this)

  // --------------------------------------------------------------------------
  function getDifficultyCoeff() returns real
    return m_difficultyCoeff

  // --------------------------------------------------------------------------
  function setDifficultyCoeff(real value)
    m_difficultyCoeff = value

  // --------------------------------------------------------------------------
  function getTier() returns int
    return m_tier

  // --------------------------------------------------------------------------
  function setTier(int value)
    m_tier = value
  
  // --------------------------------------------------------------------------
  function getGroupId() returns int
    return m_groupId
  
  // --------------------------------------------------------------------------
  function setGroupId(int value)
    m_groupId = value

  // --------------------------------------------------------------------------
  function getTargetUnit() returns unit
    return m_targetUnit
  
  // --------------------------------------------------------------------------
  function setTargetUnit(unit value)
    m_targetUnit = value

  // ----------------------------------------------------------------------------
  function getSpawnDefinition() returns ISpawnDefinition
    return m_spawnDefinition
  
  // ----------------------------------------------------------------------------
  function setSpawnDefinition(ISpawnDefinition value)
    m_spawnDefinition = value

// ============================================================================
public interface ISpawnDefinition
  function setCommonUnitModifier(Action2<unit, SpawnContext> action)
  function getCommonUnitModifier() returns Action2<unit, SpawnContext>
  function setUnitModifier(int unitTypeId, Action2<unit, SpawnContext> action)
  function getUnitModifier(int unitTypeId) returns Action2<unit, SpawnContext>

// ============================================================================
public enum SpawnRange
  CLOSE
  MID
  FAR

// ============================================================================
public function SpawnRange.toRangeReal() returns rangeReal
  switch (this)
    case CLOSE
      return SPAWN_RANGE_CLOSE
    case MID
      return SPAWN_RANGE_MID
    case FAR
      return SPAWN_RANGE_FAR

// ============================================================================
public function SpawnRange.toString() returns string
  switch (this)
    case CLOSE
      return "Close"
    case MID
      return "Mid"
    case FAR
      return "Far"

constant MAX_SPAWN_POINTS = 32

// ============================================================================
public class SpawnPointCollection
  private vec2 array[MAX_SPAWN_POINTS] points
  private int m_count

  // --------------------------------------------------------------------------
  construct()
    m_count = 0

  // --------------------------------------------------------------------------
  function getCapacity() returns int
    return MAX_SPAWN_POINTS

  // --------------------------------------------------------------------------
  function getCount() returns int
    return m_count

  // --------------------------------------------------------------------------
  function isEmpty() returns bool
    return m_count == 0

  // --------------------------------------------------------------------------
  function clear()
    m_count = 0

  // --------------------------------------------------------------------------
  function getPoint(int index) returns vec2
    if (index >= m_count)
      error("Argument out of bounds: index")
    return points[index]

  // --------------------------------------------------------------------------
  function pushPoint(vec2 point)
    if (m_count == MAX_SPAWN_POINTS)
      error("Too many spawn points")
    points[m_count] = point
    m_count++

  // --------------------------------------------------------------------------
  function popPoint() returns vec2
    let point = peekPoint()
    m_count--
    return point

  // --------------------------------------------------------------------------
  function peekPoint() returns vec2
    if (m_count == 0)
      error("Collection is empty")
    return points[m_count]

  // --------------------------------------------------------------------------
  function iterator() returns SpawnPointCollectionIterator
    return new SpawnPointCollectionIterator(this)

// ============================================================================
public class SpawnPointCollectionIterator
  private SpawnPointCollection m_collection
  private int m_index

  // --------------------------------------------------------------------------
  construct(SpawnPointCollection collection)
    m_collection = collection
    m_index = 0

  // --------------------------------------------------------------------------
  function hasNext() returns bool
    return m_index < m_collection.getCount()

  // --------------------------------------------------------------------------
  function next() returns vec2
    let point = m_collection.getPoint(m_index)
    m_index++
    return point

  // --------------------------------------------------------------------------
  function close()
    destroy this

// ============================================================================
public tuple spawnPointResult(bool succeeded, vec2 spawnPoint)
public tuple spawnPointsResult(bool succeeded, SpawnPointCollection spawnPoints)

// ============================================================================
public interface ISpawnPointProvider
  function getRandomSpawnPointInRange(vec2 pos, rangeReal range) returns spawnPointResult
  function getRandomSpawnPointsInRange(vec2 pos, rangeReal range, int count) returns spawnPointsResult
  function getRandomSpawnPointInRect(bounds bounds) returns spawnPointResult
  function getRandomSpawnPointsInRect(bounds bounds, int count) returns spawnPointsResult

// ============================================================================
public function ISpawnPointProvider.getRandomSpawnPointInPlayableMap() returns spawnPointResult
  return this.getRandomSpawnPointInRect(bounds(playableMin, playableMax))

// ============================================================================
public abstract class TargetProvider
  use RefObject
  // ----------------------------------------------------------------------------
  abstract function getTargetUnit(SpawnContext context) returns unit