package CircularCachedSpawnManager
import Range
import GameConstants
import SpawnRegion
import RegionExtensions
import Circle
import ClosureTimers
import SpawnManager
import SpawnPointCollection
import Arc
import Func
import Vector
import FX
import TLSFrame
import LinkedList

import initlater FriendlyCircularCachedSpawnManager
import initlater HostileCircularCachedSpawnManager
import ProjectConstants

constant int NUM_SPAWN_RANGES = 3 // Close, mid, far
constant int NUM_SPAWN_DIRS = 8
constant int NUM_SPAWN_AREAS = 8 * NUM_SPAWN_RANGES // Number of spawn ranges
constant int MAX_ATTEMPTS_PER_REQUEST = 10
constant int MAX_ATTEMPTS_PER_LOOP = 10
constant int MAX_REQUEUES_PER_REQUEST = 5

constant real ANGLE_DELTA = PI2 / 8.0
constant real ANGLE_DELTA_HALF = ANGLE_DELTA / 2.0
constant real ANGLE_PAD_PERCENT = 0.1
constant real DISTANCE_PAD_PERCENT = 0.1

@configurable public bool g_enableCCSMLogging = false
public CCSMDebugger g_ccsmDebugger

LinkedList<SpawnAreaUpdateRequest> g_updateRequests
Vector<int> g_tempValidSpawnPointIndexList
group g_testGroup = CreateGroup()

// ============================================================================
tuple spawnArea(int index)

// ============================================================================
function makeSpawnArea(SpawnRange range, int direction) returns spawnArea
  return spawnArea((range castTo int) * 8 + direction)

// ============================================================================
function spawnArea.getSpawnRange() returns SpawnRange
  return R2I(I2R(this.index) / 8) castTo SpawnRange

// ============================================================================
function spawnArea.getDirection() returns int
  return this.index - (this.getSpawnRange() castTo int) * 8

// ============================================================================
function spawnArea.getDistanceRange() returns rangeReal
  rangeReal range

  switch (this.getSpawnRange())
    case CLOSE
      range = SPAWN_RANGE_CLOSE
    case MID
      range = SPAWN_RANGE_MID
    case FAR
      range = SPAWN_RANGE_FAR
  
  let padVal = range.getLength() * DISTANCE_PAD_PERCENT
  range.min += padVal
  range.max -= padVal

  return range

// ============================================================================
function spawnArea.overlaps(vec2 spawnAreaCenter, circle circle) returns bool
  return arc(spawnAreaCenter, this.getAngleRange(), this.getDistanceRange()).overlaps(circle)

// ============================================================================
function spawnArea.getAngleRange() returns rangeReal
  return rangeReal(
    I2R(this.getDirection()) * ANGLE_DELTA - ANGLE_DELTA_HALF + ANGLE_DELTA * ANGLE_PAD_PERCENT,
    I2R(this.getDirection() + 1) * ANGLE_DELTA - ANGLE_DELTA_HALF - ANGLE_DELTA * ANGLE_PAD_PERCENT)

// ============================================================================
function spawnArea.getRandomPointInSpawnRange() returns vec2
  let angleRange = this.getAngleRange()
  let distRange = this.getDistanceRange()
  let angle = angleRange.getRandom()
  let dist = distRange.getRandom()
  return vec2(Cos(angle) * dist, Sin(angle) * dist)

// ============================================================================
function spawnArea.getDirectionVector() returns vec2
  let angle = this.getAngleRange().getMid()
  return vec2(Cos(angle), Sin(angle))

// ============================================================================
function spawnArea.toString() returns string
  return "{0}:{1}".format(this.getSpawnRange().toString(), this.getDirection().toString())

// ============================================================================
class SpawnAreaUpdateRequest
  private CircularCachedSpawnManager m_spawnData
  private spawnArea m_area
  private int m_attempts
  private int m_requeues

  // --------------------------------------------------------------------------
  construct(CircularCachedSpawnManager spawnManager, spawnArea area)
    m_spawnData = spawnManager
    m_area = area
    m_attempts = 0
    m_requeues = 0

  // --------------------------------------------------------------------------
  function getSpawnManager() returns CircularCachedSpawnManager
    return m_spawnData

  // --------------------------------------------------------------------------
  function getSpawnArea() returns spawnArea
    return m_area

  // --------------------------------------------------------------------------
  function getAttempts() returns int
    return m_attempts

  // --------------------------------------------------------------------------
  function getRequeues() returns int
    return m_requeues

  // --------------------------------------------------------------------------
  function incrementAttempts()
    m_attempts++

  // --------------------------------------------------------------------------
  function incrementRequeues()
    m_requeues++
    m_attempts = 0

tuple spawnAreaData(vec2 pos, bool valid, bool processingRequest)

// ============================================================================
public class CircularCachedSpawnManager implements ISpawnManager
  private circle m_circle

  private spawnAreaData array[NUM_SPAWN_AREAS] m_areaData
  private bool m_isEnabled
  private string m_id
  private player m_player
  private Func1<unit, bool> m_spawnPointInvalidationFilter

  // Debug helpers
  private bool m_showEffects = false
  private texttag array[NUM_SPAWN_DIRS + 1] m_spawnRangeTexts
  private effect array[NUM_SPAWN_AREAS] m_spawnPointEffects
  private colorA m_debugColor

  // --------------------------------------------------------------------------
  construct(player p, string id, Func1<unit, bool> spawnPointInvalidationFilter, colorA color)
    m_player = p
    m_id = id
    m_spawnPointInvalidationFilter = spawnPointInvalidationFilter
    m_debugColor = color

  // --------------------------------------------------------------------------
  ondestroy
    destroy m_spawnPointInvalidationFilter

  // --------------------------------------------------------------------------
  function getId() returns string
    return m_id

  // --------------------------------------------------------------------------
  function setCenter(vec2 pos)
    m_circle = circle(pos, SPAWN_RANGE_FAR.max)
    invalidateSpawnPoints()
    updateEffects()

  // --------------------------------------------------------------------------
  function getCenter() returns vec2
    return m_circle.center

  // --------------------------------------------------------------------------
  function setIsEnabled(bool enabled)
    if (g_enableCCSMLogging)
      Log.debug("CircularCachedSpawnManager", "setIsEnabled", m_id, "enabled: " + enabled.toString())
    m_isEnabled = enabled
    invalidateSpawnPoints()
    updateEffects()

  // --------------------------------------------------------------------------
  override function getIsEnabled() returns bool
    return m_isEnabled

  // --------------------------------------------------------------------------
  function getShowDebug() returns bool
    return m_showEffects

  // --------------------------------------------------------------------------
  function setShowDebug(bool value)
    m_showEffects = value
    updateEffects()

  // --------------------------------------------------------------------------
  function getSpawnAreaData(int index) returns spawnAreaData
    return m_areaData[index]
  
  // --------------------------------------------------------------------------
  override function getRandomSpawnPointInRange(SpawnRange range) returns spawnPointResult
    if (not m_isEnabled)
      return spawnPointResult(false, ZERO2)

    let startIndex = (range castTo int) * 8

    var validCount = 0
    for i = 0 to NUM_SPAWN_DIRS-1
      if (m_areaData[startIndex + i].valid)
        validCount++

    if (validCount > 0)
      let validIndex = GetRandomInt(0, validCount)
      for i = 0 to NUM_SPAWN_DIRS-1
        if (m_areaData[startIndex + i].valid and i == validIndex)
          return spawnPointResult(true, m_areaData[startIndex + i].pos)

    return spawnPointResult(false, ZERO2)
    
  // --------------------------------------------------------------------------
  override function getRandomSpawnPointsInRange(SpawnRange range, int count) returns spawnPointsResult
    if (not m_isEnabled)
      return spawnPointsResult(false, null)

    let startIndex = (range castTo int) * 8

    g_tempValidSpawnPointIndexList.clear()

    for i = 0 to NUM_SPAWN_DIRS-1
      let validSpawnPointIndex = startIndex + i
      if (m_areaData[validSpawnPointIndex].valid)
        g_tempValidSpawnPointIndexList.add(validSpawnPointIndex)

    if (g_tempValidSpawnPointIndexList.isEmpty())
      return spawnPointsResult(false, null)

    let collection = new SpawnPointCollection()
    
    let spawnPointIndices = g_tempValidSpawnPointIndexList.getRandomUnique(count)
    for validIndex in spawnPointIndices
      collection.pushPoint(m_areaData[validIndex].pos)

    destroy spawnPointIndices

    return spawnPointsResult(true, collection)

  // --------------------------------------------------------------------------
  function isAreaValid(spawnArea area) returns bool
    return m_areaData[area.index].valid

  // --------------------------------------------------------------------------
  function updateSpawnArea(spawnArea area) returns bool
    if (not m_isEnabled)
      return false
    
    let index = area.index
    if (m_areaData[index].valid)
      return true
    
    let pos = getCenter() + area.getRandomPointInSpawnRange()
    let isValid = isSpawnPointValid(pos)
    
    m_areaData[index].pos = pos
    m_areaData[index].valid = isValid
    
    updateEffects()

    return isValid

  // --------------------------------------------------------------------------
  function invalidateSpawnPoints()
    for i = 0 to NUM_SPAWN_AREAS-1
      invalidateSpawnArea(spawnArea(i))

    updateEffects()

  // --------------------------------------------------------------------------
  function invalidateSpawnPoints(circle circle)

    if (not m_circle.overlaps(circle))
      return

    let center = getCenter()

    for i = 0 to NUM_SPAWN_AREAS-1
      let spawnArea = spawnArea(i)
      if ((m_areaData[i].valid or not m_areaData[i].processingRequest) and spawnArea.overlaps(center, circle))
        invalidateSpawnArea(spawnArea)

    updateEffects()
        
  // --------------------------------------------------------------------------
  private function invalidateSpawnArea(spawnArea spawnArea)
    m_areaData[spawnArea.index].valid = false

    if (m_isEnabled and not m_areaData[spawnArea.index].processingRequest)
      m_areaData[spawnArea.index].processingRequest = true
      g_updateRequests.add(new SpawnAreaUpdateRequest(this, spawnArea))

  // --------------------------------------------------------------------------
  function isSpawnPointValid(vec2 pos) returns bool
    if (not g_spawnRegion.containsPoint(pos))
      return false
    g_testGroup.enumUnitsInRange(pos, UNDEAD_SPAWN_TEST_RADIUS)    
    var isValid = true
    for u from g_testGroup
      if (m_spawnPointInvalidationFilter.call(u))
        isValid = false
        break
    return isValid

  // --------------------------------------------------------------------------
  protected function cancelRequest(spawnArea spawnArea)
    m_areaData[spawnArea.index].processingRequest = false

  // --------------------------------------------------------------------------
  protected function finishRequest(spawnArea spawnArea)
    m_areaData[spawnArea.index].processingRequest = false

  // --------------------------------------------------------------------------
  private function updateEffects()

    for i = 0 to NUM_SPAWN_DIRS-1
    //{
      let spawnRange = (i castTo SpawnRange)
      let spawnRangeReal = spawnRange.toRangeReal()
      
      // Show text for each ring name and distance
      if (m_isEnabled and m_showEffects)
      //{
        let spawnRangeTextPos = (m_circle.center + vec2(0, spawnRangeReal.max)).withZ(32)
        if (m_spawnRangeTexts[i] == null)
          m_spawnRangeTexts[i] = createTTEx(spawnRangeTextPos, "{0} ({1})".format(spawnRange.toString(), spawnRangeReal.max.toString()), 10.0)
        m_spawnRangeTexts[i].setPos(spawnRangeTextPos)
      //}
      else if (m_spawnRangeTexts[i] != null)
        m_spawnRangeTexts[i].destr()
        m_spawnRangeTexts[i] = null
    //}

    // Show text at center
    if (m_isEnabled and m_showEffects)
    //{
      let pos = m_circle.center.withZ(32)
      if (m_spawnRangeTexts[NUM_SPAWN_DIRS] == null)
        m_spawnRangeTexts[NUM_SPAWN_DIRS] = createTTEx(pos, "center", 10.0)
      m_spawnRangeTexts[NUM_SPAWN_DIRS].setPos(pos)
    //}
    else if (m_spawnRangeTexts[NUM_SPAWN_DIRS] != null)
      m_spawnRangeTexts[NUM_SPAWN_DIRS].destr()
      m_spawnRangeTexts[NUM_SPAWN_DIRS] = null

    // Show flags on each spawn point
    for i = 0 to NUM_SPAWN_AREAS-1
    //{
      if (m_areaData[i].valid and m_showEffects)
      //{
        if (m_spawnPointEffects[i] == null)
          m_spawnPointEffects[i] = AddSpecialEffect("UI\\Feedback\\WaypointFlags\\WaypointFlag.mdl", m_areaData[i].pos.x, m_areaData[i].pos.y)
          m_spawnPointEffects[i].setColor(m_debugColor)
          m_spawnPointEffects[i].setScale(2.0)
          FX.createJobChangeEffect(m_areaData[i].pos)
        m_spawnPointEffects[i].setPos(m_areaData[i].pos)
      //}
      else if (m_spawnPointEffects[i] != null)
        m_spawnPointEffects[i].destr()
        m_spawnPointEffects[i] = null
    //}

int g_totalRequestsProcessed = 0
int g_totalUpdateSpawnAreaAttempts = 0
int g_mostAttempts = 0
int g_totalFound = 0
int g_totalAbandoned = 0
int g_totalRequeues = 0

// ============================================================================
function processRequests()
  if (g_updateRequests.isEmpty())
    return

  var attemptsCounter = 0

  while (not g_updateRequests.isEmpty() and attemptsCounter < MAX_ATTEMPTS_PER_LOOP)
  //{
    let request = g_updateRequests.dequeue()
    let spawnManager = request.getSpawnManager()
    let spawnArea = request.getSpawnArea()

    g_totalRequestsProcessed++

    if (not spawnManager.getIsEnabled())
      spawnManager.cancelRequest(spawnArea)
      destroy request
    else
    //{
      if (spawnManager.isAreaValid(spawnArea))
        spawnManager.finishRequest(spawnArea)
        destroy request
      else
      //{
        var foundValidSpawnPoint = false
        
        var i = 0
        while i < MAX_ATTEMPTS_PER_REQUEST and attemptsCounter < MAX_ATTEMPTS_PER_LOOP
        //{
          i++
          attemptsCounter++
          g_totalUpdateSpawnAreaAttempts++

          request.incrementAttempts()
          g_mostAttempts = max(g_mostAttempts, request.getAttempts())
          
          if (spawnManager.updateSpawnArea(spawnArea))
            foundValidSpawnPoint = true
            g_totalFound++
            break
        //}

        if (foundValidSpawnPoint)
          spawnManager.finishRequest(spawnArea)
          destroy request
        else if (request.getRequeues() < MAX_REQUEUES_PER_REQUEST)
          request.incrementRequeues()
          g_totalRequeues++
          g_updateRequests.add(request)
          if (g_enableCCSMLogging)
            Log.debug("Requeuing request {0}:{1} after {2} attempts".format(
              spawnManager.getId(),
              spawnArea.toString(),
              request.getAttempts().toString()))
        else
          spawnManager.cancelRequest(spawnArea)
          if (g_enableCCSMLogging)
            Log.debug("Abandoning request {0}:{1} after {2} requeues".format(
              spawnManager.getId(),
              spawnArea.toString(),
              request.getRequeues().toString()))
          g_totalAbandoned++
          destroy request
      //}
    //}
  //}

// ============================================================================
class CCSMDebugger extends TLSFrame
  private framehandle m_textArea
  private unit m_selectedUnit

  // --------------------------------------------------------------------------
  construct()
    super(createFrame("FRAME", "CCSMDebugger", GAME_UI, "", 0))

  // --------------------------------------------------------------------------
  override function initialize()
    super.initialize()

    let frame = getFrameHandle()
    ..setWidth(0.35)
    ..setHeight(0.3)
    ..setAbsPoint(FRAMEPOINT_TOPLEFT, 0.46, 0.56)
    ..show()

    createFrame("BACKDROP", "UTCDebuggerBackdrop", GAME_UI, "BattleNetControlBackdropTemplate", 0)
    ..setParent(frame)
    ..setAllPoints(frame)

    m_textArea = createFrame("TEXTAREA", "UTCDebuggerTextArea", GAME_UI, "ConsoleTextArea", 0)
    ..setParent(frame)
    ..setAllPoints(frame)

    doPeriodically(0.1) (CallbackPeriodic cb) ->
      update()

  // --------------------------------------------------------------------------
  function setSelectedUnit(unit context)
    m_selectedUnit = context

  // --------------------------------------------------------------------------
  function update()

    if (getFrameHandle().isVisible() == false)
      return

    BlzFrameSetText(m_textArea, "===== Circular Cached Spawn Manager =====")
    BlzFrameAddText(m_textArea, "Requests : " + g_updateRequests.size().toString())
    BlzFrameAddText(m_textArea, "Processed : " + g_totalRequestsProcessed.toString())
    BlzFrameAddText(m_textArea, "Attempts : " + g_totalUpdateSpawnAreaAttempts.toString())
    BlzFrameAddText(m_textArea, "Most Attempts : " + g_mostAttempts.toString())
    BlzFrameAddText(m_textArea, "Found : " + g_totalFound.toString())
    BlzFrameAddText(m_textArea, "Requeues : " + g_totalRequeues.toString())
    BlzFrameAddText(m_textArea, "Abandoned : " + g_totalAbandoned.toString())
    
    let friendlySpawnManager = getPlayerCachedFriendlySpawnManager(localPlayer)
    if (friendlySpawnManager != null)
      update_spawnManager(friendlySpawnManager)
    
    let hostileSpawnManager = getPlayerCachedHostileSpawnManager(localPlayer)
    if (hostileSpawnManager != null)
      update_spawnManager(hostileSpawnManager)

  private function update_spawnManager(CircularCachedSpawnManager spawnManager)
    BlzFrameAddText(m_textArea, "----- {0} ({1}) -----".format(spawnManager.getId(), spawnManager.getIsEnabled().toString()))
    let center = spawnManager.getCenter()
    let camCursor = circle(vec2(GetCameraTargetPositionX(), GetCameraTargetPositionY()), 64.0)
    for i = 0 to NUM_SPAWN_AREAS-1
      let spawnArea = spawnArea(i)
      if (spawnArea.overlaps(center, camCursor))
        let spawnAreaData = spawnManager.getSpawnAreaData(i)
        BlzFrameAddText(m_textArea, "Focused: {0} d:{1} v:{2} r:{3}".format(
          spawnArea(i).getSpawnRange().toString(), spawnArea.getDirection().toString(),
          spawnAreaData.valid.toString(), spawnAreaData.processingRequest.toString()))
        break

// ============================================================================
init
  g_tempValidSpawnPointIndexList = new Vector<int>()
  g_updateRequests = new LinkedList<SpawnAreaUpdateRequest>()
  doPeriodically(0.5, (CallbackPeriodic cb) -> processRequests())

  if (DEV_ENVIRONMENT)
    doAfter(2) () ->
      g_ccsmDebugger = new CCSMDebugger()