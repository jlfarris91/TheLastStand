package GridCachedSpawnManager
import Func
import Grid
import Bounds
import ColorUtility
import LinkedList
import ISpawnPointProvider
import SpawnRegion
import RegionExtensions
import GameConstants
import ClosureTimers
import Execute
import FX
import Range
import Vector
import SpawnPointCollection

constant int COLUMNS = 16 
constant int ROWS = 16
constant int NUM_SPAWN_AREAS = COLUMNS * ROWS 
constant int MAX_ATTEMPTS_PER_REQUEST = 10
constant int MAX_ATTEMPTS_PER_LOOP = 10
constant int MAX_REQUEUES_PER_REQUEST = 5

constant group g_testGroup = CreateGroup()
constant Vector<int> g_tempSpawnPointAreaIndices = new Vector<int>()

@configurable public bool g_enableGCSMLogging = false

// ============================================================================
public class GCSM
  static constant Grid mapGrid = new Grid(playableBounds, COLUMNS, ROWS)
  static constant LinkedList<SpawnAreaUpdateRequest> updateRequests = new LinkedList<SpawnAreaUpdateRequest>()
  static int totalRequestsProcessed = 0
  static int totalUpdateSpawnAreaAttempts = 0
  static int mostAttempts = 0
  static int totalFound = 0
  static int totalAbandoned = 0
  static int totalRequeues = 0

tuple debugData(effect fx, colorA color)
tuple spawnArea(cell cell, bounds bounds, vec2 pos, bool valid, bool processingRequest, debugData debug)

// ============================================================================
public function spawnArea.toString() returns string
  return "{0}:{1}".format(this.cell.column.toString(), this.cell.row.toString())

// ============================================================================
class SpawnAreaUpdateRequest
  private GridCachedSpawnManager m_spawnData
  private int m_spawnAreaIndex
  private int m_attempts
  private int m_requeues

  // --------------------------------------------------------------------------
  construct(GridCachedSpawnManager spawnManager, int spawnAreaIndex)
    m_spawnData = spawnManager
    m_spawnAreaIndex = spawnAreaIndex
    m_attempts = 0
    m_requeues = 0

  // --------------------------------------------------------------------------
  function getSpawnManager() returns GridCachedSpawnManager
    return m_spawnData

  // --------------------------------------------------------------------------
  function getSpawnAreaIndex() returns int
    return m_spawnAreaIndex

  // --------------------------------------------------------------------------
  function getAttempts() returns int
    return m_attempts

  // --------------------------------------------------------------------------
  function getRequeues() returns int
    return m_requeues

  // --------------------------------------------------------------------------
  function incrementAttempts()
    m_attempts++

  // --------------------------------------------------------------------------
  function incrementRequeues()
    m_requeues++
    m_attempts = 0

// ============================================================================
public class GridCachedSpawnManager implements ISpawnPointProvider
  private spawnArea array[NUM_SPAWN_AREAS] m_areaData
  private Func1<unit, bool> m_spawnPointInvalidationFilter
  private bool m_showDebugEffects = false

  // --------------------------------------------------------------------------
  construct(Func1<unit, bool> spawnPointInvalidationFilter, colorA debugColor)
    m_spawnPointInvalidationFilter = spawnPointInvalidationFilter.acquire()

    execute() () ->
      for i = 0 to NUM_SPAWN_AREAS-1
      //{
        m_areaData[i].cell = GCSM.mapGrid.getCell(i)
        m_areaData[i].bounds = GCSM.mapGrid.getCellBounds(m_areaData[i].cell)
        m_areaData[i].valid = false
        m_areaData[i].processingRequest = false
        m_areaData[i].debug.color = debugColor
        m_areaData[i].debug.fx = FX.createEffect("UI\\Feedback\\WaypointFlags\\WaypointFlag.mdl", m_areaData[i].bounds.center())
          ..setColor(m_areaData[i].debug.color)
          ..setScale(2.0)
      //}

    invalidateSpawnPoints()

  // --------------------------------------------------------------------------
  ondestroy
    m_spawnPointInvalidationFilter.release()

  // --------------------------------------------------------------------------
  function getId() returns string
    return "GridSpawnManager"

  // --------------------------------------------------------------------------
  function getShowDebug() returns bool
    return m_showDebugEffects

  // --------------------------------------------------------------------------
  function setShowDebug(bool value)
    m_showDebugEffects = value
    updateEffects()

  // --------------------------------------------------------------------------
  function getSpawnArea(int index) returns spawnArea
    return m_areaData[index]

  // --------------------------------------------------------------------------
  function isAreaValid(int index) returns bool
    return m_areaData[index].valid

  // --------------------------------------------------------------------------
  override function getRandomSpawnPointInRange(vec2 pos, rangeReal range) returns spawnPointResult
    return getRandomSpawnPointInRect(bounds(pos, range.max))
    
  // --------------------------------------------------------------------------
  override function getRandomSpawnPointsInRange(vec2 pos, rangeReal range, int count) returns spawnPointsResult
    return getRandomSpawnPointsInRect(bounds(pos, range.max), count)
    
  // --------------------------------------------------------------------------
  override function getRandomSpawnPointInRect(bounds bounds) returns spawnPointResult

    g_tempSpawnPointAreaIndices.clear()

    let span = GCSM.mapGrid.getArea(bounds)

    for r = span.min.row to span.max.row
      for c = span.min.column to span.max.column
        let index = GCSM.mapGrid.getIndex(cell(r, c))
        if (isAreaValid(index))
          g_tempSpawnPointAreaIndices.add(index)

    var result = spawnPointResult(false, ZERO2)

    if (g_tempSpawnPointAreaIndices.isEmpty() == false)
      result.succeeded = true
      result.spawnPoint = m_areaData[g_tempSpawnPointAreaIndices.getRandom()].pos

    g_tempSpawnPointAreaIndices.clear()

    return result

  // --------------------------------------------------------------------------
  override function getRandomSpawnPointsInRect(bounds bounds, int count) returns spawnPointsResult

    g_tempSpawnPointAreaIndices.clear()

    let span = GCSM.mapGrid.getArea(bounds)

    for r = span.min.row to span.max.row
      for c = span.min.column to span.max.column
        let index = GCSM.mapGrid.getIndex(cell(r, c))
        if (isAreaValid(index))
          g_tempSpawnPointAreaIndices.add(index)

    var result = spawnPointsResult(false, null)

    if (g_tempSpawnPointAreaIndices.isEmpty() == false)
      result.succeeded = true
      result.spawnPoints = new SpawnPointCollection()

      let randomUnique = g_tempSpawnPointAreaIndices.getRandomUnique(count)
      for i = 0 to min(count, randomUnique.getCount())
        result.spawnPoints.pushPoint(m_areaData[randomUnique.getItem(i)].pos)
      destroy randomUnique

    g_tempSpawnPointAreaIndices.clear()

    return result

  // --------------------------------------------------------------------------
  protected function updateSpawnArea(int index) returns bool

    if (m_areaData[index].valid)
      return true
    
    let pos = m_areaData[index].bounds.getRandomPoint()
    let isValid = isSpawnPointValid(pos)
    
    m_areaData[index].pos = pos
    m_areaData[index].valid = isValid
    
    updateEffects(index)

    return isValid

  // --------------------------------------------------------------------------
  protected function cancelRequest(int index)
    m_areaData[index].processingRequest = false

  // --------------------------------------------------------------------------
  protected function finishRequest(int index)
    m_areaData[index].processingRequest = false

  // --------------------------------------------------------------------------
  function isSpawnPointValid(vec2 pos) returns bool
    if (not g_spawnRegion.containsPoint(pos))
      return false
    g_testGroup.enumUnitsInRange(pos, UNDEAD_SPAWN_TEST_RADIUS)    
    var isValid = true
    for u from g_testGroup
      if (m_spawnPointInvalidationFilter.call(u))
        isValid = false
        break
    return isValid

  // --------------------------------------------------------------------------
  function invalidateSpawnPoints()
    execute() () ->
      for i = 0 to NUM_SPAWN_AREAS-1
        invalidateSpawnArea(i)
      updateEffects()

  // --------------------------------------------------------------------------
  function invalidateSpawnPoints(bounds bounds)

    let span = GCSM.mapGrid.getArea(bounds.center(), bounds.getHalfExtents())

    for r = span.min.row to span.max.row
      for c = span.min.column to span.max.column
        let index = GCSM.mapGrid.getIndex(cell(r, c))
        if (m_areaData[index].valid or not m_areaData[index].processingRequest)
          invalidateSpawnArea(index)
          updateEffects()

  // --------------------------------------------------------------------------
  private function invalidateSpawnArea(int index)
    m_areaData[index].valid = false

    if (not m_areaData[index].processingRequest)
      m_areaData[index].processingRequest = true
      GCSM.updateRequests.add(new SpawnAreaUpdateRequest(this, index))
    
    updateEffects(index)

  // --------------------------------------------------------------------------
  private function updateEffects()
    for i = 0 to NUM_SPAWN_AREAS-1
      updateEffects(i)

  // --------------------------------------------------------------------------
  private function updateEffects(int index)
    m_areaData[index].debug.fx.setColor((m_showDebugEffects and m_areaData[index].valid) ? m_areaData[index].debug.color : Colors.clear)
    m_areaData[index].debug.fx.setPos(m_areaData[index].pos)

// ============================================================================
function processRequests()
  if (GCSM.updateRequests.isEmpty())
    return

  var attemptsCounter = 0

  while (not GCSM.updateRequests.isEmpty() and attemptsCounter < MAX_ATTEMPTS_PER_LOOP)
  //{
    let request = GCSM.updateRequests.dequeue()
    let spawnManager = request.getSpawnManager()
    let spawnAreaIndex = request.getSpawnAreaIndex()

    GCSM.totalRequestsProcessed++

    if (spawnManager.isAreaValid(spawnAreaIndex))
      spawnManager.finishRequest(spawnAreaIndex)
      destroy request
    else
    //{
      var foundValidSpawnPoint = false
      
      var i = 0
      while i < MAX_ATTEMPTS_PER_REQUEST and attemptsCounter < MAX_ATTEMPTS_PER_LOOP
      //{
        i++
        attemptsCounter++
        GCSM.totalUpdateSpawnAreaAttempts++

        request.incrementAttempts()
        GCSM.mostAttempts = max(GCSM.mostAttempts, request.getAttempts())
        
        if (spawnManager.updateSpawnArea(spawnAreaIndex))
          foundValidSpawnPoint = true
          GCSM.totalFound++
          break
      //}

      if (foundValidSpawnPoint)
        spawnManager.finishRequest(spawnAreaIndex)
        destroy request
      else if (request.getRequeues() < MAX_REQUEUES_PER_REQUEST)
        request.incrementRequeues()
        GCSM.totalRequeues++
        GCSM.updateRequests.add(request)
        if (g_enableGCSMLogging)
          Log.debug("Requeuing request {0}:{1} after {2} attempts".format(
            spawnManager.getId(),
            spawnManager.getSpawnArea(spawnAreaIndex).toString(),
            request.getAttempts().toString()))
      else
        spawnManager.cancelRequest(spawnAreaIndex)
        if (g_enableGCSMLogging)
          Log.debug("Abandoning request {0}:{1} after {2} requeues".format(
            spawnManager.getId(),
            spawnManager.getSpawnArea(spawnAreaIndex).toString(),
            request.getRequeues().toString()))
        GCSM.totalAbandoned++
        destroy request
    //}
  //}

// ============================================================================
init
  doPeriodically(0.5, (CallbackPeriodic cb) -> processRequests())