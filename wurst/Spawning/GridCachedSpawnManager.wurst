package GridCachedSpawnManager
import Func
import Grid
import Bounds
import ColorUtility
import LinkedList
import SpawnManager
import SpawnRegion
import RegionExtensions
import GameConstants
import TLSFrame
import ClosureTimers
import ProjectConstants
import Execute
import FX
import Range

import initlater FriendlyGridCachedSpawnManager
import initlater HostileGridCachedSpawnManager
import Vector
import SpawnPointCollection

constant int COLUMNS = 16 
constant int ROWS = 16
constant int NUM_SPAWN_AREAS = COLUMNS * ROWS 
constant int MAX_ATTEMPTS_PER_REQUEST = 10
constant int MAX_ATTEMPTS_PER_LOOP = 10
constant int MAX_REQUEUES_PER_REQUEST = 5

constant Grid g_mapGrid = new Grid(playableBounds, COLUMNS, ROWS)
constant LinkedList<SpawnAreaUpdateRequest> g_updateRequests = new LinkedList<SpawnAreaUpdateRequest>()
constant group g_testGroup = CreateGroup()
constant Vector<int> g_tempSpawnPointAreaIndices = new Vector<int>()

@configurable public bool g_enableGCSMLogging = false
public GCSMDebugger g_gcsmDebugger

int g_totalRequestsProcessed = 0
int g_totalUpdateSpawnAreaAttempts = 0
int g_mostAttempts = 0
int g_totalFound = 0
int g_totalAbandoned = 0
int g_totalRequeues = 0

tuple debugData(texttag tag, effect fx, colorA color)
tuple spawnArea(cell cell, bounds bounds, vec2 pos, bool valid, bool processingRequest, debugData debug)

// ============================================================================
function spawnArea.toString() returns string
  return "{0}:{1}".format(this.cell.column.toString(), this.cell.row.toString())

// ============================================================================
class SpawnAreaUpdateRequest
  private GridCachedSpawnManager m_spawnData
  private int m_spawnAreaIndex
  private int m_attempts
  private int m_requeues

  // --------------------------------------------------------------------------
  construct(GridCachedSpawnManager spawnManager, int spawnAreaIndex)
    m_spawnData = spawnManager
    m_spawnAreaIndex = spawnAreaIndex
    m_attempts = 0
    m_requeues = 0

  // --------------------------------------------------------------------------
  function getSpawnManager() returns GridCachedSpawnManager
    return m_spawnData

  // --------------------------------------------------------------------------
  function getSpawnAreaIndex() returns int
    return m_spawnAreaIndex

  // --------------------------------------------------------------------------
  function getAttempts() returns int
    return m_attempts

  // --------------------------------------------------------------------------
  function getRequeues() returns int
    return m_requeues

  // --------------------------------------------------------------------------
  function incrementAttempts()
    m_attempts++

  // --------------------------------------------------------------------------
  function incrementRequeues()
    m_requeues++
    m_attempts = 0

// ============================================================================
public class GridCachedSpawnManager implements ISpawnPointProvider
  private spawnArea array[NUM_SPAWN_AREAS] m_areaData
  private Func1<unit, bool> m_spawnPointInvalidationFilter
  private bool m_showDebugEffects = false

  // --------------------------------------------------------------------------
  construct(Func1<unit, bool> spawnPointInvalidationFilter, colorA debugColor)
    m_spawnPointInvalidationFilter = spawnPointInvalidationFilter

    execute() () ->
      for i = 0 to NUM_SPAWN_AREAS-1
      //{
        m_areaData[i].cell = g_mapGrid.getCell(i)
        m_areaData[i].bounds = g_mapGrid.getCellBounds(m_areaData[i].cell)
        m_areaData[i].valid = false
        m_areaData[i].processingRequest = false
        m_areaData[i].debug.color = debugColor
        m_areaData[i].debug.tag = createTTEx(m_areaData[i].bounds.center().withZ(32), m_areaData[i].toString(), 10.0)
        m_areaData[i].debug.fx = FX.createEffect("UI\\Feedback\\WaypointFlags\\WaypointFlag.mdl", m_areaData[i].bounds.center())
          ..setColor(m_areaData[i].debug.color)
          ..setScale(2.0)
      //}

    invalidateSpawnPoints()

  // --------------------------------------------------------------------------
  function getId() returns string
    return "GridSpawnManager"

  // --------------------------------------------------------------------------
  function getShowDebug() returns bool
    return m_showDebugEffects

  // --------------------------------------------------------------------------
  function setShowDebug(bool value)
    m_showDebugEffects = value
    updateEffects()

  // --------------------------------------------------------------------------
  protected function getSpawnArea(int index) returns spawnArea
    return m_areaData[index]

  // --------------------------------------------------------------------------
  function isAreaValid(int index) returns bool
    return m_areaData[index].valid

  // --------------------------------------------------------------------------
  override function getRandomSpawnPointInRange(vec2 pos, SpawnRange range) returns spawnPointResult

    g_tempSpawnPointAreaIndices.clear()

    let span = g_mapGrid.getArea(pos, range.toRangeReal().max)

    for r = span.min.row to span.max.row
      for c = span.min.column to span.max.column
        let index = g_mapGrid.getIndex(cell(r, c))
        if (isAreaValid(index))
          g_tempSpawnPointAreaIndices.add(index)

    var result = spawnPointResult(false, ZERO2)

    if (g_tempSpawnPointAreaIndices.isEmpty() == false)
      result.succeeded = true
      result.spawnPoint = m_areaData[g_tempSpawnPointAreaIndices.getRandom()].pos

    g_tempSpawnPointAreaIndices.clear()

    return result
    
  // --------------------------------------------------------------------------
  override function getRandomSpawnPointsInRange(vec2 pos, SpawnRange range, int count) returns spawnPointsResult

    g_tempSpawnPointAreaIndices.clear()

    let span = g_mapGrid.getArea(pos, range.toRangeReal().max)

    for r = span.min.row to span.max.row
      for c = span.min.column to span.max.column
        let index = g_mapGrid.getIndex(cell(r, c))
        if (isAreaValid(index))
          g_tempSpawnPointAreaIndices.add(index)

    var result = spawnPointsResult(false, null)

    if (g_tempSpawnPointAreaIndices.isEmpty() == false)
      result.succeeded = true
      result.spawnPoints = new SpawnPointCollection()

      let randomUnique = g_tempSpawnPointAreaIndices.getRandomUnique(count)
      for i = 0 to min(count, randomUnique.getCount())
        result.spawnPoints.pushPoint(m_areaData[randomUnique.getItem(i)].pos)
      destroy randomUnique

    g_tempSpawnPointAreaIndices.clear()

    return result

  // --------------------------------------------------------------------------
  protected function updateSpawnArea(int index) returns bool

    if (m_areaData[index].valid)
      return true
    
    let pos = m_areaData[index].bounds.getRandomPoint()
    let isValid = isSpawnPointValid(pos)
    
    m_areaData[index].pos = pos
    m_areaData[index].valid = isValid
    
    updateEffects(index)

    return isValid

  // --------------------------------------------------------------------------
  protected function cancelRequest(int index)
    m_areaData[index].processingRequest = false

  // --------------------------------------------------------------------------
  protected function finishRequest(int index)
    m_areaData[index].processingRequest = false

  // --------------------------------------------------------------------------
  function isSpawnPointValid(vec2 pos) returns bool
    if (not g_spawnRegion.containsPoint(pos))
      return false
    g_testGroup.enumUnitsInRange(pos, UNDEAD_SPAWN_TEST_RADIUS)    
    var isValid = true
    for u from g_testGroup
      if (m_spawnPointInvalidationFilter.call(u))
        isValid = false
        break
    return isValid

  // --------------------------------------------------------------------------
  function invalidateSpawnPoints()
    execute() () ->
      for i = 0 to NUM_SPAWN_AREAS-1
        invalidateSpawnArea(i)
      updateEffects()

  // --------------------------------------------------------------------------
  function invalidateSpawnPoints(bounds bounds)

    let span = g_mapGrid.getArea(bounds.center(), bounds.getHalfExtents())

    for r = span.min.row to span.max.row
      for c = span.min.column to span.max.column
        let index = g_mapGrid.getIndex(cell(r, c))
        if (m_areaData[index].valid or not m_areaData[index].processingRequest)
          invalidateSpawnArea(index)
          updateEffects()

  // --------------------------------------------------------------------------
  private function invalidateSpawnArea(int index)
    m_areaData[index].valid = false

    if (not m_areaData[index].processingRequest)
      m_areaData[index].processingRequest = true
      g_updateRequests.add(new SpawnAreaUpdateRequest(this, index))
    
    updateEffects(index)

  // --------------------------------------------------------------------------
  private function updateEffects()
    for i = 0 to NUM_SPAWN_AREAS-1
      updateEffects(i)

  // --------------------------------------------------------------------------
  private function updateEffects(int index)
    m_areaData[index].debug.tag.setColor((m_showDebugEffects and m_areaData[index].valid) ? Colors.white : Colors.clear)
    m_areaData[index].debug.fx.setColor((m_showDebugEffects and m_areaData[index].valid) ? m_areaData[index].debug.color : Colors.clear)
    m_areaData[index].debug.fx.setPos(m_areaData[index].pos)

// ============================================================================
function processRequests()
  if (g_updateRequests.isEmpty())
    return

  var attemptsCounter = 0

  while (not g_updateRequests.isEmpty() and attemptsCounter < MAX_ATTEMPTS_PER_LOOP)
  //{
    let request = g_updateRequests.dequeue()
    let spawnManager = request.getSpawnManager()
    let spawnAreaIndex = request.getSpawnAreaIndex()

    g_totalRequestsProcessed++

    if (spawnManager.isAreaValid(spawnAreaIndex))
      spawnManager.finishRequest(spawnAreaIndex)
      destroy request
    else
    //{
      var foundValidSpawnPoint = false
      
      var i = 0
      while i < MAX_ATTEMPTS_PER_REQUEST and attemptsCounter < MAX_ATTEMPTS_PER_LOOP
      //{
        i++
        attemptsCounter++
        g_totalUpdateSpawnAreaAttempts++

        request.incrementAttempts()
        g_mostAttempts = max(g_mostAttempts, request.getAttempts())
        
        if (spawnManager.updateSpawnArea(spawnAreaIndex))
          foundValidSpawnPoint = true
          g_totalFound++
          break
      //}

      if (foundValidSpawnPoint)
        spawnManager.finishRequest(spawnAreaIndex)
        destroy request
      else if (request.getRequeues() < MAX_REQUEUES_PER_REQUEST)
        request.incrementRequeues()
        g_totalRequeues++
        g_updateRequests.add(request)
        if (g_enableGCSMLogging)
          Log.debug("Requeuing request {0}:{1} after {2} attempts".format(
            spawnManager.getId(),
            spawnManager.getSpawnArea(spawnAreaIndex).toString(),
            request.getAttempts().toString()))
      else
        spawnManager.cancelRequest(spawnAreaIndex)
        if (g_enableGCSMLogging)
          Log.debug("Abandoning request {0}:{1} after {2} requeues".format(
            spawnManager.getId(),
            spawnManager.getSpawnArea(spawnAreaIndex).toString(),
            request.getRequeues().toString()))
        g_totalAbandoned++
        destroy request
    //}
  //}

// ============================================================================
class GCSMDebugger extends TLSFrame
  private framehandle m_textArea
  private unit m_selectedUnit

  // --------------------------------------------------------------------------
  construct()
    super(createFrame("FRAME", "GCSMDebugger", GAME_UI, "", 0))

  // --------------------------------------------------------------------------
  override function initialize()
    super.initialize()

    let frame = getFrameHandle()
    ..setWidth(0.35)
    ..setHeight(0.3)
    ..setAbsPoint(FRAMEPOINT_TOPLEFT, 0.46, 0.56)
    ..show()

    createFrame("BACKDROP", "UTCDebuggerBackdrop", GAME_UI, "BattleNetControlBackdropTemplate", 0)
    ..setParent(frame)
    ..setAllPoints(frame)

    m_textArea = createFrame("TEXTAREA", "UTCDebuggerTextArea", GAME_UI, "ConsoleTextArea", 0)
    ..setParent(frame)
    ..setAllPoints(frame)

    doPeriodically(0.1) (CallbackPeriodic cb) ->
      update()

  // --------------------------------------------------------------------------
  function setSelectedUnit(unit context)
    m_selectedUnit = context

  // --------------------------------------------------------------------------
  function update()

    if (getFrameHandle().isVisible() == false)
      return

    BlzFrameSetText(m_textArea, "===== Grid Spawn Manager =====")
    BlzFrameAddText(m_textArea, "Requests : " + g_updateRequests.size().toString())
    BlzFrameAddText(m_textArea, "Processed : " + g_totalRequestsProcessed.toString())
    BlzFrameAddText(m_textArea, "Attempts : " + g_totalUpdateSpawnAreaAttempts.toString())
    BlzFrameAddText(m_textArea, "Most Attempts : " + g_mostAttempts.toString())
    BlzFrameAddText(m_textArea, "Found : " + g_totalFound.toString())
    BlzFrameAddText(m_textArea, "Requeues : " + g_totalRequeues.toString())
    BlzFrameAddText(m_textArea, "Abandoned : " + g_totalAbandoned.toString())
    
    let friendlySpawnManager = getPlayerCachedFriendlySpawnManager(localPlayer)
    if (friendlySpawnManager != null)
      update_spawnManager(friendlySpawnManager)
    
    let hostileSpawnManager = getPlayerCachedHostileSpawnManager(localPlayer)
    if (hostileSpawnManager != null)
      update_spawnManager(hostileSpawnManager)

  // --------------------------------------------------------------------------
  private function update_spawnManager(GridCachedSpawnManager spawnManager)
    BlzFrameAddText(m_textArea, "----- {0} ({1}) -----".format(spawnManager.getId()))
    let camCursor = vec2(GetCameraTargetPositionX(), GetCameraTargetPositionY())
    let camCell = g_mapGrid.getCell(camCursor)
    let spawnAreaData = spawnManager.getSpawnArea(g_mapGrid.getIndex(camCell))
    BlzFrameAddText(m_textArea, "Focused: {0} d:{1} v:{2} r:{3}".format(
      spawnAreaData.toString(),
      spawnAreaData.valid.toString(), spawnAreaData.processingRequest.toString()))

// ============================================================================
init
  doPeriodically(0.5, (CallbackPeriodic cb) -> processRequests())

  if (DEV_ENVIRONMENT)
    doAfter(2) () ->
      g_gcsmDebugger = new GCSMDebugger()