package ScoutTowerComponent
import Events
import WorkstationComponent
import Range
import TooltipBuilder
import Unit_ScoutTower
import GameConstants
import TlsAbilityIds
import ChannelAbilityPreset
import Icons
import TlsUpgradeIds
import ClosureEvents
import HashMap
import ErrorHandling
import RealtimeUnitComponent
import ClosureTimers
import DamageEvent
import Damage
import DisplayTextToPlayer
import HumanPlayerComponent
import UnitExtensions
import Elites
import BuildingUndeadTarget

constant rangeInt   SCOUT_TOWER_SIGHT_RANGE                     = rangeInt(800, 1800)
constant real       SCOUT_TOWER_SIGHT_RANGE_PER_LEVEL           = SCOUT_TOWER_SIGHT_RANGE.getLength() / 10.0
constant real       SCOUT_TOWER_MAX_SIGHT_RANGE_SQ              = (SCOUT_TOWER_SIGHT_RANGE.max * SCOUT_TOWER_SIGHT_RANGE.max).toReal()

constant rangeInt   SCOUT_TOWER_ARMOR_DEC_RANGE                 = rangeInt(1, 3)
constant real       SCOUT_TOWER_ARMOR_DEC_RANGE_PERC_PER_LEVEL  = SCOUT_TOWER_ARMOR_DEC_RANGE.getLength() / 10.0

constant int array  SCOUT_TOWER_ACTIVE_SIGHT_ABILITY_ID         = [compiletime(ABIL_ID_GEN.next()), compiletime(ABIL_ID_GEN.next()), compiletime(ABIL_ID_GEN.next()), compiletime(ABIL_ID_GEN.next()), compiletime(ABIL_ID_GEN.next()), compiletime(ABIL_ID_GEN.next()), compiletime(ABIL_ID_GEN.next()), compiletime(ABIL_ID_GEN.next()), compiletime(ABIL_ID_GEN.next()), compiletime(ABIL_ID_GEN.next())]
constant int        SCOUT_TOWER_ACTIVE_ICON_ABILITY_ID          = compiletime(ABIL_ID_GEN.next())
constant int        SCOUT_TOWER_INACTIVE_ICON_ABILITY_ID        = compiletime(ABIL_ID_GEN.next())

constant string     MARKED_TARGET_FX = "Abilities\\Spells\\Items\\AIco\\CrownOfCmndTarget.mdl"

HashMap<unit, unit> g_markedTargetToScoutTowerMap = new HashMap<unit, unit>()
group g_tempGroup = CreateGroup()
boolexpr g_validTargetFilter = Condition(function isFilterUnitValidTargetForMarking)
player g_validTargetOwner

// ============================================================================
function getActiveSightRadius(int level) returns int
  return SCOUT_TOWER_SIGHT_RANGE.lerp(RANGE_ONE_TO_TEN.parameterize01(level)).toInt()

// ============================================================================
function getActiveTargetArmorReduction(int level) returns int
  return SCOUT_TOWER_ARMOR_DEC_RANGE.lerp(RANGE_ONE_TO_TEN.parameterize01(level)).toInt()

// ============================================================================
function isFilterUnitValidTargetForMarking() returns bool
  let filterUnit = GetFilterUnit()
  return not filterUnit.isStructure() and filterUnit.getOwner().isEnemyOf(g_validTargetOwner) and not g_markedTargetToScoutTowerMap.has(filterUnit)

// ============================================================================
@compiletime function createAbility()
  for i = 1 to 10
  //{
    new AbilityDefinitionSightBonus(SCOUT_TOWER_ACTIVE_SIGHT_ABILITY_ID[i-1])
    ..setSightRangeBonus(1, getActiveSightRadius(i))
  //}

  let activeWorkstationIconTooltipBuilder = new WorkstationIconTooltipBuilder(true)..setDescription(g_scoutTowerDefinition.getDescription())
  let inactiveWorkstationIconTooltipBuilder = new WorkstationIconTooltipBuilder(false)..setDescription(g_scoutTowerDefinition.getDescription())

  let properties = new WorkstationOperatorBonusTooltipItem()
  ..addValue(lvl -> "{0}m sight radius".format((getActiveSightRadius(lvl) * WORLD_TO_METERS).toString()))
  ..addValue(lvl -> "Target armor is reduced by {0}".format(getActiveTargetArmorReduction(lvl).toString()))
  activeWorkstationIconTooltipBuilder.addItem(properties)

  new AbilityActiveWorkstationIconDefinition(SCOUT_TOWER_ACTIVE_ICON_ABILITY_ID)
    ..setName("Lookout Tower")
    ..presetTooltipNormalExtended(lvl -> activeWorkstationIconTooltipBuilder.getTooltipExtended(lvl))

  new AbilityInactiveWorkstationIconDefinition(SCOUT_TOWER_INACTIVE_ICON_ABILITY_ID)
    ..setName("Lookout Tower")
    ..presetTooltipNormalExtended(lvl -> inactiveWorkstationIconTooltipBuilder.getTooltipExtended(lvl))

  destroy activeWorkstationIconTooltipBuilder
  destroy inactiveWorkstationIconTooltipBuilder

  new ChannelAbilityPreset(TlsAbilityIds.scoutTowerMarkTargets, 1, true)
    ..setHeroAbility(false)
    ..setItemAbility(false)
    ..presetTargetTypes(Targettype.UNIT)
    ..removeChannelProperties(true, true)
    ..presetBaseOrderID((lvl) -> "magicleash")
    ..setIconNormal(Icons.bTNReveal)
    ..setName("Mark Target")
    ..setTooltipNormal(1, "Mark Target")
    ..setTooltipNormalExtended(1, "Study an enemy unit to discover it's weak spot and mark it. Any units that attack the marked target will deal increased damage.")
    ..presetCastRange(lvl -> SCOUT_TOWER_SIGHT_RANGE.max.toReal())
    ..presetTargetsAllowed(lvl -> "enemy")
    ..setButtonPositionNormalX(0)
    ..setButtonPositionNormalY(0)
    ..setRequirements(commaList(TlsUpgradeIds.scoutTowerMarkTargets))

// ============================================================================
public class ScoutTowerComponent extends RealtimeUnitComponent
  private _handle m_workedEnteredCallback = INVALID_HANDLE
  private _handle m_workedExitedCallback = INVALID_HANDLE
  private _handle m_workedLeveledCallback = INVALID_HANDLE
  private bool m_activated = false
  private unit m_markedTarget
  private effect m_markedTargetFx

  // --------------------------------------------------------------------------
  construct (IUnitMetadata metadata)
    super(metadata)

  // --------------------------------------------------------------------------
  override function onEnabled()
    super.onEnabled()
    
    let workstationComponent = getOwner().getOrAddWorkstationComponent()
    m_workedEnteredCallback = workstationComponent.workerEntered.registerDispatched(this, () -> onWorkerEntered())
    m_workedExitedCallback = workstationComponent.workerExited.registerDispatched(this, () -> onWorkedExited())
    m_workedLeveledCallback = workstationComponent.workerLeveled.registerDispatched(this, () -> onWorkerLeveled())

    updateState()

  // --------------------------------------------------------------------------
  override function onDisabled()
    super.onDisabled()

    let workstationComponent = getOwner().getWorkstationComponent()
    if (workstationComponent != null)
      workstationComponent.workerEntered.unregister(m_workedEnteredCallback)
      workstationComponent.workerExited.unregister(m_workedExitedCallback)
      workstationComponent.workerLeveled.unregister(m_workedLeveledCallback)

    deactivate()

    if (m_markedTarget != null)
      g_markedTargetToScoutTowerMap.remove(m_markedTarget)
      m_markedTarget = null

    destroyMarkedTargetFX()

  // --------------------------------------------------------------------------
  function markTarget(unit target)
    if (m_markedTarget == target)
      return
    g_markedTargetToScoutTowerMap.put(target, getOwnerUnit())
    m_markedTarget = target
    this.registerForRealtimeUpdate(RealtimeUpdatePriority.Background)

    destroyMarkedTargetFX()
    
    m_markedTargetFx = addEffect(MARKED_TARGET_FX, m_markedTarget, "overhead")

  // --------------------------------------------------------------------------
  protected function onMarkedTargetLost(unit target)
    if (m_markedTarget != target)
      return
    this.unregisterForRealtimeUpdate()
    g_markedTargetToScoutTowerMap.remove(target)
    m_markedTarget = null

    destroyMarkedTargetFX()

    if (m_activated)
      tryFindNextTargetLater()

  // --------------------------------------------------------------------------
  private function destroyMarkedTargetFX()
    if (m_markedTargetFx != null)
      m_markedTargetFx.destr()
      m_markedTargetFx = null

  // --------------------------------------------------------------------------
  private function tryFindNextTarget()

    if (m_markedTarget != null or not m_activated)
      return

    let ownerUnit = getOwnerUnit()
    let ownerUnitPos = ownerUnit.getPos()
    let sightRadiusLevel = ownerUnit.getAbilityLevel(SCOUT_TOWER_ACTIVE_ICON_ABILITY_ID)

    g_validTargetOwner = ownerUnit.getOwner()
    g_tempGroup.enumUnitsInRange(ownerUnitPos, getActiveSightRadius(sightRadiusLevel).toReal(), g_validTargetFilter)
    g_validTargetOwner = null

    // Try again later
    if (not g_tempGroup.hasNext())
      tryFindNextTargetLater()
      return

    unit bestTarget = null
    var bestScore = REAL_MAX

    for u in g_tempGroup
    //{
      real score
      let dd = u.getPos().distanceToSq(ownerUnitPos)
      if (u.isBoss())
        score = dd
      else if (u.isElite())
        score = SCOUT_TOWER_MAX_SIGHT_RANGE_SQ + dd
      else
        score = 2 * SCOUT_TOWER_MAX_SIGHT_RANGE_SQ + dd
      if (score < bestScore)
        bestScore = score
        bestTarget = u
    //}

    g_tempGroup.clear()

    if (bestTarget == null)
      tryFindNextTargetLater()
      return

    markTarget(bestTarget)

  // --------------------------------------------------------------------------
  private function tryFindNextTargetLater()
    doAfter(1.0, () -> tryFindNextTarget())

  // --------------------------------------------------------------------------
  override function realtimeUpdate(real _dt)

    if (m_markedTarget.getPos().distanceToSq(getOwnerUnit().getPos()) > SCOUT_TOWER_SIGHT_RANGE.max*SCOUT_TOWER_SIGHT_RANGE.max)
      let markedTarget = m_markedTarget
      nullTimer(() -> onMarkedTargetLost(markedTarget))
    
  // --------------------------------------------------------------------------
  private function onWorkerEntered()
    if (getNumberOfWorkers() == 1)
      activate()

  // --------------------------------------------------------------------------
  private function onWorkedExited()
    if (getNumberOfWorkers() == 0)
      deactivate()

  // --------------------------------------------------------------------------
  private function onWorkerLeveled()
    updateState()

  // --------------------------------------------------------------------------
  private function getNumberOfWorkers() returns int
    let workstationComponent = getOwner().getWorkstationComponent()
    return workstationComponent != null ? workstationComponent.getLoadedUnitCount() : 0

  // --------------------------------------------------------------------------
  private function activate()
    setActive(true)

  // --------------------------------------------------------------------------
  private function deactivate()
    setActive(false)

  // --------------------------------------------------------------------------
  private function setActive(bool active)
    if (m_activated == active)
      return
    m_activated = active
    updateState()

  // --------------------------------------------------------------------------
  private function getOperatorLevel() returns int
    if (m_activated)
      let workstationComponent = getOwner().getWorkstationComponent()
      if (workstationComponent != null)
        return workstationComponent.getMaxOperatorLevel()
    return 1

  // --------------------------------------------------------------------------
  private function updateState()
    let ownerUnit = getOwnerUnit()

    let operatorLevel = getOperatorLevel()

    for i = 1 to 10
      if (m_activated and operatorLevel == i)
        ownerUnit.addAbility(SCOUT_TOWER_ACTIVE_SIGHT_ABILITY_ID[i-1])
      else
        ownerUnit.removeAbility(SCOUT_TOWER_ACTIVE_SIGHT_ABILITY_ID[i-1])

    if (m_activated)
      ownerUnit.removeAbility(SCOUT_TOWER_INACTIVE_ICON_ABILITY_ID)
      ownerUnit.addAbility(SCOUT_TOWER_ACTIVE_ICON_ABILITY_ID)
      ownerUnit.setAbilityLevel(SCOUT_TOWER_ACTIVE_ICON_ABILITY_ID, operatorLevel)
      ownerUnit.addAbility(TlsAbilityIds.scoutTowerMarkTargets)
    else
      ownerUnit.removeAbility(TlsAbilityIds.scoutTowerMarkTargets)
      ownerUnit.removeAbility(SCOUT_TOWER_ACTIVE_ICON_ABILITY_ID)
      ownerUnit.addAbility(SCOUT_TOWER_INACTIVE_ICON_ABILITY_ID)

    if (m_activated)
      tryFindNextTarget()
    else if (m_markedTarget != null)
      onMarkedTargetLost(m_markedTarget)

// ============================================================================
public function IUnitMetadata.getScoutTowerComponent() returns ScoutTowerComponent
  return this.getComponent(ScoutTowerComponent.typeId) castTo ScoutTowerComponent

// ============================================================================
public function IUnitMetadata.getOrAddScoutTowerComponent() returns ScoutTowerComponent
  var component = this.getScoutTowerComponent()
  if (component == null)
    component = this.addComponent(new ScoutTowerComponent(this)) castTo ScoutTowerComponent
  return component

// ============================================================================
function onMarkTargetAbilCast(unit caster, unit target)

  if (g_markedTargetToScoutTowerMap.has(target))
    displayErrorToPlayer(caster.getOwner(), "Failed to Mark Target", "Unit has already been marked")
    return

  let metadata = caster.getMetadata()
  if (metadata == null)
    return

  let comp = metadata.getScoutTowerComponent()
  if (comp == null)
    return

  comp.markTarget(target)

// ============================================================================
function onUnitKilled()
  let dyingUnit = GetDyingUnit()
  if (not g_markedTargetToScoutTowerMap.has(dyingUnit))
    return
  let scoutTowerUnit = g_markedTargetToScoutTowerMap.get(dyingUnit)
  if (scoutTowerUnit == null)
    error("Scout Tower unit is null")
  let comp = scoutTowerUnit.getMetadata().getScoutTowerComponent()
  comp.onMarkedTargetLost(dyingUnit)

// ============================================================================
function onDamageEventRelative()
  if (DamageEvent.getSource().isBuildingUndeadTarget())
    return
  let target = DamageEvent.getTarget()
  if (not g_markedTargetToScoutTowerMap.has(target))
    return
  let scoutTower = g_markedTargetToScoutTowerMap.get(target)
  let playerComp = scoutTower.getOwner().getMetadata().getHumanPlayerComponent()
  let scale = playerComp.markedTargetDamageScalePerc01.getValue()
  DamageEvent.addAmount(DamageEvent.getOriginalAmount() * scale)

// ============================================================================
init
  EventListener.onTargetCast(TlsAbilityIds.scoutTowerMarkTargets, (unit caster, unit target) -> onMarkTargetAbilCast(caster, target))
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_DEATH, function onUnitKilled)
  DamageEvent.addListener(DAMAGE_EVENT_PRIO_RELATIVE, () -> onDamageEventRelative())