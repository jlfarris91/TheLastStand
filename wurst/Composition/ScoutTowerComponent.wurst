package ScoutTowerComponent
import Events
import WorkstationComponent
import Range
import TooltipBuilder
import Unit_ScoutTower
import GameConstants
import TlsAbilityIds
import ChannelAbilityPreset
import Icons
import TlsUpgradeIds
import ClosureEvents
import HashMap
import ErrorHandling
import RealtimeUnitComponent
import ClosureTimers
import DamageEvent
import Damage
import DisplayTextToPlayer
import HumanPlayerComponent
import UnitExtensions
import Elites
import BuildingUndeadTarget
import BuffObjEditing
import StandardTextTags
import TlsUnitIds
import RealExtensions
import DefenseUpgrades
import SmartValue
import LinkedList
import ExperienceComponent
import FX

constant rangeInt   SCOUT_TOWER_SIGHT_RANGE                     = rangeInt(800, 1800)
constant real       SCOUT_TOWER_SIGHT_RANGE_PER_LEVEL           = SCOUT_TOWER_SIGHT_RANGE.getLength() / 10.0
constant real       SCOUT_TOWER_MAX_SIGHT_RANGE_SQ              = (SCOUT_TOWER_SIGHT_RANGE.max * SCOUT_TOWER_SIGHT_RANGE.max).toReal()

constant rangeInt   SCOUT_TOWER_ARMOR_DEC_RANGE                 = rangeInt(1, 3)
constant real       SCOUT_TOWER_ARMOR_DEC_RANGE_PERC_PER_LEVEL  = SCOUT_TOWER_ARMOR_DEC_RANGE.getLength() / 10.0

constant int array  SCOUT_TOWER_ACTIVE_SIGHT_ABILITY_ID         = [compiletime(ABIL_ID_GEN.next()), compiletime(ABIL_ID_GEN.next()), compiletime(ABIL_ID_GEN.next()), compiletime(ABIL_ID_GEN.next()), compiletime(ABIL_ID_GEN.next()), compiletime(ABIL_ID_GEN.next()), compiletime(ABIL_ID_GEN.next()), compiletime(ABIL_ID_GEN.next()), compiletime(ABIL_ID_GEN.next()), compiletime(ABIL_ID_GEN.next())]
constant int        SCOUT_TOWER_ACTIVE_ICON_ABILITY_ID          = compiletime(ABIL_ID_GEN.next())
constant int        SCOUT_TOWER_INACTIVE_ICON_ABILITY_ID        = compiletime(ABIL_ID_GEN.next())
constant buffTuple  MARKED_TARGET_BUFF                          = compiletime(createDummyBuffObject("Marked", "This unit is marked; it takes additional damage", Icons.bTNReveal, "Abilities\\Marked\\Marked.mdl", "overhead"))

HashMap<unit, unit> g_markedTargetToScoutTowerMap = new HashMap<unit, unit>()
group g_tempGroup = CreateGroup()
player g_validTargetOwner
boolexpr g_validTargetFilter = Condition(function isFilterUnitValidTargetForMarking)
boolexpr g_filterUnitIsScoutTower = Condition(function filterUnitIsScoutTower)

// ============================================================================
function getActiveSightRadius(int level) returns int
  return SCOUT_TOWER_SIGHT_RANGE.lerp(RANGE_ONE_TO_TEN.parameterize01(level)).toInt()

// ============================================================================
function isFilterUnitValidTargetForMarking() returns bool
  let filterUnit = GetFilterUnit()
  return filterUnit.isAlive() and not filterUnit.isStructure() and filterUnit.getOwner().isEnemyOf(g_validTargetOwner) and not g_markedTargetToScoutTowerMap.has(filterUnit)

// ============================================================================
@compiletime function createAbility()
  for i = 1 to 10
  //{
    new AbilityDefinitionSightBonus(SCOUT_TOWER_ACTIVE_SIGHT_ABILITY_ID[i-1])
    ..setSightRangeBonus(1, getActiveSightRadius(i))
  //}

  let activeWorkstationIconTooltipBuilder = new WorkstationIconTooltipBuilder(true)..setDescription(g_scoutTowerDefinition.getDescription())
  let inactiveWorkstationIconTooltipBuilder = new WorkstationIconTooltipBuilder(false)..setDescription(g_scoutTowerDefinition.getDescription())

  let properties = new WorkstationOperatorBonusTooltipItem()
  ..addValue(lvl -> "{0}m sight radius".format((getActiveSightRadius(lvl) * WORLD_TO_METERS).toString()))
  ..addValue(lvl -> "Marked Targets take {0} more damage".format(getMarkedTargetDamageScalePerc01(lvl).toPercentageString01()))
  activeWorkstationIconTooltipBuilder.addItem(properties)

  new AbilityActiveWorkstationIconDefinition(SCOUT_TOWER_ACTIVE_ICON_ABILITY_ID)
    ..setName("Lookout Tower")
    ..presetTooltipNormalExtended(lvl -> activeWorkstationIconTooltipBuilder.getTooltipExtended(lvl))

  new AbilityInactiveWorkstationIconDefinition(SCOUT_TOWER_INACTIVE_ICON_ABILITY_ID)
    ..setName("Lookout Tower")
    ..presetTooltipNormalExtended(lvl -> inactiveWorkstationIconTooltipBuilder.getTooltipExtended(lvl))

  destroy activeWorkstationIconTooltipBuilder
  destroy inactiveWorkstationIconTooltipBuilder

  new ChannelAbilityPreset(TlsAbilityIds.scoutTowerMarkTargets, 1, true)
    ..setHeroAbility(false)
    ..setItemAbility(false)
    ..presetTargetTypes(Targettype.UNIT)
    ..removeChannelProperties(true, true)
    ..presetBaseOrderID((lvl) -> "magicleash")
    ..setIconNormal(Icons.bTNReveal)
    ..setName("Mark Target")
    ..setTooltipNormal(1, "Mark Target")
    ..setTooltipNormalExtended(1, "Study an enemy unit to discover it's weak spot and mark it. Any units that attack the marked target will deal increased damage.")
    ..presetCastRange(lvl -> SCOUT_TOWER_SIGHT_RANGE.max.toReal())
    ..presetTargetsAllowed(lvl -> "enemy")
    ..setButtonPositionNormalX(0)
    ..setButtonPositionNormalY(0)
    ..setRequirements(commaList(TlsUpgradeIds.scoutTowerMarkTargets))
    ..setHotkeyNormal("Q")

// ============================================================================
public class ScoutTowerComponent extends RealtimeUnitComponent
  private _handle m_workedEnteredCallback = INVALID_HANDLE
  private _handle m_workedExitedCallback = INVALID_HANDLE
  private _handle m_workedLeveledCallback = INVALID_HANDLE
  private bool m_activated = false
  private LinkedList<unit> m_markedTargets = new LinkedList<unit>()
  private SmartValue m_maxTargets

  // --------------------------------------------------------------------------
  construct (IUnitMetadata metadata)
    super(metadata)

  // --------------------------------------------------------------------------
  ondestroy
    destroy m_markedTargets

  // --------------------------------------------------------------------------
  override function onEnabled()
    super.onEnabled()
    
    let workstationComponent = getOwner().getOrAddWorkstationComponent()
    m_workedEnteredCallback = workstationComponent.onWorkedEntered().registerDispatched(this, () -> onWorkerEntered())
    m_workedExitedCallback = workstationComponent.onWorkedExited().registerDispatched(this, () -> onWorkedExited())
    m_workedLeveledCallback = workstationComponent.onWorkedLeveled().registerDispatched(this, () -> onWorkerLeveled())

    let humanOwnerComp = getOwnerUnit().getOwnerHumanPlayerComponent()
    if (humanOwnerComp != null)
      m_maxTargets = humanOwnerComp.scoutTowerMaxTargets.attach(this)

    updateState()

  // --------------------------------------------------------------------------
  override function onDisabled()
    super.onDisabled()

    let workstationComponent = getOwner().getWorkstationComponent()
    if (workstationComponent != null)
      workstationComponent.onWorkedEntered().unregister(m_workedEnteredCallback)
      workstationComponent.onWorkedExited().unregister(m_workedExitedCallback)
      workstationComponent.onWorkedLeveled().unregister(m_workedLeveledCallback)

    if (m_maxTargets != null)
      destroy m_maxTargets
      m_maxTargets = null

    deactivate()
    clearMarkedTargets()

  // --------------------------------------------------------------------------
  function getMaxTargets() returns int
    return m_maxTargets != null ? m_maxTargets.getValue().toInt() : 0

  // --------------------------------------------------------------------------
  function markTarget(unit target)
    if (m_markedTargets.has(target))
      return

    let numMarkedTargets = m_markedTargets.size()
    if (numMarkedTargets == getMaxTargets())
      onMarkedTargetLost(m_markedTargets.getFirst(), false)

    g_markedTargetToScoutTowerMap.put(target, getOwnerUnit())
    m_markedTargets.add(target)

    if (m_markedTargets.size() == 1)
      this.registerForRealtimeUpdate(RealtimeUpdatePriority.Background)

    target.addAbility(MARKED_TARGET_BUFF.abilId)

  // --------------------------------------------------------------------------
  protected function onMarkedTargetKilled(unit target)

    onMarkedTargetLost(target, true)

    // Give the operator experience for the kill as well
    let ownerUnit = getOwnerUnit()
    let xpComp = getOwner().getOrAddExperienceComponent()
    let xp = xpComp.getXpValueForKilledUnit(target)
    xpComp.giveOwnerUnitXp(xp, true)
    FX.createGainedXPTag(ownerUnit.getPos(), xp, ownerUnit.getOwner())

  // --------------------------------------------------------------------------
  protected function onMarkedTargetLost(unit target, bool tryFindNextTarget)
    if (not m_markedTargets.has(target))
      return

    target.removeAbility(MARKED_TARGET_BUFF.abilId)
    target.removeAbility(MARKED_TARGET_BUFF.buffId)

    g_markedTargetToScoutTowerMap.remove(target)
    m_markedTargets.remove(target)

    if (m_markedTargets.isEmpty())
      this.unregisterForRealtimeUpdate()

    if (m_activated and tryFindNextTarget)
      tryFindNextTargetLater()

  // --------------------------------------------------------------------------
  private function clearMarkedTargets()

    while (m_markedTargets.isEmpty() == false)
      onMarkedTargetLost(m_markedTargets.getFirst(), false)

  // --------------------------------------------------------------------------
  private function tryFindNextTarget()

    if (not m_activated or m_markedTargets.size() == getMaxTargets())
      return

    let ownerUnit = getOwnerUnit()
    let ownerUnitPos = ownerUnit.getPos()
    let sightRadius = getSightRadius()

    g_validTargetOwner = ownerUnit.getOwner()
    g_tempGroup.enumUnitsInRange(ownerUnitPos, sightRadius, g_validTargetFilter)
    g_validTargetOwner = null

    // Try again later
    if (not g_tempGroup.hasNext())
      tryFindNextTargetLater()
      return

    unit bestTarget = null
    var bestScore = REAL_MAX

    for u in g_tempGroup
    //{
      real score
      let dd = u.getPos().distanceToSq(ownerUnitPos)
      if (u.isBoss())
        score = dd
      else if (u.isElite())
        score = SCOUT_TOWER_MAX_SIGHT_RANGE_SQ + dd
      else
        score = 2 * SCOUT_TOWER_MAX_SIGHT_RANGE_SQ + dd
      if (score < bestScore)
        bestScore = score
        bestTarget = u
    //}

    g_tempGroup.clear()

    if (bestTarget == null)
      tryFindNextTargetLater()
      return

    markTarget(bestTarget)

    if (m_markedTargets.size() < getMaxTargets())
      tryFindNextTargetLater()

  // --------------------------------------------------------------------------
  private function tryFindNextTargetLater()
    doAfter(1.0, () -> tryFindNextTarget())

  // --------------------------------------------------------------------------
  private function getSightRadius() returns real
    let sightRadiusLevel = getOwnerUnit().getAbilityLevel(SCOUT_TOWER_ACTIVE_ICON_ABILITY_ID)
    return getActiveSightRadius(sightRadiusLevel).toReal()

  // --------------------------------------------------------------------------
  override function realtimeUpdate(real _dt)

    let sightRadius = getSightRadius()

    for target in m_markedTargets
      if (target.getPos().distanceToSq(getOwnerUnit().getPos()) > sightRadius*sightRadius)
        nullTimer(() -> onMarkedTargetLost(target, true))
    
  // --------------------------------------------------------------------------
  private function onWorkerEntered()

    let workstationComponent = getOwner().getOrAddWorkstationComponent()
    getOwnerUnit().setXpTarget(workstationComponent.getLoadedUnitAt(0))

    if (getNumberOfWorkers() == 1)
      activate()

  // --------------------------------------------------------------------------
  private function onWorkedExited()

    getOwnerUnit().clearXpTarget()

    if (getNumberOfWorkers() == 0)
      deactivate()

  // --------------------------------------------------------------------------
  private function onWorkerLeveled()
    updateState()

  // --------------------------------------------------------------------------
  private function getNumberOfWorkers() returns int
    let workstationComponent = getOwner().getWorkstationComponent()
    return workstationComponent != null ? workstationComponent.getLoadedUnitCount() : 0

  // --------------------------------------------------------------------------
  private function activate()
    setActive(true)

  // --------------------------------------------------------------------------
  private function deactivate()
    setActive(false)

  // --------------------------------------------------------------------------
  private function setActive(bool active)
    if (m_activated == active)
      return
    m_activated = active
    updateState()

  // --------------------------------------------------------------------------
  private function getOperatorLevel() returns int
    if (m_activated)
      let workstationComponent = getOwner().getWorkstationComponent()
      if (workstationComponent != null)
        return workstationComponent.getMaxOperatorLevel()
    return 1

  // --------------------------------------------------------------------------
  protected function updateState()
    let ownerUnit = getOwnerUnit()

    let operatorLevel = getOperatorLevel()

    for i = 1 to 10
      if (m_activated and operatorLevel == i)
        ownerUnit.addAbility(SCOUT_TOWER_ACTIVE_SIGHT_ABILITY_ID[i-1])
      else
        ownerUnit.removeAbility(SCOUT_TOWER_ACTIVE_SIGHT_ABILITY_ID[i-1])

    if (m_activated)
      ownerUnit.removeAbility(SCOUT_TOWER_INACTIVE_ICON_ABILITY_ID)
      ownerUnit.addAbility(SCOUT_TOWER_ACTIVE_ICON_ABILITY_ID)
      ownerUnit.setAbilityLevel(SCOUT_TOWER_ACTIVE_ICON_ABILITY_ID, operatorLevel)
      ownerUnit.addAbility(TlsAbilityIds.scoutTowerMarkTargets)
    else
      ownerUnit.removeAbility(TlsAbilityIds.scoutTowerMarkTargets)
      ownerUnit.removeAbility(SCOUT_TOWER_ACTIVE_ICON_ABILITY_ID)
      ownerUnit.addAbility(SCOUT_TOWER_INACTIVE_ICON_ABILITY_ID)

    if (m_activated)
      tryFindNextTarget()
    else
      clearMarkedTargets()

// ============================================================================
public function IUnitMetadata.getScoutTowerComponent() returns ScoutTowerComponent
  return this.getComponent(ScoutTowerComponent.typeId) castTo ScoutTowerComponent

// ============================================================================
public function IUnitMetadata.getOrAddScoutTowerComponent() returns ScoutTowerComponent
  var component = this.getScoutTowerComponent()
  if (component == null)
    component = this.addComponent(new ScoutTowerComponent(this)) castTo ScoutTowerComponent
  return component

// ============================================================================
function onMarkTargetAbilCast(unit caster, unit target)

  if (g_markedTargetToScoutTowerMap.has(target))
    displayErrorToPlayer(caster.getOwner(), "Failed to Mark Target", "Unit has already been marked")
    return

  let metadata = caster.getMetadata()
  if (metadata == null)
    return

  let comp = metadata.getScoutTowerComponent()
  if (comp == null)
    return

  comp.markTarget(target)

// ============================================================================
function onUnitKilled()
  let dyingUnit = GetDyingUnit()
  if (not g_markedTargetToScoutTowerMap.has(dyingUnit))
    return
  let scoutTowerUnit = g_markedTargetToScoutTowerMap.get(dyingUnit)
  if (scoutTowerUnit == null)
    error("Scout Tower unit is null")
  let comp = scoutTowerUnit.getMetadata().getScoutTowerComponent()
  comp.onMarkedTargetKilled(dyingUnit)

// ============================================================================
function filterUnitIsScoutTower() returns bool
  let filterUnit = GetFilterUnit()
  return filterUnit.getTypeId() == TlsUnitIds.scoutTower and filterUnit.isAlive()

// ============================================================================
function onDamageEventRelative()
  if (DamageEvent.getSource().isBuildingUndeadTarget())
    return
  let target = DamageEvent.getTarget()
  if (not g_markedTargetToScoutTowerMap.has(target))
    return
  let scoutTower = g_markedTargetToScoutTowerMap.get(target)
  let playerComp = scoutTower.getOwnerHumanPlayerComponent()
  let scale = playerComp.scoutTowerMarkedTargetDamageScalar01.getValue()
  DamageEvent.addAmount(DamageEvent.getOriginalAmount() * scale)

// ============================================================================
function onDamageEventFinal()
  let target = DamageEvent.getTarget()
  if (not g_markedTargetToScoutTowerMap.has(target))
    return
  let source = DamageEvent.getSource()
  // It's just too annoying to see this for spikes
  if (source.isSpikes())
    return
  let damageAmount = DamageEvent.getAmount().floor()
  if (damageAmount > 0)
    createCriticalStrikeTextTag(source, damageAmount)

// ============================================================================
init
  EventListener.onTargetCast(TlsAbilityIds.scoutTowerMarkTargets, (unit caster, unit target) -> onMarkTargetAbilCast(caster, target))
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_DEATH, function onUnitKilled)
  DamageEvent.addListener(DAMAGE_EVENT_PRIO_RELATIVE, () -> onDamageEventRelative())
  DamageEvent.addListener(DAMAGE_EVENT_PRIO_FINAL, () -> onDamageEventFinal())