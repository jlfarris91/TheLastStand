package UndeadTargetingComponent
import UnitComponent
import HumanPlayerMetadata
import Events
import LinkedList
import RegisterEvents
import HashMap
import HumanPlayers
import TlsUnitIds
import HashList
import GroupUtils
import Unit_WoodFence
import Unit_StoneWall
import Unit_GateCommon
import Unit_MetalWall
import Orders
import TargetUtility
import UnitExtensions
import ClosureTimers
import RealTime
import Dispatcher

constant real ATTACK_TIMER_INTERVAL = 1.0
constant real ATTACK_TIMER_DURATION = 10.0

HashMap<player, LinkedList<unit>> g_validHumanStructureTargets
HashList<int> g_validTargetStructureIds
conditionfunc g_filterUnitIsValidTargetStructure = Condition(function filterUnitIsValidTargetStructure)
conditionfunc g_filterUnitIsValidTargetNonStructure = Condition(function filterUnitIsValidTargetNonStructure)
HashMap<unit, HashList<UndeadTargetingComponent>> g_targetedUnitToUTCMap = new HashMap<unit, HashList<UndeadTargetingComponent>>()
HashList<UndeadTargetingComponent> g_activeUndeadTargetingComponents = new HashList<UndeadTargetingComponent>()
Dispatcher g_issueOrderDispatcher

/*

  This component is used to direct spawned enemies to attack a target player.
  
  It works by first attempting to target one of the player's "exterior structures"
  such as barricades, walls, gates, etc. We can reasonably assume that players
  will build at least one of these structures at some point. This works whether
  the player's base is completely closed off or has a pathable opening.
  
  We keep track of all of these exterior structures to make the operation as
  efficient as possible; issueOrderTargetingPlayer() is called at least once
  per enemy. We need to remember to update g_validTargetStructureIds with any
  new exterior structures added to the game.

  If the player has built no exterior structure then the unit will target the
  player's camp tent. If the player has no camp tent the unit will target the
  player's hero.

  Finally, if there is nothing to target so far the unit will increase it's
  acquisition range to the maximum. It should find SOMETHING to attack.

  We use the attack-move order in hopes of having the unit wander into range
  of a player's unit to attack. However, this can also mean that it can wander
  by another player's camp and attack it instead. This is fine.

*/

// ============================================================================
public class UndeadTargetingComponent extends UnitComponent
  private player m_targetPlayer
  private Event m_targetPlayerChangedEvent
  private unit m_targetUnit
  private int m_attackTime
  private bool m_awaitingOrder

  // --------------------------------------------------------------------------
  construct(IUnitMetadata owner)
    super(owner)
    m_targetPlayer = null
    m_targetUnit = null

  // --------------------------------------------------------------------------
  ondestroy
    if (m_targetPlayerChangedEvent != null)
      destroy m_targetPlayerChangedEvent
      m_targetPlayerChangedEvent = null

  // --------------------------------------------------------------------------
  override function getTypeId() returns int
    return UndeadTargetingComponent.typeId

  // --------------------------------------------------------------------------
  override function onEnabled()
    super.onEnabled()
    g_activeUndeadTargetingComponents.add(this)

  // --------------------------------------------------------------------------
  override function onDisabled()
    super.onDisabled()
    g_activeUndeadTargetingComponents.remove(this)

  // --------------------------------------------------------------------------
  function getTargetPlayerChangedEvent() returns Event
    if (m_targetPlayerChangedEvent == null)
      m_targetPlayerChangedEvent = new Event()
    return m_targetPlayerChangedEvent

  // --------------------------------------------------------------------------
  function getTargetUnit() returns unit
    return m_targetUnit

  // --------------------------------------------------------------------------
  function getTargetPlayer() returns player
    return m_targetPlayer

  // --------------------------------------------------------------------------
  function setTargetPlayer(player p) returns bool
    if (p == m_targetPlayer)
      return false
    m_targetPlayer = p
    setTargetUnit(null)
    raiseTargetPlayerChangedEvent()
    issueOrderTargetingPlayer()
    return true

  // --------------------------------------------------------------------------
  function issueOrderTargetingPlayer()

    if (not getOwnerUnit().isAlive())
      return

    // We're already awaiting a call to issueOrderTargetingPlayer_impl so early out
    if (m_awaitingOrder)
      return

    m_awaitingOrder = true

    // Dispatch this operation to limit how often this gets executed because
    // finding the nearest unit can be expensive
    g_issueOrderDispatcher.invoke(() -> issueOrderTargetingPlayer_impl(), DispatchPriority.LOW)

  // --------------------------------------------------------------------------
  private function issueOrderTargetingPlayer_impl()

    m_awaitingOrder = false
    restartAttackTimer()

    if (not getOwnerUnit().isAlive())
      return

    if (tryReissueOrder())
      return

    // 1. Try attacking the nearest structure
    // 2. Try attacking the nearest non-structure
    if (tryTargetClosestUnit())
      //Log.debug("[UndeadTargetingComponent] Found target to attack")
      return

    // At this point the target unit must not have been valid
    setTargetUnit(null)

    // 3. Try attack-moving to the target player's camp center (the OT or the hero)
    if (tryTargetCampCenter())
      //Log.debug("[UndeadTargetingComponent] Could not find target unit, attack-moving to camp center")
      return

    // 4. The target player is either null or considered dead, so try targeting another alive player
    if (m_targetPlayer == null or m_targetPlayer.getHumanMetadataRequired().getIsDead())
      // If we actually picked a new target player then re-issue the order
      if (pickNextValidTargetPlayer())
        issueOrderTargetingPlayer()
        return

    // 5. If there are really no players left to attack then just die
    //Log.debug("[UndeadTargetingComponent] Found no player to attack")
    nullTimer(() -> getOwnerUnit().kill())

  // --------------------------------------------------------------------------
  function tryReissueOrder() returns bool
    if (m_targetUnit == null)
      return false
    
    if (not unitIsValidTargetStructure(m_targetUnit) or
        not unitIsValidTargetNonStructure(m_targetUnit))
      return false
      
    return getOwnerUnit().issueTargetOrderById(OrderIds.attack, m_targetUnit)

  // --------------------------------------------------------------------------
  private function pickNextValidTargetPlayer() returns bool
    let currentTargetPlayer = m_targetPlayer
    for _player in g_PlayingHumanPlayers
      if (_player != m_targetPlayer and not _player.getHumanMetadataRequired().getIsDead())
        setTargetPlayer(_player)
        return true
    setTargetPlayer(null)
    return currentTargetPlayer != null

  // --------------------------------------------------------------------------
  private function setTargetUnit(unit targetUnit)
    if (m_targetUnit == targetUnit)
      return
    if (m_targetUnit != null)
      unregisterTargetedUnit(m_targetUnit, this)
    m_targetUnit = targetUnit
    if (m_targetUnit != null)
      registerTargetedUnit(m_targetUnit, this)
    restartAttackTimer()

  // --------------------------------------------------------------------------
  protected function tryTargetClosestUnit() returns bool
    let targetPlayer = getTargetPlayer()
    if (targetPlayer == null)
      return false

    let ownerUnit = getOwnerUnit()
    unit targetUnit

    // Try to attack the nearest structure
    targetUnit = getClosestValidHumanStructureTarget(targetPlayer, ownerUnit.getPos())
    if (targetUnit != null)
      m_targetUnit = targetUnit
      return ownerUnit.issueTargetOrderById(OrderIds.attack, m_targetUnit)

    // There are no structures to attack? Try attacking a non-structure unit then
    if (targetUnit == null)
      targetUnit = getNearestUnitOfPlayer(targetPlayer, ownerUnit.getPos(), g_filterUnitIsValidTargetNonStructure)

    if (targetUnit != null)
      setTargetUnit(targetUnit)
      return ownerUnit.issueTargetOrderById(OrderIds.attack, m_targetUnit)

    return false

  // --------------------------------------------------------------------------
  protected function tryTargetCampCenter() returns bool    
    let targetPlayer = getTargetPlayer()
    if (targetPlayer == null)
      return false

    let playerMetadata = targetPlayer.getHumanMetadata()
    if (playerMetadata == null or playerMetadata.getIsDead())
      return false

    let campCenter = playerMetadata.getCampCenter()
    let undeadUnit = getOwnerUnit()
    undeadUnit.issuePointOrder("attack", campCenter)
    return true

  // --------------------------------------------------------------------------
  protected function onTargetUnitDied()
    setTargetUnit(null)
    issueOrderTargetingPlayer()

  // --------------------------------------------------------------------------
  protected function onAttackedTargetUnit()
    restartAttackTimer()

  // --------------------------------------------------------------------------
  private function raiseTargetPlayerChangedEvent()
    if (m_targetPlayerChangedEvent != null)
      m_targetPlayerChangedEvent.call()

  // --------------------------------------------------------------------------
  protected function onAttackTimer()
    if (m_awaitingOrder)
      return
    // If the timer has expired then this unit hasn't been able to attack
    // it's target in a while so try to target a new enemy
    if (getRealTimeSeconds() - m_attackTime > ATTACK_TIMER_DURATION)
      setTargetUnit(null)
      issueOrderTargetingPlayer()

  // --------------------------------------------------------------------------
  protected function restartAttackTimer()
    m_attackTime = getRealTimeSeconds()

// ============================================================================
public function IUnitMetadata.getUndeadTargetingComponent() returns UndeadTargetingComponent
  return this.getComponent(typeInfo(UndeadTargetingComponent.typeId)) castTo UndeadTargetingComponent

// ============================================================================
public function IUnitMetadata.getOrAddUndeadTargetingComponent() returns UndeadTargetingComponent
  var component = this.getUndeadTargetingComponent()
  if (component == null)
    component = this.addComponent(new UndeadTargetingComponent(this)) castTo UndeadTargetingComponent
  return component

// ============================================================================
function getClosestValidHumanStructureTarget(player p, vec2 pos) returns unit
  let targetList = g_validHumanStructureTargets.get(p)
  if (targetList.isEmpty())
    return null
  
  var distance = REAL_MAX
  unit target = null

  for u in targetList
    let d = u.getPos().distanceToSq(pos)
    if (d < distance)
      target = u
      distance = d

  return target

// ============================================================================
function unitIsValidTargetStructure(unit u) returns bool
  return g_validTargetStructureIds.has(u.getTypeId())

// ============================================================================
function filterUnitIsValidTargetStructure() returns bool
  return unitIsValidTargetStructure(GetFilterUnit())

// ============================================================================
function unitIsValidTargetNonStructure(unit u) returns bool
  return u.isAlive() and not u.isInvulnerable() and not u.isStructure()

// ============================================================================
function filterUnitIsValidTargetNonStructure() returns bool
  return unitIsValidTargetNonStructure(GetFilterUnit())

// ============================================================================
function onConstructionFinished()
  let constructedUnit = GetConstructedStructure()
  let owningPlayer = constructedUnit.getOwner()

  if (not owningPlayer.isHumanPlayer())
    return

  if (not unitIsValidTargetStructure(constructedUnit))
    return

  let targetList = g_validHumanStructureTargets.get(owningPlayer)
  targetList.add(constructedUnit)

// ============================================================================
function onUnitDeath()
  let dyingUnit = GetDyingUnit()
  let owningPlayer = dyingUnit.getOwner()

  if (owningPlayer.isHumanPlayer() and unitIsValidTargetStructure(dyingUnit))
    let targetList = g_validHumanStructureTargets.get(owningPlayer)
    targetList.remove(dyingUnit)

  unregisterTargetedUnit(dyingUnit)

// ============================================================================
function onUnitAttacked()
  let attackedUnit = GetAttackedUnitBJ()
  let attackingUnit = GetAttacker()

  let metadata = attackingUnit.getMetadata()
  if (metadata == null)
    return
  
  let undeadTargetingComponent = metadata.getUndeadTargetingComponent()
  if (undeadTargetingComponent == null)
    return

  let targetUnit = undeadTargetingComponent.getTargetUnit()
  if (targetUnit == null)
    // Wait what? Why did he attack the non-target unit?
    // Oh well, just issue a new attack order
    undeadTargetingComponent.issueOrderTargetingPlayer()
    return

  if (targetUnit == attackedUnit)
    undeadTargetingComponent.onAttackedTargetUnit()

// ============================================================================
function populateInitialValidHumanStructureTargets()
  let cond = Condition(function filterUnitIsValidTargetStructure)
  let tempGroup = getGroup()
  for p in g_PlayingHumanPlayers
    let list = g_validHumanStructureTargets.get(p)
    tempGroup.clear()
    tempGroup.enumUnitsOfPlayer(p, cond)
    for u in tempGroup
      list.add(u)
  cond.destr()
  tempGroup.release()

// ============================================================================
function registerTargetedUnit(unit targetedUnit, UndeadTargetingComponent comp)
  HashList<UndeadTargetingComponent> attackerList
  if (g_targetedUnitToUTCMap.has(targetedUnit))
    attackerList = g_targetedUnitToUTCMap.get(targetedUnit)
  else
    attackerList = new HashList<UndeadTargetingComponent>()
    g_targetedUnitToUTCMap.put(targetedUnit, attackerList)
  attackerList.add(comp)

// ============================================================================
function unregisterTargetedUnit(unit targetedUnit, UndeadTargetingComponent comp)
  if (not g_targetedUnitToUTCMap.has(targetedUnit))
    return
  let attackerList = g_targetedUnitToUTCMap.get(targetedUnit)
  attackerList.remove(comp)

// ============================================================================
function unregisterTargetedUnit(unit targetedUnit)
  if (not g_targetedUnitToUTCMap.has(targetedUnit))
    return
  let attackerList = g_targetedUnitToUTCMap.get(targetedUnit)
  g_targetedUnitToUTCMap.remove(targetedUnit)
  for comp in attackerList
    comp.onTargetUnitDied()
  destroy attackerList

// ============================================================================
init
  g_validHumanStructureTargets = new HashMap<player, LinkedList<unit>>()

  g_issueOrderDispatcher = new Dispatcher(1024, 1024, 1024)..setMaxExecutions(50)

  for p in g_PlayingHumanPlayers
    g_validHumanStructureTargets.put(p, new LinkedList<unit>())

  g_validTargetStructureIds = new HashList<int>()
  ..add(TlsUnitIds.barricade1)
  ..add(TlsUnitIds.barricade2)
  ..add(TlsUnitIds.barricade3)
  ..add(TlsUnitIds.scoutTower1)
  ..add(TlsUnitIds.scoutTower2)
  ..add(TlsUnitIds.scoutTower3)
  ..add(TlsUnitIds.scoutTower4)
  ..add(TlsUnitIds.scoutTower5)
  ..addAll(g_woodFenceIds)
  ..addAll(g_stoneWallIds)
  ..addAll(g_metalWallIds)
  ..addAll(g_allGateIds)

  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_CONSTRUCT_FINISH, function onConstructionFinished)
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_DEATH, function onUnitDeath)
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_ATTACKED, function onUnitAttacked)

  // Populate with initial structures (for debug purposes)
  populateInitialValidHumanStructureTargets()

  doPeriodically(ATTACK_TIMER_INTERVAL) (CallbackPeriodic cb) ->
    for comp in g_activeUndeadTargetingComponents
      g_issueOrderDispatcher.invoke(() -> comp.onAttackTimer(), DispatchPriority.HIGH)