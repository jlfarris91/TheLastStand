package UndeadTargetingComponent
import UnitMetadata
import Events
import RegisterEvents
import HumanPlayers
import UnitExtensions
import ClosureTimers
import GameConstants
import Range
import TimerUtils
import GroupExtensions
import LeashComponent
import Trace
// import Vector
import Orders
import UnitIndexer
import LinkedList
import Spawning
import BuildingUndeadTarget
import GroupUtils
import TlsUnitIds
import HumanPlayerComponent
import HashList
import HashMap
import PlayerTeam

public bool UTC_ENABLED = true

constant rangeReal ATTACK_TIMER_DURATION_RANGE = rangeReal(3.0, 5.0)
constant real ATTACK_TIMER_DISTANCE_THRESHOLD = 128.0
constant real ATTACK_TIMER_DISTANCE_THRESHOLD_SQ = ATTACK_TIMER_DISTANCE_THRESHOLD * ATTACK_TIMER_DISTANCE_THRESHOLD
constant real TELEPORT_DISTANCE_THRESHOLD = SPAWN_RANGE_FAR.max
constant real TELEPORT_DISTANCE_THRESHOLD_SQ = TELEPORT_DISTANCE_THRESHOLD * TELEPORT_DISTANCE_THRESHOLD

constant real DOT_INTERVAL = 1.0
constant real DOT_PERCENT01 = 0.1

constant int MAX_DEFERRED_EXECUTION_COUNT = 4
constant real UPDATE_INTERVAL = 0.2

@configurable public bool g_enableUTCLogging = false
@configurable constant public int VALID_HUMAN_STRUCTURE_TARGETS_ATTACKER_COUNT_THRESHOLD = 3

public group g_dealDOTGroup = CreateGroup()
public group g_awaitingOrderGroup = CreateGroup()
CallbackPeriodic g_issueOrderTimer
int g_utpId = 1

/*

  This component is used to direct spawned enemies to attack a target player.
  
  It works by first attempting to target one of the player's "exterior structures"
  such as barricades, walls, gates, etc. We can reasonably assume that players
  will build at least one of these structures at some point. This works whether
  the player's base is completely closed off or has a pathable opening.
  
  We keep track of all of these exterior structures to make the operation as
  efficient as possible; issueOrderTargetingPlayer() is called at least once
  per enemy. We need to remember to update g_validTargetStructureIds with any
  new exterior structures added to the game.

  If the player has built no exterior structure then the unit will target the
  player's camp tent. If the player has no camp tent the unit will target the
  player's hero.

  Finally, if there is nothing to target so far the unit will increase it's
  acquisition range to the maximum. It should find SOMETHING to attack.

  We use the attack-move order in hopes of having the unit wander into range
  of a player's unit to attack. However, this can also mean that it can wander
  by another player's camp and attack it instead. This is fine.

*/

// ============================================================================
public class UndeadTargetingComponent extends UnitComponent
  protected player m_targetPlayer
  protected Event m_targetPlayerChangedEvent
  protected unit m_targetUnit
  protected int m_nextAttackTime
  protected bool m_preferOrganicTargets
  protected CallbackManual m_attackTimer
  protected real m_baseAttackRange
  protected LeashComponent m_leashComponent = null
  protected string m_orderFailedReason
  // protected Vector<string> m_notes
  protected int m_numberOfTimesFailedOrder = 0
  protected int m_numberOfTimesAttackTimerExpired = 0
  protected vec2 m_lastPos
  private bool m_ignoreDOTFate

  private UndeadTargetProvider m_targetProvider = null
  private _handle m_targetProviderOrganicTargetsChangedCallback = INVALID_HANDLE

  // --------------------------------------------------------------------------
  construct(IUnitMetadata owner)
    super(owner)
    m_targetPlayer = null
    m_targetPlayerChangedEvent = null
    m_targetUnit = null 
    m_nextAttackTime = 0
    m_preferOrganicTargets = false
    // m_notes = new Vector<string>()
    m_numberOfTimesFailedOrder = 0
    m_numberOfTimesAttackTimerExpired = 0
    m_baseAttackRange = MELEE_UNIT_ATTACK_RANGE.toReal()

  // --------------------------------------------------------------------------
  ondestroy
    if (m_targetPlayerChangedEvent != null)
      destroy m_targetPlayerChangedEvent
      m_targetPlayerChangedEvent = null

    // destroy m_notes

  // --------------------------------------------------------------------------
  override function onEnabled()
    super.onEnabled()
    m_baseAttackRange = getOwnerUnit().getFieldWeapon(UNIT_WEAPON_RF_ATTACK_RANGE, 0)
    m_lastPos = getOwnerUnit().getPos()
    m_leashComponent = getOwner().getOrAddLeashComponent()

  // --------------------------------------------------------------------------
  override function onDisabled()
    super.onDisabled()
    m_targetPlayer = null
    m_targetUnit = null
    m_numberOfTimesFailedOrder = 0
    m_numberOfTimesAttackTimerExpired = 0

    if (m_targetProvider != null)
      let evnt = m_targetProvider.onPreferOrganicTargetsChanged()
      if (evnt != null)
        evnt.unregister(m_targetProviderOrganicTargetsChangedCallback)
      m_targetProvider = null
      m_targetProviderOrganicTargetsChangedCallback = INVALID_HANDLE

    unregisterUnitAwaitingOrder(getOwnerUnit())
    setTargetUnit_impl(null)
    stopDOT()

    if (m_attackTimer != null)
      destroy m_attackTimer
      m_attackTimer = null

  // // --------------------------------------------------------------------------
  // function getNotes() returns Vector<string>
  //   return m_notes

  // --------------------------------------------------------------------------
  function getIsAwaitingOrder() returns bool
    return g_awaitingOrderGroup.contains(getOwnerUnit())

  // --------------------------------------------------------------------------
  function getIsInDOTGroup() returns bool
    return g_dealDOTGroup.contains(getOwnerUnit())

  // --------------------------------------------------------------------------
  function getTargetPlayerChangedEvent() returns Event
    if (m_targetPlayerChangedEvent == null)
      m_targetPlayerChangedEvent = new Event()
    return m_targetPlayerChangedEvent

  // --------------------------------------------------------------------------
  function getTargetUnit() returns unit
    return m_targetUnit

  // --------------------------------------------------------------------------
  function getTargetPlayer() returns player
    return m_targetPlayer

  // --------------------------------------------------------------------------
  function setPreferOrganicTargets(bool value)
    m_preferOrganicTargets = value

  // --------------------------------------------------------------------------
  function getPreferOrganicTargets() returns bool
    return m_preferOrganicTargets

  // --------------------------------------------------------------------------
  function setIgnoreDOTFate(bool value)
    m_ignoreDOTFate = value

  // --------------------------------------------------------------------------
  function setTargetPlayer(player targetPlayer) returns bool
    let setPlayer = setTargetPlayer_impl(targetPlayer)
    if (setPlayer)
      setTargetUnit_impl(null)
      raiseTargetPlayerChangedEvent()
      issueOrderTargetingPlayer_impl()
    return setPlayer

  // --------------------------------------------------------------------------
  function setTargetUnit(unit targetUnit) returns bool
    let targetPlayer = targetUnit != null ? targetUnit.getOwner() : null
    let setPlayer = setTargetPlayer_impl(targetPlayer)
    let setUnit = setTargetUnit_impl(targetUnit)
    if (setUnit)
      issueOrderTargetingPlayer_impl()
    return setPlayer

  // --------------------------------------------------------------------------
  function setTargetPlayer_impl(player targetPlayer) returns bool
    let ownerUnit = getOwnerUnit()

    // This should really never happen but if it does fuckit kill the unit
    if (targetPlayer == null)
      //recordNote("sTP_i", "Target player was set to null")
      nullTimer(() -> ownerUnit.kill())
      return false

    if (targetPlayer == m_targetPlayer)
      return false
    
    m_targetPlayer = targetPlayer

    return true

  // --------------------------------------------------------------------------
  // protected function recordNote(string methodName, string note)
  //   m_notes.add("{0}: [{1}] {2}".format(m_numberOfTimesFailedOrder.toString(), methodName, note))

  // --------------------------------------------------------------------------
  function issueOrderTargetingNewPlayerUnit()
    //recordNote("iOTNPU", "")
    setTargetUnit_impl(null)
    issueOrderTargetingPlayer()

  // --------------------------------------------------------------------------
  function issueOrderTargetingPlayer()

    let ownerUnit = getOwnerUnit()
    if (not ownerUnit.isAlive())
      //recordNote("iOTP", "UTC owner unit is dead")
      m_orderFailedReason = "UTC owner unit is dead"
      return

    // We're already awaiting a call to issueOrderTargetingPlayer_impl so early out
    if (getIsAwaitingOrder())
      //recordNote("iOTP", "Awaiting order")
      m_orderFailedReason = "Still awaiting order"
      return 
    
    if (getIsInDOTGroup())
      //recordNote("iOTP", "Is in dot group")
      m_orderFailedReason = "In DOT group"
      return

    registerUnitAwaitingOrder(ownerUnit)

    m_orderFailedReason = "Awaiting order"

  // --------------------------------------------------------------------------
  protected function issueOrderTargetingPlayer_impl()

    unregisterUnitAwaitingOrder(getOwnerUnit())
    // if (unregisterUnitAwaitingOrder(getOwnerUnit()))
      //recordNote("iOTP_i", "Removed from waiting group")      

    //recordNote("iOTP_i", "Order dispatched")

    restartAttackTimer()

    if (m_targetUnit == null or not m_targetUnit.isAlive())
    //{
      //recordNote("iOTP_i", "1 m_targetUnit == null")

      tryTargetClosestUnit()

      // Unable to find a target unit
      if (m_targetUnit == null or not m_targetUnit.isAlive())
      //{
        //recordNote("iOTP_i", "2 m_targetUnit == null")
        
        bool invalidTargetPlayer = m_targetPlayer == null
        if (m_targetPlayer != null)
          invalidTargetPlayer = m_targetPlayer.getMetadata().getHasLostGame()

        // The target player is null or has lost the game, so start damaging the unit over time
        if (invalidTargetPlayer and not m_ignoreDOTFate)
          //recordNote("iOTP_i", "3 m_targetUnit == null")
          startDOT()
          return
      //}
    //}

    if (m_targetUnit == null)
    //{
      m_orderFailedReason = "Target unit is null"
      m_numberOfTimesFailedOrder++

      // Unable to issue the order so clear the target unit and try again later
      clearTargetAndIssueNewOrder()
      return
    //}

    if (not m_targetUnit.isAlive())
    //{
      m_orderFailedReason = "Target unit is dead"
      m_numberOfTimesFailedOrder++

      // Unable to issue the order so clear the target unit and try again later
      clearTargetAndIssueNewOrder()
      return
    //}

    tryTeleportCloserToTargetUnit()

    if (not tryIssueOrder())
    //{
      m_orderFailedReason = "Failed to issue attack order"
      m_numberOfTimesFailedOrder++

      // if (m_numberOfTimesFailedOrder > 3)
        // m_notes.clear()
      //recordNote("iOTP_i", "Unable to issue order ({0}), trying again".format(m_numberOfTimesFailedOrder.toString()))

      // Unable to issue the order so clear the target unit and try again later
      clearTargetAndIssueNewOrder()
      return
    //}
    
    m_numberOfTimesFailedOrder = 0
    //recordNote("iOTP_i", "Success!")
    m_orderFailedReason = "Success"

  // --------------------------------------------------------------------------
  function clearTargetAndIssueNewOrder()
    setTargetUnit_impl(null)
    issueOrderTargetingPlayer()

  // --------------------------------------------------------------------------
  function tryIssueOrder() returns bool
    if (m_targetUnit == null)
      //recordNote("tIO", "m_targetUnit == null")
      m_orderFailedReason = "m_targetUnit == null"
      return false
    
    bool issuedOrder
    
    if (m_targetUnit.isBuilding())
      //recordNote("tIO", "ordering attack on " + m_targetUnit.getName())
      issuedOrder = getOwnerUnit().issueTargetOrderById(OrderIds.attack, m_targetUnit)
    else
      //recordNote("tIO", "ordering attack on " + m_targetUnit.getName())
      issuedOrder = getOwnerUnit().issueTargetOrderById(OrderIds.attack, m_targetUnit)

    if (issuedOrder == false)
      m_orderFailedReason = "Failed to issue order"
    
    return issuedOrder

  // --------------------------------------------------------------------------
  function getNearestTargettableUnit() returns unit
    let targetPlayer = getTargetPlayer()
    if (targetPlayer == null)
      //recordNote("gNTU", "getTargetPlayer() == null")
      return null
    
    let ownerUnit = getOwnerUnit()
    unit targetUnit
    
    let targetProvider = getUndeadTargetProvider(targetPlayer)
    if (targetProvider == null)
      //recordNote("gNTU", "No target provider")
      return null

    let preferOrganicTargets = getPreferOrganicTargets()

    var maxRange = REAL_MAX
    if (preferOrganicTargets)
      maxRange = ownerUnit.getFieldWeapon(UNIT_WEAPON_RF_ATTACK_RANGE, 0)

    targetUnit = targetProvider.getClosestTargetUnit(ownerUnit.getPos(), maxRange, preferOrganicTargets)
    //recordNote("gNTU", "Closest {0} unit: {1}".format((getPreferOrganicTargets() ? "organic" : "structure"), (targetUnit != null ? targetUnit.getName() : "null")))
    
    return targetUnit

  // --------------------------------------------------------------------------
  function getUndeadTargetProvider(player targetPlayer) returns UndeadTargetProvider
    let targetProvider = getUndeadTargetProviderForPlayer(targetPlayer)

    if (m_targetProvider == targetProvider)
      return targetProvider
    
    if (m_targetProvider != null)
      let e = m_targetProvider.onPreferOrganicTargetsChanged()
      if (e != null)
        e.unregister(m_targetProviderOrganicTargetsChangedCallback)
      m_targetProviderOrganicTargetsChangedCallback = INVALID_HANDLE
      m_targetProvider.release()

    m_targetProvider = targetProvider

    if (m_targetProvider != null)
      m_targetProvider.acquire()     
      m_targetProviderOrganicTargetsChangedCallback = m_targetProvider.onPreferOrganicTargetsChanged().registerDispatched(this) () ->
        clearTargetAndIssueNewOrder()

    return m_targetProvider

  // --------------------------------------------------------------------------
  private function setTargetUnit_impl(unit targetUnit) returns bool
    if (m_targetUnit == targetUnit)
      //recordNote("sTU_i", "m_targetUnit == targetUnit, m_targetUnit = " + (m_targetUnit != null ? m_targetUnit.getName() : "null"))
      return false

    if (m_targetUnit != null)
      //recordNote("sTU_i", "Target unit was not null : " + m_targetUnit.getName())
      unregisterTargetedUnit(m_targetUnit, getOwnerUnit())

    m_targetUnit = targetUnit

    if (m_leashComponent != null)
      m_leashComponent.setTargetUnit(targetUnit)

    if (m_targetUnit != null)
      //recordNote("sTU_i", "Target unit is not null : " + m_targetUnit.getName())
      registerTargetedUnit(m_targetUnit, getOwnerUnit())
      restartAttackTimer()
    // else
      //recordNote("sTU_i", "Target unit is null")

    return true

  // --------------------------------------------------------------------------
  // Returns true if a closest unit target was found
  function tryTargetClosestUnit() returns bool
    let targetPlayer = getTargetPlayer()
    if (targetPlayer == null)
      //recordNote("tTCU", "getTargetPlayer() == null")
      return false

    let targetUnit = getNearestTargettableUnit()
    if (targetUnit == null)
      //recordNote("tTCU", "getNearestTargettableUnit() == null")
      return false

    setTargetUnit_impl(targetUnit)
    return true

  // --------------------------------------------------------------------------
  function onTargetUnitNoLongerTargettable()
    issueOrderTargetingNewPlayerUnit()

  // --------------------------------------------------------------------------
  protected function onAttackedUnit(unit attackedUnit)
    m_numberOfTimesAttackTimerExpired = 0
    if (m_targetUnit == null)
      issueOrderTargetingNewPlayerUnit()
    else if (m_targetUnit == attackedUnit)
      restartAttackTimer()

  // --------------------------------------------------------------------------
  private function raiseTargetPlayerChangedEvent()
    if (m_targetPlayerChangedEvent != null)
      m_targetPlayerChangedEvent.call()

  // --------------------------------------------------------------------------
  protected static function onAttackTimer(unit utcUnit)
    let metadata = utcUnit.getMetadata()
    if (metadata == null)
      return
    let comp = metadata.getUndeadTargetingComponent()
    if (comp == null)
      return
    comp.onAttackTimer()

  // --------------------------------------------------------------------------
  protected function onAttackTimer()
    m_numberOfTimesAttackTimerExpired++
    
    if (getIsAwaitingOrder())
      //recordNote("onAttackTimer", "Awaiting order")
      return

    //recordNote("onAttackTimer", "Timer has expired")

    // Distance to target unit is way too far to walk all the way there, teleport closer.
    // We want to check this regularly so we might as well check it here.
    if (tryTeleportCloserToTargetUnit())
      //recordNote("onAttackTimer", "No teleport, issuing new order")
      issueOrderTargetingNewPlayerUnit()

    // If the unit is standing still and hasn't attacked anything since the last attack timer
    // then issue a new order, otherwise give them a chance to get to their target
    else if (getOwnerUnit().getPos().distanceToSq(m_lastPos) < ATTACK_TIMER_DISTANCE_THRESHOLD_SQ)
      //recordNote("onAttackTimer", "Standing still, issuing new order")
      issueOrderTargetingNewPlayerUnit()
    
    // Otherwise, restart the attack timer to check again later
    else
      restartAttackTimer()

    m_lastPos = getOwnerUnit().getPos()

  // --------------------------------------------------------------------------
  private function tryTeleportCloserToTargetUnit() returns bool
    return m_leashComponent != null and m_leashComponent.getEnabled() and m_leashComponent.tryTeleportCloserToTargetUnit()

  // --------------------------------------------------------------------------
  protected function restartAttackTimer()
    //recordNote("rAT", "restarting attack timer")
    if (m_attackTimer == null)
      m_attackTimer = getTimer().doManual(ATTACK_TIMER_DURATION_RANGE.getRandom(), true) -> 
        onAttackTimer()
    else
      m_attackTimer.restart(ATTACK_TIMER_DURATION_RANGE.getRandom())

  // --------------------------------------------------------------------------
  private function startDOT()
    if (not getIsInDOTGroup() and not getOwnerUnit().getOwner().isHumanPlayer())
      //recordNote("startDOT", "Adding UTC owner unit to dot group")
      g_dealDOTGroup.addUnit(getOwnerUnit())

  // --------------------------------------------------------------------------
  private function stopDOT()
    if (getIsInDOTGroup())
      //recordNote("startDOT", "Removing UTC owner unit from dot group")
      g_dealDOTGroup.removeUnit(getOwnerUnit())

  // --------------------------------------------------------------------------
  function getOrderFailedReason() returns string
    return m_orderFailedReason

  // --------------------------------------------------------------------------
  function getNumberOfTimesFailedOrder() returns int
    return m_numberOfTimesFailedOrder

  // --------------------------------------------------------------------------
  function getNumberOfTimesAttackTimerExpired() returns int
    return m_numberOfTimesAttackTimerExpired

  // --------------------------------------------------------------------------
  function getDistanceMoved() returns real
    return getOwnerUnit().getPos().distanceTo(m_lastPos)

// ============================================================================
public function IUnitMetadata.getUndeadTargetingComponent() returns UndeadTargetingComponent
  return this.getComponent(UndeadTargetingComponent.typeId) castTo UndeadTargetingComponent

// ============================================================================
public function IUnitMetadata.getOrAddUndeadTargetingComponent() returns UndeadTargetingComponent
  var component = this.getUndeadTargetingComponent()
  if (component == null)
    component = this.addComponent(new UndeadTargetingComponent(this)) castTo UndeadTargetingComponent
  return component

// ============================================================================
public function unit.getUndeadTargetingComponent() returns UndeadTargetingComponent
  let metadata = this.getMetadata()
  return metadata != null ? metadata.getUndeadTargetingComponent() : null

// ============================================================================
function onUnitAttacked()
  let attackingUnit = GetAttacker()

  let metadata = attackingUnit.getMetadata()
  if (metadata == null)
    return
  
  let undeadTargetingComponent = metadata.getUndeadTargetingComponent()
  if (undeadTargetingComponent == null)
    return
  
  undeadTargetingComponent.onAttackedUnit(GetAttackedUnitBJ())

group g_tempGroup = CreateGroup()

// ============================================================================
function applyDOT()

  if (not UTC_ENABLED)
    return

  Trace.trace("UTC.applyDOT")

  for _unit in g_dealDOTGroup
    if (_unit != null and _unit.isAlive())
      _unit.subHP(_unit.getMaxHP() * DOT_PERCENT01)

// ============================================================================
function registerUnitAwaitingOrder(unit utcUnit) returns bool
  let didNotContainUnit = not g_awaitingOrderGroup.contains(utcUnit)
  g_awaitingOrderGroup.addUnit(utcUnit)
  return didNotContainUnit and g_awaitingOrderGroup.contains(utcUnit)

// ============================================================================
function unregisterUnitAwaitingOrder(unit utcUnit) returns bool
  let didContainUnit = g_awaitingOrderGroup.contains(utcUnit)
  g_awaitingOrderGroup.removeUnit(utcUnit)
  return didContainUnit and not g_awaitingOrderGroup.contains(utcUnit)

public int g_numberOfTimesIssueOrdersStartCalled = 0
public int g_numberOfTimesIssueOrdersEndCalled = 0
public int g_numberOfOrdersIssued = 0

// ============================================================================
function issueOrders()

  if (not UTC_ENABLED)
    return

  Trace.trace("UTC.issueOrders")

  let maxUpdateExecutionCount = MAX_DEFERRED_EXECUTION_COUNT
  var executionCount = 0
 
  g_numberOfTimesIssueOrdersStartCalled++

  // Occasionally we get a unit that has been removed from the game but not from
  // our g_awaitingOrderGroup group. In which case g_awaitingOrderGroup.isEmpty()
  // was returning null since it uses FirstOfGroup() which will return null when
  // one of those ghost units is the first unit in the group. So, we need use
  // refresh() here to get rid of any ghost units.
  if (g_awaitingOrderGroup.isEmpty() and g_awaitingOrderGroup.size() > 0)
    g_awaitingOrderGroup.refresh()

  while (not g_awaitingOrderGroup.isEmpty() and executionCount < maxUpdateExecutionCount)
  //{
    let utcUnit = g_awaitingOrderGroup.getUnitAt(GetRandomInt(0, g_awaitingOrderGroup.size() - 1))
    g_awaitingOrderGroup.removeUnit(utcUnit)
    if (utcUnit != null)
      if (not utcUnit.isAlive())
        if (g_enableUTCLogging)
          Log.debug("UTC", "issueOrders", "", "Unit is dead")
      else
        let metadata = utcUnit.getMetadata()
        if (metadata == null)
          if (g_enableUTCLogging)
            Log.debug("UTC", "issueOrders", "", "Metadata is null")
        else
          let comp = metadata.getUndeadTargetingComponent()
          if (comp == null or not comp.getEnabled())
            if (g_enableUTCLogging)
              Log.debug("UTC", "issueOrders", "", "UTC is null or disabled")
          else
            comp.issueOrderTargetingPlayer_impl()
            executionCount++
            g_numberOfOrdersIssued++
    //}

  Trace.trace("UTC.issueOrders.execute", executionCount)

  g_numberOfTimesIssueOrdersEndCalled++

public bool UTS_ENABLED = true

constant real PROCESS_UPDATES_INTERVAL = 1.0
constant real TARGET_STRUCTURE_SCORE_RANGE = 512.0
constant real ATTACK_RANGE_SCALAR = 1.0
constant int UNDEAD_TARGET_PROVIDER_PRI_COUNT = 4

public enum UndeadTargetProviderPriority
  Organic
  StructureHigh
  StructureLow
  StructureNone
  Unknown

// ============================================================================
public function UndeadTargetProviderPriority.toString() returns string
  switch this
    case Organic
      return "Organic"
    case StructureHigh
      return "High"
    case StructureLow
      return "Low"
    case StructureNone
      return "None"
    default
      return "unknown"

UndeadTargetProvider array g_playerData
HashMap<PlayerTeam, UndeadTargetProvider> g_utpByTeam = new HashMap<PlayerTeam, UndeadTargetProvider>()
LinkedList<UndeadTargetProvider> g_undeadTargetProviders = new LinkedList<UndeadTargetProvider>()
int g_playerDataUpdateIndex = -1
group array g_targetedUnitToUTCMap
// int array g_targetUnitScore
// texttag array g_targetUnitScoreTags
LinkedList<UndeadTargetProvider> g_forceTargetCollections = new LinkedList<UndeadTargetProvider>()
CallbackPeriodic g_processUpdates
group g_temp = CreateGroup()
HashList<int> g_targetPriNone = new HashList<int>()
HashList<int> g_targetPriLow = new HashList<int>()

// group g_targetUnitScoreFilterGroup
// boolexpr g_targetUnitScoreFilter = Condition(function isUnitStructureInTargetCollection)

// ============================================================================
public function getUndeadTargetProviderForPlayer(player p) returns UndeadTargetProvider
  return g_playerData[p.getId()]

// ============================================================================
public function getNumberOfRegisteredAttackers(unit target) returns int
  let attackers = g_targetedUnitToUTCMap[target.getIndex()]
  return attackers == null ? -1 : attackers.size()

// ============================================================================
public class UndeadTargetProvider extends TargetProvider
  private int m_id
  private PlayerTeam m_playerTeam = null
  private force m_players = CreateForce()
  private group m_structureTargets = CreateGroup()
  private group m_organicTargets = CreateGroup()
  private group array[UNDEAD_TARGET_PROVIDER_PRI_COUNT] m_targetsByPriority
  private bool m_preferOrganicTargets = false
  private Event m_preferOrganicTargetsChanged = null

  // --------------------------------------------------------------------------
  construct(PlayerTeam playerTeam)

    m_playerTeam = playerTeam

    m_id = g_utpId
    g_utpId++

    Log.info("Created UTP {0}".format(m_id.toString()))

    g_undeadTargetProviders.add(this)

    registerHumanForceTargetCollection(this)

    for i = 0 to UNDEAD_TARGET_PROVIDER_PRI_COUNT - 1
      m_targetsByPriority[i] = CreateGroup()

  // --------------------------------------------------------------------------
  ondestroy
    g_undeadTargetProviders.remove(this)

    unregisterHumanForceTargetCollection(this)

    if (m_preferOrganicTargetsChanged != null)
      destroy m_preferOrganicTargetsChanged
      m_preferOrganicTargetsChanged = null

    m_players.destr()
    m_structureTargets.destr()
    m_organicTargets.destr()

    for i = 0 to UNDEAD_TARGET_PROVIDER_PRI_COUNT - 1
      m_targetsByPriority[i].destr()
      m_targetsByPriority[i] = null

    Log.info("Destroyed UTP {0}".format(m_id.toString()))

  // --------------------------------------------------------------------------
  function getId() returns int
    return m_id

  // --------------------------------------------------------------------------
  function addPlayer(player p)
    m_players.addPlayer(p)
    g_playerData[p.getId()] = this

    Log.info("Added player {0} to UTP {1}".format(p.getName(), m_id.toString()))

    updatePreferOrganicTargets()

    addPlayerUnitsToGroups(p)

  // --------------------------------------------------------------------------
  function removePlayer(player p)
    m_players.removePlayer(p)
    g_playerData[p.getId()] = null

    Log.info("Removed player {0} from UTP {1}".format(p.getName(), m_id.toString()))

    updatePreferOrganicTargets()

    removePlayerUnitsFromGroups(p)

    if (m_players.count() == 0)
      release()

  // --------------------------------------------------------------------------
  function getPlayers() returns force
    return m_players

  // --------------------------------------------------------------------------
  function getStructureTargets() returns group
    return m_structureTargets

  // --------------------------------------------------------------------------
  function getOrganicTargets() returns group
    return m_organicTargets

  // --------------------------------------------------------------------------
  function getAliveOrganicTargets() returns group
    return m_targetsByPriority[UndeadTargetProviderPriority.Organic castTo int]

  // --------------------------------------------------------------------------
  function getAttackPriority(unit u) returns UndeadTargetProviderPriority
    for i = 0 to UNDEAD_TARGET_PROVIDER_PRI_COUNT - 1
      if (m_targetsByPriority[i].contains(u))
        return i castTo UndeadTargetProviderPriority
    return UndeadTargetProviderPriority.Unknown

  // --------------------------------------------------------------------------
  function getAttackerCount(unit u) returns int
    let attackerGroup = g_targetedUnitToUTCMap[u.getIndex()]
    return attackerGroup != null ? attackerGroup.size() : 0

  // --------------------------------------------------------------------------
  function setPreferOrganicTargets(bool value)
    if (m_preferOrganicTargets != value)
      m_preferOrganicTargets = value
      preferOrganicTargetsChanged()

  // --------------------------------------------------------------------------
  function getPreferOrganicTargets() returns bool
    return m_preferOrganicTargets

  // --------------------------------------------------------------------------
  function onPreferOrganicTargetsChanged() returns IEvent
    if (m_preferOrganicTargetsChanged == null)
      m_preferOrganicTargetsChanged = new Event()
    return m_preferOrganicTargetsChanged

  // --------------------------------------------------------------------------
  private function addPlayerUnitsToGroups(player p)
    g_temp.enumUnitsOfPlayer(p, null)
    for u in g_temp
      registerPlayerUnit(u)

  // --------------------------------------------------------------------------
  private function removePlayerUnitsFromGroups(player p)
    g_temp.enumUnitsOfPlayer(p, null)
    for u in g_temp
      unregisterPlayerUnit(u)

  // ----------------------------------------------------------------------------
  override function getTargetUnit(SpawnContext context) returns unit
    return getRandomTargetUnit(false)

  // --------------------------------------------------------------------------
  function getRandomTargetUnit(bool preferOrganic) returns unit

    let organicTargets = getAliveOrganicTargets()

    if ((preferOrganic or m_preferOrganicTargets) and organicTargets != null and not organicTargets.isEmpty())
      return organicTargets.getRandomUnit()

    for i = 0 to UNDEAD_TARGET_PROVIDER_PRI_COUNT - 1
      if (not m_targetsByPriority[i].isEmpty())
        return m_targetsByPriority[i].getRandomUnit()
    
    return null

  // --------------------------------------------------------------------------
  function getClosestTargetUnit(vec2 pos, bool preferOrganic) returns unit
    return getClosestTargetUnit(pos, REAL_MAX, preferOrganic)

  // --------------------------------------------------------------------------
  function getClosestTargetUnit(vec2 pos, real maxRange, bool preferOrganic) returns unit

    let organicTargets = getAliveOrganicTargets()

    if ((preferOrganic or m_preferOrganicTargets) and organicTargets != null and not organicTargets.isEmpty())
      let target = organicTargets.getClosestUnit(pos, maxRange)
      if (target != null)
        return target

    for i = 0 to UNDEAD_TARGET_PROVIDER_PRI_COUNT - 1
      if (not m_targetsByPriority[i].isEmpty())
        let target = m_targetsByPriority[i].getClosestUnit(pos)
        if (target != null)
          return target
    
    return null

  // --------------------------------------------------------------------------
  function clear()

    for i = 0 to UNDEAD_TARGET_PROVIDER_PRI_COUNT - 1
      m_targetsByPriority[i].clear()
    
    for targetStructure in m_structureTargets
      unregisterTargetedUnit(targetStructure)

    m_structureTargets.clear()
    m_organicTargets.clear()

    m_preferOrganicTargets = false

  // --------------------------------------------------------------------------
  function registerPlayerUnit(unit _unit)

    if (_unit.isBuilding())
      if (unitIsValidTargetStructure(_unit) and not m_structureTargets.contains(_unit))
        m_structureTargets.addUnit(_unit)
        sortStructureTargetUnit(_unit)
        updateBUTAttackEnabled(_unit, getBUTAttacksEnabled())
        
        // enumNearbyStructures(_unit.getPos())
        // addScore(1)
        // g_targetUnitScore[_unit.getIndex()] = g_temp.size()
    else
      if (unitIsValidTargetNonStructure(_unit))
        m_organicTargets.addUnit(_unit)

  // --------------------------------------------------------------------------
  function unregisterPlayerUnit(unit _unit)

    for i = 0 to UNDEAD_TARGET_PROVIDER_PRI_COUNT - 1
      m_targetsByPriority[i].removeUnit(_unit)

    m_structureTargets.removeUnit(_unit)
    m_organicTargets.removeUnit(_unit)

  // --------------------------------------------------------------------------
  protected function sortTargetUnits()
    // Log.debug(m_player.getId().toString() + " Sorting structure targets")

    m_targetsByPriority[UndeadTargetProviderPriority.StructureHigh castTo int].clear()
    m_targetsByPriority[UndeadTargetProviderPriority.StructureLow castTo int].clear()

    for structureTarget in m_structureTargets
      sortStructureTargetUnit(structureTarget)

    let aliveTargets = getAliveOrganicTargets()
    aliveTargets.clear()

    for organicTarget in m_organicTargets
      if (organicTarget.isAlive())
        aliveTargets.addUnit(organicTarget)

  // --------------------------------------------------------------------------
  private function sortStructureTargetUnit(unit structureTarget)

    var priority = UndeadTargetProviderPriority.StructureHigh

    // Force into None
    if (g_targetPriNone.has(structureTarget.getTypeId()))
      priority = UndeadTargetProviderPriority.StructureNone

    // Force into Low
    else if (g_targetPriLow.has(structureTarget.getTypeId()))
      priority = UndeadTargetProviderPriority.StructureLow

    // Balance between High and Low based on number of current attackers
    else
      let attackerGroup = g_targetedUnitToUTCMap[structureTarget.getIndex()]
      if (attackerGroup != null and attackerGroup.size() > VALID_HUMAN_STRUCTURE_TARGETS_ATTACKER_COUNT_THRESHOLD)
        priority = UndeadTargetProviderPriority.StructureLow

    m_targetsByPriority[priority castTo int].addUnit(structureTarget)

  // --------------------------------------------------------------------------
  private function preferOrganicTargetsChanged()
    updateAllBUTAttacksEnabled(getBUTAttacksEnabled())
    if (m_preferOrganicTargetsChanged != null)
      m_preferOrganicTargetsChanged.call()

  // --------------------------------------------------------------------------
  private function updateAllBUTAttacksEnabled(bool enabled)
    for target in m_structureTargets
      updateBUTAttackEnabled(target, enabled)

  // --------------------------------------------------------------------------
  private function updateBUTAttackEnabled(unit target, bool enabled)
    if (target.isBuildingUndeadTargetWithSpecialDamage())
      target.setFieldWeapon(UNIT_WEAPON_BF_ATTACKS_ENABLED, 0, enabled)

  // --------------------------------------------------------------------------
  private function getBUTAttacksEnabled() returns bool
    return not m_preferOrganicTargets

  // --------------------------------------------------------------------------
  protected function updatePreferOrganicTargets()
    var preferOrganicTargets = false
    for p in m_players
      let comp = p.getMetadata().getHumanPlayerComponent()
      preferOrganicTargets = preferOrganicTargets or comp.getCanPathToHeadquartersOrHero()
    setPreferOrganicTargets(preferOrganicTargets)

  // --------------------------------------------------------------------------
  // private function enumNearbyStructures(vec2 pos)
  //   g_targetUnitScoreFilterGroup = m_structureTargets
  //   g_temp.enumUnitsInRange(pos, TARGET_STRUCTURE_SCORE_RANGE, g_targetUnitScoreFilter)
  //   g_targetUnitScoreFilterGroup = null

  // --------------------------------------------------------------------------
  // private function addScore(int value)
  //   for structureTarget in g_temp
  //     g_targetUnitScore[structureTarget.getIndex()] += value
  //   onScoreChanged(g_temp)

  // --------------------------------------------------------------------------
  // private function onScoreChanged(group structureTargets)
  //   for structureTarget in structureTargets
  //     updateScoreTag(structureTarget)
      
  // --------------------------------------------------------------------------
  // private function updateScoreTag(unit u)
    // var tag = g_targetUnitScoreTags[u.getIndex()]
    // let score = g_targetUnitScore[u.getIndex()].toString()
    // if (tag == null)
    //   tag = createTTEx(u.getPos().withZ(64.0), score, 10.0)
    //   g_targetUnitScoreTags[u.getIndex()] = tag
    // tag.setText(score, 10.0)      

// ============================================================================
// function isUnitStructureInTargetCollection() returns bool
//   if (g_targetUnitScoreFilterGroup == null)
//     return false
//   return g_targetUnitScoreFilterGroup.contains(GetFilterUnit())

// ============================================================================
function unitIsValidTargetStructure(unit u) returns bool
  return u.isAlive() and u.isBuilding() and u.isBuildingUndeadTarget()

// ============================================================================
function filterUnitIsValidTargetStructure() returns bool
  return unitIsValidTargetStructure(GetFilterUnit())

// ============================================================================
function unitIsValidTargetNonStructure(unit u) returns bool
  return u.isAlive() and not u.isInvulnerable() and (u.isHeadquarters() or not u.isBuilding())

// ============================================================================
function filterUnitIsValidTargetNonStructure() returns bool
  return unitIsValidTargetNonStructure(GetFilterUnit())  

// ============================================================================
public function registerTargetedUnit(unit targetedUnit, unit targetingUnit)
  let index = targetedUnit.getIndex()
  var attackerGroup = g_targetedUnitToUTCMap[index]
  if (attackerGroup == null)
    attackerGroup = getGroup()
    g_targetedUnitToUTCMap[index] = attackerGroup
  attackerGroup.addUnit(targetingUnit)

// ============================================================================
public function unregisterTargetedUnit(unit targetedUnit, unit targetingUnit)
  let index = targetedUnit.getIndex()
  let attackerGroup = g_targetedUnitToUTCMap[index]
  attackerGroup.removeUnit(targetingUnit)
  if (attackerGroup.isEmpty())
    attackerGroup.release()
  g_targetedUnitToUTCMap[index] = null

// ============================================================================
public function unregisterTargetedUnit(unit targetedUnit)
  let index = targetedUnit.getIndex()
  let attackerGroup = g_targetedUnitToUTCMap[index]
  g_targetedUnitToUTCMap[index] = null
  if (attackerGroup != null)
    for utc in attackerGroup
      let comp = utc.getUndeadTargetingComponent()
      if (comp != null)
        comp.onTargetUnitNoLongerTargettable()
    attackerGroup.release()

// ============================================================================
function clearLeavingLosingPlayerData(player leavingLosingPlayer)
  let playerData = g_playerData[leavingLosingPlayer.getId()]
  if (playerData != null)
    playerData.removePlayer(leavingLosingPlayer)

// ============================================================================
function processUpdates()

  if (not UTS_ENABLED)
    return

  Trace.trace("UTS.processUpdates")
  for provider in g_forceTargetCollections
    provider.sortTargetUnits()

// ============================================================================
function registerHumanForceTargetCollection(UndeadTargetProvider value)
  g_forceTargetCollections.add(value)
  if (g_forceTargetCollections.size() == 1)
    g_processUpdates = doPeriodically(PROCESS_UPDATES_INTERVAL, cb -> processUpdates())

// ============================================================================
function unregisterHumanForceTargetCollection(UndeadTargetProvider value)
  if (not g_forceTargetCollections.remove(value))
    return
  if (g_forceTargetCollections.isEmpty() and g_processUpdates != null)
    destroy g_processUpdates
    g_processUpdates = null

// ============================================================================
function getPlayerUTP(player p) returns UndeadTargetProvider
  return g_playerData[p.getId()]

// ============================================================================
function getTeamUTP(PlayerTeam team) returns UndeadTargetProvider
  return g_utpByTeam.get(team)

// ============================================================================
function getOrCreateUTPForTeam(PlayerTeam team) returns UndeadTargetProvider
  var utp = getTeamUTP(team)
  if (utp == null)
    utp = new UndeadTargetProvider(team)..acquire()
    g_utpByTeam.put(team, utp)
  return utp

// ============================================================================
function onUnitDeindexed()
  let indexingUnit = getIndexingUnit()
  let owningPlayer = indexingUnit.getOwner()
  let playerData = getPlayerUTP(owningPlayer)
  if (playerData != null)
    playerData.unregisterPlayerUnit(indexingUnit)

// ============================================================================
function onPlayerLeave()
  clearLeavingLosingPlayerData(GetTriggerPlayer())

// ============================================================================
function onHumanPlayerComponentPropertyChanged(HumanPlayerComponent sender, string propertyName)
  
  if (propertyName == HumanPlayerComponent.Properties.canPathToHeadquartersOrHero)
    let utp = getUndeadTargetProviderForPlayer(sender.getOwnerPlayer())
    if (utp != null)
      utp.updatePreferOrganicTargets()

// ============================================================================
init

  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_ATTACKED, function onUnitAttacked)

  doPeriodically(UPDATE_INTERVAL, (CallbackPeriodic cb) -> issueOrders())
  doPeriodically(DOT_INTERVAL, (CallbackPeriodic cb) -> applyDOT())

  onUnitDeindex(() -> onUnitDeindexed())

  onPlayerLost(() -> clearLeavingLosingPlayerData(getLosingPlayer()))
  registerPlayerEvent(EVENT_PLAYER_LEAVE, function onPlayerLeave)

  for p in g_PlayingHumanPlayers
  //{
    // Listen for changes to the 
    let comp = p.getMetadata().getHumanPlayerComponent()
    if (comp != null)
      comp.onPropertyChanged().register((s,a) -> onHumanPlayerComponentPropertyChanged(s,a))
  //}

  // Create an initial UTP for each team
  for team in PlayerTeam.getTeams()
    let utp = getOrCreateUTPForTeam(team)
    if (utp != null)
      for p in team.getPlayers()
        utp.addPlayer(p)

  PlayerTeam.onTeamPlayerAdded().register() (PlayerTeam team, player p) ->
    let utp = getOrCreateUTPForTeam(team)
    if (utp != null)
      utp.addPlayer(p)

  PlayerTeam.onTeamPlayerRemoved().register() (PlayerTeam team, player p) ->
    let utp = getTeamUTP(team)
    if (utp != null)
      utp.removePlayer(p)

  g_targetPriNone.add(TlsUnitIds.campFire)
  g_targetPriNone.add(TlsUnitIds.campFire2)
  g_targetPriNone.add(TlsUnitIds.campFireBuild)
  g_targetPriNone.add(TlsUnitIds.lampPowered)
  g_targetPriNone.add(TlsUnitIds.lampUnpowered)
  g_targetPriNone.add(TlsUnitIds.postLantern)
  g_targetPriNone.add(TlsUnitIds.chest)
  g_targetPriNone.add(TlsUnitIds.foundationLarge)
  g_targetPriNone.add(TlsUnitIds.foundationMedium)
  g_targetPriNone.add(TlsUnitIds.foundationTower)

  g_targetPriLow.add(TlsUnitIds.headquarters1)
  g_targetPriLow.add(TlsUnitIds.headquarters2)
  g_targetPriLow.add(TlsUnitIds.headquarters3)
  g_targetPriLow.add(TlsUnitIds.headquarters4)
  g_targetPriLow.add(TlsUnitIds.headquarters5)
  g_targetPriLow.add(TlsUnitIds.shelter1)
  g_targetPriLow.add(TlsUnitIds.shelter2)
  g_targetPriLow.add(TlsUnitIds.shelter3)
  g_targetPriLow.add(TlsUnitIds.workbench)
  g_targetPriLow.add(TlsUnitIds.workshop)
  g_targetPriLow.add(TlsUnitIds.blacksmith)
  g_targetPriLow.add(TlsUnitIds.armory)
  g_targetPriLow.add(TlsUnitIds.chapel)
  g_targetPriLow.add(TlsUnitIds.forge)
  g_targetPriLow.add(TlsUnitIds.lumberMill)
  g_targetPriLow.add(TlsUnitIds.munitionsDepot)
  g_targetPriLow.add(TlsUnitIds.spearmansTent)
  g_targetPriLow.add(TlsUnitIds.tannery)