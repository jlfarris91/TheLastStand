package UndeadTargetingComponent
import UnitComponent
import HumanPlayerMetadata
import Events
import LinkedList
import RegisterEvents
import HashMap
import HumanPlayers
import TlsUnitIds
import HashList
import GroupUtils
import Unit_WoodFence
import Unit_StoneWall
import Unit_GateCommon
import Unit_MetalWall
import Orders
import TargetUtility
import UnitExtensions
import ClosureTimers
import RealTime
import Math
import Host
import GameConstants
import UnitRecycler
import Unit_BrickWall
import Vector
import TLSFrame
import ColorUtility

constant real ATTACK_TIMER_INTERVAL = 1.0
constant real ATTACK_TIMER_DURATION = 5.0

constant real DOT_INTERVAL = 1.0
constant real DOT_PERCENT01 = 0.1

constant int MAX_DEFERRED_EXECUTION_COUNT = 10
constant real UPDATE_INTERVAL = 0.5

constant bool ENABLED_DEBUG = false

HashMap<player, LinkedList<unit>> g_validHumanStructureTargets
HashList<int> g_validTargetStructureIds
conditionfunc g_filterUnitIsValidTargetStructure = Condition(function filterUnitIsValidTargetStructure)
conditionfunc g_filterUnitIsValidTargetNonStructure = Condition(function filterUnitIsValidTargetNonStructure)
IterableMap<unit, HashList<UndeadTargetingComponent>> g_targetedUnitToUTCMap = new IterableMap<unit, HashList<UndeadTargetingComponent>>()
group array g_activeUTCUnitsByTargetPlayer
group g_dealDOTGroup = CreateGroup()
int g_updateActiveUTCGroupIndex = 0
UTCDebugger g_utcDebugger

group g_awaitingOrderGroup = CreateGroup()
CallbackPeriodic g_awaitingOrderGroupTimer

/*

  This component is used to direct spawned enemies to attack a target player.
  
  It works by first attempting to target one of the player's "exterior structures"
  such as barricades, walls, gates, etc. We can reasonably assume that players
  will build at least one of these structures at some point. This works whether
  the player's base is completely closed off or has a pathable opening.
  
  We keep track of all of these exterior structures to make the operation as
  efficient as possible; issueOrderTargetingPlayer() is called at least once
  per enemy. We need to remember to update g_validTargetStructureIds with any
  new exterior structures added to the game.

  If the player has built no exterior structure then the unit will target the
  player's camp tent. If the player has no camp tent the unit will target the
  player's hero.

  Finally, if there is nothing to target so far the unit will increase it's
  acquisition range to the maximum. It should find SOMETHING to attack.

  We use the attack-move order in hopes of having the unit wander into range
  of a player's unit to attack. However, this can also mean that it can wander
  by another player's camp and attack it instead. This is fine.

*/

// ============================================================================
public class UndeadTargetingComponent extends UnitComponent
  protected player m_targetPlayer
  protected Event m_targetPlayerChangedEvent
  protected unit m_targetUnit
  protected int m_attackTime
  protected bool m_awaitingOrder
  protected bool m_preferOrganicTargets
  protected Vector<string> m_notes

  // --------------------------------------------------------------------------
  construct(IUnitMetadata owner)
    super(owner)
    m_targetPlayer = null
    m_targetPlayerChangedEvent = null
    m_targetUnit = null 
    m_attackTime = 0
    m_awaitingOrder = false
    m_preferOrganicTargets = false
    m_notes = new Vector<string>()

  // --------------------------------------------------------------------------
  ondestroy
    if (m_targetPlayerChangedEvent != null)
      destroy m_targetPlayerChangedEvent
      m_targetPlayerChangedEvent = null

    destroy m_notes

    // Make sure to remove this component
    for key in g_targetedUnitToUTCMap
      let list = g_targetedUnitToUTCMap.get(key)
      if (list != null)
        list.remove(this)

  // --------------------------------------------------------------------------
  override function getTypeId() returns int
    return UndeadTargetingComponent.typeId

  // --------------------------------------------------------------------------
  override function onEnabled()
    super.onEnabled()
    if (m_targetPlayer != null)
      registerActiveUTC(m_targetPlayer, getOwnerUnit())
    m_awaitingOrder = false
    m_targetPlayer = null
    m_targetUnit = null
    restartAttackTimer()

  // --------------------------------------------------------------------------
  override function onDisabled()
    super.onDisabled()
    unregisterUnitAwaitingOrder(getOwnerUnit())
    if (m_targetPlayer != null)
      unregisterActiveUTC(m_targetPlayer, getOwnerUnit())
    setTargetUnit_impl(null)
    stopDOT()

  // --------------------------------------------------------------------------
  override function onUnitChanged(unit oldUnit, unit _newUnit)
    super.onUnitChanged(oldUnit, _newUnit)

    if (oldUnit != null)
      g_dealDOTGroup.removeUnit(oldUnit)

  // --------------------------------------------------------------------------
  function getIsInDOTGroup() returns bool
    return g_dealDOTGroup.contains(getOwnerUnit())

  // --------------------------------------------------------------------------
  function getTargetPlayerChangedEvent() returns Event
    if (m_targetPlayerChangedEvent == null)
      m_targetPlayerChangedEvent = new Event()
    return m_targetPlayerChangedEvent

  // --------------------------------------------------------------------------
  function getTargetUnit() returns unit
    return m_targetUnit

  // --------------------------------------------------------------------------
  function getTargetPlayer() returns player
    return m_targetPlayer

  // --------------------------------------------------------------------------
  function setPreferOrganicTargets(bool value)
    m_preferOrganicTargets = value

  // --------------------------------------------------------------------------
  function getPreferOrganicTargets() returns bool
    return m_preferOrganicTargets

  // --------------------------------------------------------------------------
  function shouldTargetOrganicUnits() returns bool
    if (m_preferOrganicTargets)
      return true
    if (m_targetPlayer == null)
      return false
    let metadata = m_targetPlayer.getHumanMetadata()
    if (metadata == null)
      return false
    return metadata.getCanPathToHeadquartersOrHero()

  // --------------------------------------------------------------------------
  function setTargetPlayer(player targetPlayer) returns bool
    let setPlayer = setTargetPlayer_impl(targetPlayer)
    if (setPlayer)
      setTargetUnit_impl(null)
      raiseTargetPlayerChangedEvent()
      issueOrderTargetingPlayer()
    return setPlayer

  // --------------------------------------------------------------------------
  function setTargetUnit(unit targetUnit) returns bool
    let targetPlayer = targetUnit != null ? targetUnit.getOwner() : null
    let setPlayer = setTargetPlayer_impl(targetPlayer)
    let setUnit = setTargetUnit_impl(targetUnit)
    if (setUnit)
      issueOrderTargetingPlayer()
    return setPlayer

  // --------------------------------------------------------------------------
  function setTargetPlayer_impl(player targetPlayer) returns bool
    let ownerUnit = getOwnerUnit()

    // This should really never happen but if it does fuckit kill the unit
    if (targetPlayer == null)
      Log.debug("Target player was set to null")
      nullTimer(() -> ownerUnit.kill())
      return false

    if (targetPlayer == m_targetPlayer)
      return false
    
    if (m_targetPlayer != null and ownerUnit != null)
      unregisterActiveUTC(m_targetPlayer, ownerUnit)
    
    m_targetPlayer = targetPlayer
    
    if (m_targetPlayer != null and ownerUnit != null and getEnabled())
      registerActiveUTC(m_targetPlayer, ownerUnit)

    return true

  // --------------------------------------------------------------------------
  private function recordNote(string methodName, string note)
    m_notes.add("[{0}] {1}".format(methodName, note))

  // --------------------------------------------------------------------------
  function issueOrderTargetingPlayer()

    m_notes.clear()

    let ownerUnit = getOwnerUnit()
    if (not ownerUnit.isAlive())
      recordNote("issueOrderTargetingPlayer", "UTC owner unit is dead")
      return

    // We're already awaiting a call to issueOrderTargetingPlayer_impl so early out
    if (m_awaitingOrder)
      recordNote("issueOrderTargetingPlayer", "Awaiting order")
      return 
    
    if (getIsInDOTGroup())
      recordNote("issueOrderTargetingPlayer", "Is in dot group")
      return

    m_awaitingOrder = true

    registerUnitAwaitingOrder(ownerUnit)

    recordNote("issueOrderTargetingPlayer", "Dispatching order (m_awaitingOrder == true)")

  // --------------------------------------------------------------------------
  protected function issueOrderTargetingPlayer_impl()

    m_awaitingOrder = false
    recordNote("issueOrderTargetingPlayer_impl", "Order dispatched (m_awaitingOrder == false)")

    if (m_targetUnit == null)
      recordNote("issueOrderTargetingPlayer_impl", "1 m_targetUnit == null")

      // 1. Try targetting the nearest structure
      // 2. Try targetting the nearest non-structure
      tryTargetClosestUnit()

      // Unable to find a target unit
      if (m_targetUnit == null)
        recordNote("issueOrderTargetingPlayer_impl", "2 m_targetUnit == targetUnit")

        // 3. Try attack-moving to the target player's camp center (the HQ tent or the hero)
        if (tryTargetCampCenter())
          recordNote("issueOrderTargetingPlayer_impl", "Could not find target unit, attack-moving to camp center")
        
        // 4. The target player is either null or considered dead, so start damaging the unit over time
        if (m_targetUnit == null)
          recordNote("issueOrderTargetingPlayer_impl", "3 m_targetUnit == targetUnit")
          startDOT()
          return

    restartAttackTimer()
    recordNote("issueOrderTargetingPlayer_impl", "m_attackTime : " + m_attackTime.toString())

    if (not tryIssueOrder())
      recordNote("issueOrderTargetingPlayer_impl", "Unable to issue order, trying again")
      // Unable to issue the order so clear the target unit and try again later
      setTargetUnit_impl(null)
      issueOrderTargetingPlayer()

  // --------------------------------------------------------------------------
  function tryIssueOrder() returns bool
    if (m_targetUnit == null)
      recordNote("tryIssueOrder", "m_targetUnit == null")
      return false
    if (unitIsValidTargetStructure(m_targetUnit))
      return getOwnerUnit().issueTargetOrderById(OrderIds.attack, m_targetUnit)
    else if (unitIsValidTargetNonStructure(m_targetUnit))
      return getOwnerUnit().issuePointOrderById(OrderIds.attack, m_targetUnit.getPos())
    return false

  // --------------------------------------------------------------------------
  function getNearestTargettableUnit() returns unit
    let targetPlayer = getTargetPlayer()
    if (targetPlayer == null)
      recordNote("getNearestTargettableUnit", "getTargetPlayer() == null")
      return null
    let ownerUnit = getOwnerUnit()
    unit targetUnit
    if (shouldTargetOrganicUnits())
      recordNote("getNearestTargettableUnit", "shouldTargetOrganicUnits() == true")
      targetUnit = getNearestUnitOfPlayer(targetPlayer, ownerUnit.getPos(), g_filterUnitIsValidTargetNonStructure)
      if (targetUnit != null)
        recordNote("getNearestTargettableUnit", "getNearestUnitOfPlayer() != null")
        return targetUnit
      targetUnit = getClosestValidHumanStructureTarget(targetPlayer, ownerUnit.getPos())
    else
      recordNote("getNearestTargettableUnit", "shouldTargetOrganicUnits() == false")
      targetUnit = getClosestValidHumanStructureTarget(targetPlayer, ownerUnit.getPos())
      if (targetUnit != null)
        recordNote("getNearestTargettableUnit", "getClosestValidHumanStructureTarget() != null")
        return targetUnit
      targetUnit = getNearestUnitOfPlayer(targetPlayer, ownerUnit.getPos(), g_filterUnitIsValidTargetNonStructure)
    return targetUnit

  // --------------------------------------------------------------------------
  private function setTargetUnit_impl(unit targetUnit) returns bool
    if (m_targetUnit == targetUnit)
      recordNote("setTargetUnit_impl", "m_targetUnit == targetUnit")
      return false
    if (m_targetUnit != null)
      recordNote("setTargetUnit_impl", "Target unit was not null : " + m_targetUnit.getName())
      unregisterTargetedUnit(m_targetUnit, this)
    m_targetUnit = targetUnit
    if (m_targetUnit != null)
      recordNote("setTargetUnit_impl", "Target unit is not null : " + m_targetUnit.getName())
      registerTargetedUnit(m_targetUnit, this)
      restartAttackTimer()
      recordNote("setTargetUnit_impl", "m_attackTime : " + m_attackTime.toString())
    else
      recordNote("setTargetUnit_impl", "Target unit is null")
    return true

  // --------------------------------------------------------------------------
  // Returns true if a closest unit target was found
  function tryTargetClosestUnit() returns bool
    let targetPlayer = getTargetPlayer()
    if (targetPlayer == null)
      recordNote("tryTargetClosestUnit", "getTargetPlayer() == null")
      return false

    let targetUnit = getNearestTargettableUnit()
    if (targetUnit == null)
      recordNote("tryTargetClosestUnit", "getNearestTargettableUnit() == null")
      return false

    setTargetUnit_impl(targetUnit)
    return true

  // --------------------------------------------------------------------------
  protected function tryTargetCampCenter() returns bool    
    let targetPlayer = getTargetPlayer()
    if (targetPlayer == null)
      recordNote("tryTargetCampCenter", "getTargetPlayer() == null")
      return false

    let playerMetadata = targetPlayer.getHumanMetadata()
    if (playerMetadata == null)
      recordNote("tryTargetCampCenter", "playerMetadata == null")
      return false

    let campCenter = playerMetadata.getHQOrHero()
    if (campCenter == null or not campCenter.isAlive())
      recordNote("tryTargetCampCenter", "campCenter == null or campCenter.isAlive()")
      return false

    return setTargetUnit_impl(campCenter)

  // --------------------------------------------------------------------------
  protected function onTargetUnitDied()
    setTargetUnit_impl(null)
    issueOrderTargetingPlayer()

  // --------------------------------------------------------------------------
  protected function onAttackedTargetUnit()
    restartAttackTimer()

  // --------------------------------------------------------------------------
  private function raiseTargetPlayerChangedEvent()
    if (m_targetPlayerChangedEvent != null)
      m_targetPlayerChangedEvent.call()

  // --------------------------------------------------------------------------
  protected function onAttackTimer()
    if (m_awaitingOrder)
      recordNote("onAttackTimer", "Awaiting order")
      return
    // If the timer has expired then this unit hasn't been able to attack
    // it's target in a while so try to target a new enemy
    if (getRealTimeSeconds() - m_attackTime > ATTACK_TIMER_DURATION)
      recordNote("onAttackTimer", "Timer has expired, issuing new order")
      setTargetUnit_impl(null)
      issueOrderTargetingPlayer()

  // --------------------------------------------------------------------------
  protected function restartAttackTimer()
    m_attackTime = getRealTimeSeconds()

  // --------------------------------------------------------------------------
  private function startDOT()
    if (not getIsInDOTGroup())
      recordNote("startDOT", "Adding UTC owner unit to dot group")
      g_dealDOTGroup.addUnit(getOwnerUnit())

  // --------------------------------------------------------------------------
  private function stopDOT()
    if (getIsInDOTGroup())
      recordNote("startDOT", "Removing UTC owner unit from dot group")
      g_dealDOTGroup.removeUnit(getOwnerUnit())

// ============================================================================
public function IUnitMetadata.getUndeadTargetingComponent() returns UndeadTargetingComponent
  return this.getComponent(typeInfo(UndeadTargetingComponent.typeId)) castTo UndeadTargetingComponent

// ============================================================================
public function IUnitMetadata.getOrAddUndeadTargetingComponent() returns UndeadTargetingComponent
  var component = this.getUndeadTargetingComponent()
  if (component == null)
    component = this.addComponent(new UndeadTargetingComponent(this)) castTo UndeadTargetingComponent
  return component

// ============================================================================
public function unit.getUndeadTargetingComponent() returns UndeadTargetingComponent
  let metadata = this.getMetadata()
  return metadata != null ? metadata.getUndeadTargetingComponent() : null

// ============================================================================
public function unit.getOrAddUndeadTargetingComponent() returns UndeadTargetingComponent
  let metadata = this.getMetadata()
  return metadata != null ? metadata.getOrAddUndeadTargetingComponent() : null

// ============================================================================
function registerActiveUTC(player _targetPlayer, unit _unit)
  var _group = g_activeUTCUnitsByTargetPlayer[_targetPlayer.getId()]
  if (_group == null)
    _group = CreateGroup()
    g_activeUTCUnitsByTargetPlayer[_targetPlayer.getId()] = _group
  if (not _group.contains(_unit))
    _group.addUnit(_unit)

// ============================================================================
function unregisterActiveUTC(player _targetPlayer, unit _unit)
  let _group = g_activeUTCUnitsByTargetPlayer[_targetPlayer.getId()]
  if (_group != null)
    _group.removeUnit(_unit)

// ============================================================================
function getClosestValidHumanStructureTarget(player p, vec2 pos) returns unit
  let targetList = g_validHumanStructureTargets.get(p)
  if (targetList.isEmpty())
    return null
  
  var distance = REAL_MAX
  unit target = null

  for u in targetList
    let d = u.getPos().distanceToSq(pos)
    if (d < distance)
      target = u
      distance = d

  return target

// ============================================================================
function unitIsValidTargetStructure(unit u) returns bool
  return g_validTargetStructureIds.has(u.getTypeId())

// ============================================================================
function filterUnitIsValidTargetStructure() returns bool
  return unitIsValidTargetStructure(GetFilterUnit())

// ============================================================================
function unitIsValidTargetNonStructure(unit u) returns bool
  return u.isAlive() and not u.isInvulnerable() and not u.isStructure()

// ============================================================================
function filterUnitIsValidTargetNonStructure() returns bool
  return unitIsValidTargetNonStructure(GetFilterUnit())

// ============================================================================
function onConstructionFinished()
  let constructedUnit = GetConstructedStructure()
  let owningPlayer = constructedUnit.getOwner()

  if (not owningPlayer.isHumanPlayer())
    return

  if (not unitIsValidTargetStructure(constructedUnit))
    return

  let targetList = g_validHumanStructureTargets.get(owningPlayer)
  targetList.add(constructedUnit)

// ============================================================================
function onUnitDeath()
  let dyingUnit = GetDyingUnit()
  let owningPlayer = dyingUnit.getOwner()

  if (owningPlayer.isHumanPlayer() and unitIsValidTargetStructure(dyingUnit))
    let targetList = g_validHumanStructureTargets.get(owningPlayer)
    targetList.remove(dyingUnit)

  unregisterTargetedUnit(dyingUnit)

// ============================================================================
function onUnitAttacked()
  let attackingUnit = GetAttacker()

  let metadata = attackingUnit.getMetadata()
  if (metadata == null)
    return
  
  let undeadTargetingComponent = metadata.getUndeadTargetingComponent()
  if (undeadTargetingComponent == null)
    return

  let targetUnit = undeadTargetingComponent.getTargetUnit()
  if (targetUnit == null)
    // Wait what? Why did he attack the non-target unit?
    // Oh well, just issue a new attack order
    undeadTargetingComponent.issueOrderTargetingPlayer()
    return
  
  undeadTargetingComponent.onAttackedTargetUnit()

// ============================================================================
function populateInitialValidHumanStructureTargets()
  let cond = Condition(function filterUnitIsValidTargetStructure)
  let tempGroup = getGroup()
  for p in g_PlayingHumanPlayers
    let list = g_validHumanStructureTargets.get(p)
    tempGroup.clear()
    tempGroup.enumUnitsOfPlayer(p, cond)
    for u in tempGroup
      list.add(u)
  cond.destr()
  tempGroup.release()

// ============================================================================
function registerTargetedUnit(unit targetedUnit, UndeadTargetingComponent comp)
  HashList<UndeadTargetingComponent> attackerList
  if (g_targetedUnitToUTCMap.has(targetedUnit))
    attackerList = g_targetedUnitToUTCMap.get(targetedUnit)
  else
    attackerList = new HashList<UndeadTargetingComponent>()
    g_targetedUnitToUTCMap.put(targetedUnit, attackerList)
  attackerList.add(comp)

// ============================================================================
function unregisterTargetedUnit(unit targetedUnit, UndeadTargetingComponent comp)
  if (not g_targetedUnitToUTCMap.has(targetedUnit))
    return
  let attackerList = g_targetedUnitToUTCMap.get(targetedUnit)
  attackerList.remove(comp)

// ============================================================================
function unregisterTargetedUnit(unit targetedUnit)
  if (not g_targetedUnitToUTCMap.has(targetedUnit))
    return
  let attackerList = g_targetedUnitToUTCMap.get(targetedUnit)
  g_targetedUnitToUTCMap.remove(targetedUnit)
  for comp in attackerList
    comp.onTargetUnitDied()
  destroy attackerList

// ============================================================================
function updateActiveUTCGroupOnePlayerAtATime()
  g_updateActiveUTCGroupIndex = wrap(g_updateActiveUTCGroupIndex, 0, g_HumanPlayers.count() - 1)
  let _player = g_HumanPlayers.getPlayerAt(g_updateActiveUTCGroupIndex)
  g_updateActiveUTCGroupIndex++
  if (_player == null)
    return
  let activeUTCUnitGroup = g_activeUTCUnitsByTargetPlayer[_player.getId()]
  if (activeUTCUnitGroup == null)
    return
  var numberOfUTCUnitsProcessed = 0
  for _unit in activeUTCUnitGroup
    if (_unit != null and _unit.isAlive())
      let comp = _unit.getMetadata().getUndeadTargetingComponent()
      if (comp != null and comp.getEnabled())
        comp.onAttackTimer()
        numberOfUTCUnitsProcessed++
  if (numberOfUTCUnitsProcessed > 0)
    Log.debug("Process {0} UTC units for target player {1}".format(numberOfUTCUnitsProcessed.toString(), _player.getId().toString()))

// ============================================================================
function applyDOT()
  for _unit in g_dealDOTGroup
    if (_unit != null and _unit.isAlive())
      _unit.subHP(_unit.getMaxHP() * DOT_PERCENT01)

// ============================================================================
function registerUnitAwaitingOrder(unit utcUnit)
  g_awaitingOrderGroup.addUnit(utcUnit)
  if (g_awaitingOrderGroupTimer == null)
    Log.debug("UTC", "registerUnitAwaitingOrder", "", "Group not empty, starting update timer")
    g_awaitingOrderGroupTimer = doPeriodically(UPDATE_INTERVAL, (CallbackPeriodic cb) -> issueOrders())

// ============================================================================
function unregisterUnitAwaitingOrder(unit utcUnit)
  g_awaitingOrderGroup.removeUnit(utcUnit)

// ============================================================================
function issueOrders()
  let maxUpdateExecutionCount = MAX_DEFERRED_EXECUTION_COUNT
  var executionCount = 0
 
  while (not g_awaitingOrderGroup.isEmpty() and executionCount < maxUpdateExecutionCount)
    let utcUnit = g_awaitingOrderGroup.getRandomUnit()
    if (utcUnit != null)
      g_awaitingOrderGroup.removeUnit(utcUnit)
      if (not utcUnit.isAlive())
        Log.debug("UTC", "issueOrders", "", "Unit is dead")
      else
        let metadata = utcUnit.getMetadata()
        if (metadata == null)
          Log.debug("UTC", "issueOrders", "", "Metadata is null")
        else
          let comp = metadata.getUndeadTargetingComponent()
          if (comp == null or not comp.getEnabled())
            Log.debug("UTC", "issueOrders", "", "UTC is null or disabled")
            return
          else
            comp.issueOrderTargetingPlayer_impl()
            executionCount++

  if (executionCount > 0)
    Log.debug("UTC", "issueOrders", "", "Issued {0} orders, {1} remaining".format(executionCount.toString(), g_awaitingOrderGroup.size().toString()))

  if (g_awaitingOrderGroup.isEmpty())
    Log.debug("UTC", "issueOrders", "", "Group empty, destroying update timer")
    destroy g_awaitingOrderGroupTimer
    g_awaitingOrderGroupTimer = null

// ============================================================================
class UTCDebugger extends TLSFrame
  private framehandle m_textArea
  private unit m_selectedUnit

  // --------------------------------------------------------------------------
  construct()
    super(createFrame("FRAME", "UTCDebugger", GAME_UI, "", 0))

  // --------------------------------------------------------------------------
  override function initialize()
    super.initialize()

    let frame = getFrameHandle()
    ..setWidth(0.35)
    ..setHeight(0.4)
    ..setAbsPoint(FRAMEPOINT_TOPLEFT, 0.46, 0.56)
    ..show()

    createFrame("BACKDROP", "UTCDebuggerBackdrop", GAME_UI, "BattleNetControlBackdropTemplate", 0)
    ..setParent(frame)
    ..setAllPoints(frame)

    m_textArea = createFrame("TEXTAREA", "UTCDebuggerTextArea", GAME_UI, "ConsoleTextArea", 0)
    ..setParent(frame)
    ..setAllPoints(frame)

    doPeriodically(0.1) (CallbackPeriodic cb) ->
      update()

  // --------------------------------------------------------------------------
  function setSelectedUnit(unit context)
    m_selectedUnit = context

  // --------------------------------------------------------------------------
  function update()

    if (getFrameHandle().isVisible() == false)
      return

    m_textArea.setText("")

    var text = ""
    for p in g_PlayingHumanPlayers
      let activeUTCUnitGroup = g_activeUTCUnitsByTargetPlayer[p.getId()]
      if (activeUTCUnitGroup != null)
        text += "{0}:{1} ".format(p.getId().toString(), activeUTCUnitGroup.size().toString())
    BlzFrameAddText(m_textArea, "Orders : {0}".format(text))

    if (m_selectedUnit == null)
      BlzFrameAddText(m_textArea, "Selected unit : null")
      return

    BlzFrameAddText(m_textArea, "Selected unit : " + m_selectedUnit.getName())

    let metadata = m_selectedUnit.getMetadata()
    if (metadata == null)
      BlzFrameAddText(m_textArea, "Selected unit metadata is null".colorize(Colors.red))
      return

    let utc = metadata.getUndeadTargetingComponent()
    if (utc == null)
      BlzFrameAddText(m_textArea, "Selected unit UTC is null".colorize(Colors.red))
      return
    
    BlzFrameAddText(m_textArea, "UTC enabled : " + utc.getEnabled().toString())
    BlzFrameAddText(m_textArea, "Target player : " + ((utc.m_targetPlayer != null) ? utc.m_targetPlayer.getName() : "null"))
    BlzFrameAddText(m_textArea, "Target unit : " + ((utc.m_targetUnit != null) ? utc.m_targetUnit.getName() : "null"))
    BlzFrameAddText(m_textArea, "Awaiting Order : " + utc.m_awaitingOrder.toString())
    BlzFrameAddText(m_textArea, "In DOT Group : " + utc.getIsInDOTGroup().toString())

    let recycler = m_selectedUnit.getRecycler()
    if (recycler != null)
      BlzFrameAddText(m_textArea, "Active in recycler \"{0}\" : {1}".format(UnitId2String(recycler.getUnitId()), recycler.isUnitActive(m_selectedUnit).toString()))

    if (utc.m_notes.isEmpty() == false)
      BlzFrameAddText(m_textArea, "=== Notes: === ")
      for note in utc.m_notes
        BlzFrameAddText(m_textArea, note)

// ============================================================================
init
  g_validHumanStructureTargets = new HashMap<player, LinkedList<unit>>()

  for p in g_PlayingHumanPlayers
    g_validHumanStructureTargets.put(p, new LinkedList<unit>())

  g_validTargetStructureIds = new HashList<int>()
  ..add(TlsUnitIds.barricade1)
  ..add(TlsUnitIds.barricade2)
  ..add(TlsUnitIds.barricade3)
  ..add(TlsUnitIds.barricade4)
  ..add(TlsUnitIds.scoutTower1)
  ..add(TlsUnitIds.scoutTower2)
  ..add(TlsUnitIds.scoutTower3)
  ..add(TlsUnitIds.scoutTower4)
  ..add(TlsUnitIds.scoutTower5)
  ..addAll(g_woodFenceIds)
  ..addAll(g_stoneWallIds)
  ..addAll(g_brickWallIds)
  ..addAll(g_metalWallIds)
  ..addAll(g_allGateIds)

  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_CONSTRUCT_FINISH, function onConstructionFinished)
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_DEATH, function onUnitDeath)
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_ATTACKED, function onUnitAttacked)

  // Populate with initial structures (for debug purposes)
  populateInitialValidHumanStructureTargets()

  doPeriodically(ATTACK_TIMER_INTERVAL, (CallbackPeriodic cb) -> updateActiveUTCGroupOnePlayerAtATime())

  doPeriodically(DOT_INTERVAL, (CallbackPeriodic cb) -> applyDOT())

  nullTimer() () ->
    g_utcDebugger = new UTCDebugger()

  doPeriodically(1.0) (CallbackPeriodic cb) ->
    let g = getGroup()
    unit selectedUnit = null
    g.enumUnitsSelected(g_HostPlayer, null)
    for u in g
    //{
      if (u.getOwner() == PLAYER_UNDEAD)
        let m = u.getMetadata()
        if (m != null)
          let c1 = m.getUndeadTargetingComponent()
          if (c1 != null)
            selectedUnit = u
    //}
    g.release()
    g_utcDebugger.setSelectedUnit(selectedUnit)
    if (selectedUnit != null)
      g_utcDebugger.show()
    else
      g_utcDebugger.hide()