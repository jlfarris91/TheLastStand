package UndeadTargetingComponent
import UnitComponent
import HumanPlayerComponent
import Events
import RegisterEvents
import HumanPlayers
import UnitExtensions
import ClosureTimers
import GameConstants
import Range
import TimerUtils
import GroupExtensions
import LeashComponent
import UndeadTargetService
import Trace

public bool UTC_ENABLED = true

constant rangeReal ATTACK_TIMER_DURATION_RANGE = rangeReal(1.0, 3.0)
constant real ATTACK_TIMER_DISTANCE_THRESHOLD = 128.0
constant real ATTACK_TIMER_DISTANCE_THRESHOLD_SQ = ATTACK_TIMER_DISTANCE_THRESHOLD * ATTACK_TIMER_DISTANCE_THRESHOLD
constant real TELEPORT_DISTANCE_THRESHOLD = SPAWN_RANGE_FAR.max
constant real TELEPORT_DISTANCE_THRESHOLD_SQ = TELEPORT_DISTANCE_THRESHOLD * TELEPORT_DISTANCE_THRESHOLD

constant real DOT_INTERVAL = 1.0
constant real DOT_PERCENT01 = 0.1

constant int MAX_DEFERRED_EXECUTION_COUNT = 4
constant real UPDATE_INTERVAL = 0.2

@configurable public bool g_enableUTCLogging = false
@configurable constant public int VALID_HUMAN_STRUCTURE_TARGETS_ATTACKER_COUNT_THRESHOLD = 3

public group g_dealDOTGroup = CreateGroup()
public group g_awaitingOrderGroup = CreateGroup()
CallbackPeriodic g_issueOrderTimer

/*

  This component is used to direct spawned enemies to attack a target player.
  
  It works by first attempting to target one of the player's "exterior structures"
  such as barricades, walls, gates, etc. We can reasonably assume that players
  will build at least one of these structures at some point. This works whether
  the player's base is completely closed off or has a pathable opening.
  
  We keep track of all of these exterior structures to make the operation as
  efficient as possible; issueOrderTargetingPlayer() is called at least once
  per enemy. We need to remember to update g_validTargetStructureIds with any
  new exterior structures added to the game.

  If the player has built no exterior structure then the unit will target the
  player's camp tent. If the player has no camp tent the unit will target the
  player's hero.

  Finally, if there is nothing to target so far the unit will increase it's
  acquisition range to the maximum. It should find SOMETHING to attack.

  We use the attack-move order in hopes of having the unit wander into range
  of a player's unit to attack. However, this can also mean that it can wander
  by another player's camp and attack it instead. This is fine.

*/

// ============================================================================
public class UndeadTargetingComponent extends UnitComponent
  protected player m_targetPlayer
  protected Event m_targetPlayerChangedEvent
  protected unit m_targetUnit
  protected int m_nextAttackTime
  protected bool m_preferOrganicTargets
  protected CallbackManual m_attackTimer
  protected real m_baseAttackRange
  protected LeashComponent m_leashComponent = null
  protected string m_orderFailedReason
  // protected Vector<string> m_notes
  protected int m_numberOfTimesFailedOrder = 0
  protected int m_numberOfTimesAttackTimerExpired = 0
  protected vec2 m_lastPos
  
  private UndeadTargetProvider m_targetProvider = null
  private _handle m_targetProviderOrganicTargetsChangedCallback = INVALID_HANDLE

  // --------------------------------------------------------------------------
  construct(IUnitMetadata owner)
    super(owner)
    m_targetPlayer = null
    m_targetPlayerChangedEvent = null
    m_targetUnit = null 
    m_nextAttackTime = 0
    m_preferOrganicTargets = false
    // m_notes = new Vector<string>()
    m_numberOfTimesFailedOrder = 0
    m_numberOfTimesAttackTimerExpired = 0
    m_baseAttackRange = MELEE_UNIT_ATTACK_RANGE.toReal()

  // --------------------------------------------------------------------------
  ondestroy
    if (m_targetPlayerChangedEvent != null)
      destroy m_targetPlayerChangedEvent
      m_targetPlayerChangedEvent = null

    // destroy m_notes

  // --------------------------------------------------------------------------
  override function onEnabled()
    super.onEnabled()
    m_baseAttackRange = getOwnerUnit().getFieldWeapon(UNIT_WEAPON_RF_ATTACK_RANGE, 0)
    m_lastPos = getOwnerUnit().getPos()
    m_leashComponent = getOwner().getOrAddLeashComponent()

  // --------------------------------------------------------------------------
  override function onDisabled()
    super.onDisabled()
    m_targetPlayer = null
    m_targetUnit = null
    m_numberOfTimesFailedOrder = 0
    m_numberOfTimesAttackTimerExpired = 0

    if (m_targetProvider != null)
      let evnt = m_targetProvider.onPreferOrganicTargetsChanged()
      if (evnt != null)
        evnt.unregister(m_targetProviderOrganicTargetsChangedCallback)
      m_targetProvider = null
      m_targetProviderOrganicTargetsChangedCallback = INVALID_HANDLE

    unregisterUnitAwaitingOrder(getOwnerUnit())
    setTargetUnit_impl(null)
    stopDOT()

    if (m_attackTimer != null)
      destroy m_attackTimer
      m_attackTimer = null

  // --------------------------------------------------------------------------
  function getIsAwaitingOrder() returns bool
    return g_awaitingOrderGroup.contains(getOwnerUnit())

  // --------------------------------------------------------------------------
  function getIsInDOTGroup() returns bool
    return g_dealDOTGroup.contains(getOwnerUnit())

  // --------------------------------------------------------------------------
  function getTargetPlayerChangedEvent() returns Event
    if (m_targetPlayerChangedEvent == null)
      m_targetPlayerChangedEvent = new Event()
    return m_targetPlayerChangedEvent

  // --------------------------------------------------------------------------
  function getTargetUnit() returns unit
    return m_targetUnit

  // --------------------------------------------------------------------------
  function getTargetPlayer() returns player
    return m_targetPlayer

  // --------------------------------------------------------------------------
  function setPreferOrganicTargets(bool value)
    m_preferOrganicTargets = value

  // --------------------------------------------------------------------------
  function getPreferOrganicTargets() returns bool
    return m_preferOrganicTargets

  // --------------------------------------------------------------------------
  function shouldTargetOrganicUnits() returns bool
    if (m_preferOrganicTargets)
      return true
    if (m_targetPlayer == null)
      return false
    let metadata = m_targetPlayer.getHumanPlayerComponent()
    if (metadata == null)
      return false
    return metadata.getCanPathToHeadquartersOrHero()

  // --------------------------------------------------------------------------
  function setTargetPlayer(player targetPlayer) returns bool
    let setPlayer = setTargetPlayer_impl(targetPlayer)
    if (setPlayer)
      setTargetUnit_impl(null)
      raiseTargetPlayerChangedEvent()
      issueOrderTargetingPlayer()
    return setPlayer

  // --------------------------------------------------------------------------
  function setTargetUnit(unit targetUnit) returns bool
    let targetPlayer = targetUnit != null ? targetUnit.getOwner() : null
    let setPlayer = setTargetPlayer_impl(targetPlayer)
    let setUnit = setTargetUnit_impl(targetUnit)
    if (setUnit)
      issueOrderTargetingPlayer()
    return setPlayer

  // --------------------------------------------------------------------------
  function setTargetPlayer_impl(player targetPlayer) returns bool
    let ownerUnit = getOwnerUnit()

    // This should really never happen but if it does fuckit kill the unit
    if (targetPlayer == null)
      //recordNote("sTP_i", "Target player was set to null")
      nullTimer(() -> ownerUnit.kill())
      return false

    if (targetPlayer == m_targetPlayer)
      return false
    
    m_targetPlayer = targetPlayer

    return true

  // --------------------------------------------------------------------------
  // protected function recordNote(string methodName, string note)
    // m_notes.add("[{0}] {1}".format(methodName, note))

  // --------------------------------------------------------------------------
  function issueOrderTargetingNewPlayerUnit()
    //recordNote("iOTNPU", "")
    setTargetUnit_impl(null)
    issueOrderTargetingPlayer()

  // --------------------------------------------------------------------------
  function issueOrderTargetingPlayer()

    let ownerUnit = getOwnerUnit()
    if (not ownerUnit.isAlive())
      //recordNote("iOTP", "UTC owner unit is dead")
      m_orderFailedReason = "UTC owner unit is dead"
      return

    // We're already awaiting a call to issueOrderTargetingPlayer_impl so early out
    if (getIsAwaitingOrder())
      //recordNote("iOTP", "Awaiting order")
      m_orderFailedReason = "Still awaiting order"
      return 
    
    if (getIsInDOTGroup())
      //recordNote("iOTP", "Is in dot group")
      m_orderFailedReason = "In DOT group"
      return

    registerUnitAwaitingOrder(ownerUnit)

    m_orderFailedReason = "Awaiting order"

  // --------------------------------------------------------------------------
  protected function issueOrderTargetingPlayer_impl()

    unregisterUnitAwaitingOrder(getOwnerUnit())
    // if (unregisterUnitAwaitingOrder(getOwnerUnit()))
      //recordNote("iOTP_i", "Removed from waiting group")      

    //recordNote("iOTP_i", "Order dispatched")

    if (m_targetUnit == null or not m_targetUnit.isAlive())
      //recordNote("iOTP_i", "1 m_targetUnit == null")

      // 1. Try targetting the nearest structure
      // 2. Try targetting the nearest non-structure
      tryTargetClosestUnit()

      // Unable to find a target unit
      if (m_targetUnit == null or not m_targetUnit.isAlive())
        //recordNote("iOTP_i", "2 m_targetUnit == null")

        // 3. Try attack-moving to the target player's camp center (the HQ tent or the hero)
        tryTargetCampCenter()
        // if (tryTargetCampCenter())
          //recordNote("iOTP_i", "Could not find target unit, attack-moving to camp center")
        
        // 4. The target player is either null or considered dead, so start damaging the unit over time
        if (m_targetUnit == null or not m_targetUnit.isAlive())
          //recordNote("iOTP_i", "3 m_targetUnit == null")
          startDOT()
          return

    restartAttackTimer()

    tryTeleportCloserToTargetUnit()

    if (not tryIssueOrder())
      m_orderFailedReason = "Failed to issue attack order"
      m_numberOfTimesFailedOrder++
      // if (m_numberOfTimesFailedOrder > 3)
        // m_notes.clear()
      //recordNote("iOTP_i", "Unable to issue order ({0}), trying again".format(m_numberOfTimesFailedOrder.toString()))
      // Unable to issue the order so clear the target unit and try again later
      clearTargetAndIssueNewOrder()
    else
      m_numberOfTimesFailedOrder = 0
      // m_notes.add("Success!")
      m_orderFailedReason = "Success"

  // --------------------------------------------------------------------------
  function clearTargetAndIssueNewOrder()
    setTargetUnit_impl(null)
    issueOrderTargetingPlayer()

  // --------------------------------------------------------------------------
  function tryIssueOrder() returns bool
    if (m_targetUnit == null)
      //recordNote("tIO", "m_targetUnit == null")
      m_orderFailedReason = "m_targetUnit == null"
      return false
    bool issuedOrder
    if (m_targetUnit.isStructure())
      //recordNote("tIO", "ordering attack on " + m_targetUnit.getName())
      issuedOrder = getOwnerUnit().issueTargetOrder("attack", m_targetUnit)
    else
      //recordNote("tIO", "ordering attack-move on " + m_targetUnit.getName())
      issuedOrder = getOwnerUnit().issuePointOrder("attack", m_targetUnit.getPos())
    if (issuedOrder == false)
      m_orderFailedReason = "Failed to issue order"
    return issuedOrder

  // --------------------------------------------------------------------------
  function getNearestTargettableUnit() returns unit
    let targetPlayer = getTargetPlayer()
    if (targetPlayer == null)
      //recordNote("gNTU", "getTargetPlayer() == null")
      return null
    let ownerUnit = getOwnerUnit()
    unit targetUnit
    let targetProvider = getUndeadTargetProvider(targetPlayer)
    if (targetProvider == null)
      return null
    targetUnit = targetProvider.getClosestTargetUnit(ownerUnit.getPos(), getPreferOrganicTargets())
    return targetUnit

  // --------------------------------------------------------------------------
  function getUndeadTargetProvider(player targetPlayer) returns UndeadTargetProvider
    let targetProvider = getUndeadTargetProviderForPlayer(targetPlayer)

    if (m_targetProvider == targetProvider)
      return targetProvider
    
    if (m_targetProvider != null)
      let e = m_targetProvider.onPreferOrganicTargetsChanged()
      if (e != null)
        e.unregister(m_targetProviderOrganicTargetsChangedCallback)
      m_targetProviderOrganicTargetsChangedCallback = INVALID_HANDLE
      m_targetProvider.release()

    m_targetProvider = targetProvider

    if (m_targetProvider != null)
      m_targetProvider.acquire()     
      m_targetProviderOrganicTargetsChangedCallback = m_targetProvider.onPreferOrganicTargetsChanged().registerDispatched(this) () ->
        clearTargetAndIssueNewOrder()

    return m_targetProvider

  // --------------------------------------------------------------------------
  private function setTargetUnit_impl(unit targetUnit) returns bool
    if (m_targetUnit == targetUnit)
      //recordNote("sTU_i", "m_targetUnit == targetUnit, m_targetUnit = " + (m_targetUnit != null ? m_targetUnit.getName() : "null"))
      return false

    if (m_targetUnit != null)
      //recordNote("sTU_i", "Target unit was not null : " + m_targetUnit.getName())
      unregisterTargetedUnit(m_targetUnit, getOwnerUnit())

    m_targetUnit = targetUnit

    if (m_leashComponent != null)
      m_leashComponent.setTargetUnit(targetUnit)

    if (m_targetUnit != null)
      //recordNote("sTU_i", "Target unit is not null : " + m_targetUnit.getName())
      registerTargetedUnit(m_targetUnit, getOwnerUnit())
      restartAttackTimer()
    // else
      //recordNote("sTU_i", "Target unit is null")

    return true

  // --------------------------------------------------------------------------
  // Returns true if a closest unit target was found
  function tryTargetClosestUnit() returns bool
    let targetPlayer = getTargetPlayer()
    if (targetPlayer == null)
      //recordNote("tTCU", "getTargetPlayer() == null")
      return false

    let targetUnit = getNearestTargettableUnit()
    if (targetUnit == null)
      //recordNote("tTCU", "getNearestTargettableUnit() == null")
      return false

    setTargetUnit_impl(targetUnit)
    return true

  // --------------------------------------------------------------------------
  protected function tryTargetCampCenter() returns bool    
    let targetPlayer = getTargetPlayer()
    if (targetPlayer == null)
      //recordNote("tTCC", "getTargetPlayer() == null")
      return false

    let playerMetadata = targetPlayer.getHumanPlayerComponent()
    if (playerMetadata == null)
      //recordNote("tTCC", "playerMetadata == null")
      return false

    let campCenter = playerMetadata.getHQOrHero()
    if (campCenter == null or not campCenter.isAlive())
      //recordNote("tTCC", "campCenter == null or campCenter.isAlive()")
      return false

    return setTargetUnit_impl(campCenter)

  // --------------------------------------------------------------------------
  function onTargetUnitNoLongerTargettable()
    issueOrderTargetingNewPlayerUnit()

  // --------------------------------------------------------------------------
  protected function onAttackedUnit(unit attackedUnit)
    m_numberOfTimesAttackTimerExpired = 0
    if (m_targetUnit == null)
      issueOrderTargetingNewPlayerUnit()
    else if (m_targetUnit == attackedUnit)
      restartAttackTimer()

  // --------------------------------------------------------------------------
  private function raiseTargetPlayerChangedEvent()
    if (m_targetPlayerChangedEvent != null)
      m_targetPlayerChangedEvent.call()

  // --------------------------------------------------------------------------
  protected static function onAttackTimer(unit utcUnit)
    let metadata = utcUnit.getMetadata()
    if (metadata == null)
      return
    let comp = metadata.getUndeadTargetingComponent()
    if (comp == null)
      return
    comp.onAttackTimer()

  // --------------------------------------------------------------------------
  protected function onAttackTimer()
    m_numberOfTimesAttackTimerExpired++
    
    if (getIsAwaitingOrder())
      //recordNote("onAttackTimer", "Awaiting order")
      return

    //recordNote("onAttackTimer", "Timer has expired")

    // Distance to target unit is way too far to walk all the way there, teleport closer.
    // We want to check this regularly so we might as well check it here.
    if (tryTeleportCloserToTargetUnit())
      //recordNote("onAttackTimer", "Issuing new order")
      issueOrderTargetingNewPlayerUnit()

    // If the unit is standing still and hasn't attacked anything since the last attack timer
    // then issue a new order, otherwise give them a chance to get to their target
    else if (getOwnerUnit().getPos().distanceToSq(m_lastPos) < ATTACK_TIMER_DISTANCE_THRESHOLD_SQ)
      //recordNote("onAttackTimer", "Issuing new order")
      issueOrderTargetingNewPlayerUnit()
    
    // Otherwise, restart the attack timer to check again later
    else
      restartAttackTimer()

    m_lastPos = getOwnerUnit().getPos()

  // --------------------------------------------------------------------------
  private function tryTeleportCloserToTargetUnit() returns bool
    return m_leashComponent != null and m_leashComponent.tryTeleportCloserToTargetUnit()

  // --------------------------------------------------------------------------
  protected function restartAttackTimer()
    if (m_attackTimer == null)
      m_attackTimer = getTimer().doManual(ATTACK_TIMER_DURATION_RANGE.getRandom(), true) -> 
        onAttackTimer()
    else
      m_attackTimer.restart(ATTACK_TIMER_DURATION_RANGE.getRandom())

  // --------------------------------------------------------------------------
  private function startDOT()
    if (not getIsInDOTGroup() and not getOwnerUnit().getOwner().isHumanPlayer())
      //recordNote("startDOT", "Adding UTC owner unit to dot group")
      g_dealDOTGroup.addUnit(getOwnerUnit())

  // --------------------------------------------------------------------------
  private function stopDOT()
    if (getIsInDOTGroup())
      //recordNote("startDOT", "Removing UTC owner unit from dot group")
      g_dealDOTGroup.removeUnit(getOwnerUnit())

  // --------------------------------------------------------------------------
  function getOrderFailedReason() returns string
    return m_orderFailedReason

  // --------------------------------------------------------------------------
  function getNumberOfTimesFailedOrder() returns int
    return m_numberOfTimesFailedOrder

  // --------------------------------------------------------------------------
  function getNumberOfTimesAttackTimerExpired() returns int
    return m_numberOfTimesAttackTimerExpired

  // --------------------------------------------------------------------------
  function getDistanceMoved() returns real
    return getOwnerUnit().getPos().distanceTo(m_lastPos)

// ============================================================================
public function IUnitMetadata.getUndeadTargetingComponent() returns UndeadTargetingComponent
  return this.getComponent(UndeadTargetingComponent.typeId) castTo UndeadTargetingComponent

// ============================================================================
public function unit.getUndeadTargetingComponent() returns UndeadTargetingComponent
  let metadata = this.getMetadata()
  return metadata != null ? metadata.getUndeadTargetingComponent() : null

// ============================================================================
function onUnitAttacked()
  let attackingUnit = GetAttacker()

  let metadata = attackingUnit.getMetadata()
  if (metadata == null)
    return
  
  let undeadTargetingComponent = metadata.getUndeadTargetingComponent()
  if (undeadTargetingComponent == null)
    return
  
  undeadTargetingComponent.onAttackedUnit(GetAttackedUnitBJ())

group g_tempGroup = CreateGroup()

// ============================================================================
function applyDOT()

  if (not UTC_ENABLED)
    return

  Trace.trace("UTC.applyDOT")

  for _unit in g_dealDOTGroup
    if (_unit != null and _unit.isAlive())
      _unit.subHP(_unit.getMaxHP() * DOT_PERCENT01)

// ============================================================================
function registerUnitAwaitingOrder(unit utcUnit) returns bool
  let didNotContainUnit = not g_awaitingOrderGroup.contains(utcUnit)
  g_awaitingOrderGroup.addUnit(utcUnit)
  return didNotContainUnit and g_awaitingOrderGroup.contains(utcUnit)

// ============================================================================
function unregisterUnitAwaitingOrder(unit utcUnit) returns bool
  let didContainUnit = g_awaitingOrderGroup.contains(utcUnit)
  g_awaitingOrderGroup.removeUnit(utcUnit)
  return didContainUnit and not g_awaitingOrderGroup.contains(utcUnit)

public int g_numberOfTimesIssueOrdersStartCalled = 0
public int g_numberOfTimesIssueOrdersEndCalled = 0
public int g_numberOfOrdersIssued = 0

// ============================================================================
function issueOrders()

  if (not UTC_ENABLED)
    return

  Trace.trace("UTC.issueOrders")

  let maxUpdateExecutionCount = MAX_DEFERRED_EXECUTION_COUNT
  var executionCount = 0
 
  g_numberOfTimesIssueOrdersStartCalled++

  // Occasionally we get a unit that has been removed from the game but not from
  // our g_awaitingOrderGroup group. In which case g_awaitingOrderGroup.isEmpty()
  // was returning null since it uses FirstOfGroup() which will return null when
  // one of those ghost units is the first unit in the group. So, we need use
  // refresh() here to get rid of any ghost units.
  if (g_awaitingOrderGroup.isEmpty() and g_awaitingOrderGroup.size() > 0)
    g_awaitingOrderGroup.refresh()

  while (not g_awaitingOrderGroup.isEmpty() and executionCount < maxUpdateExecutionCount)
  //{
    let utcUnit = g_awaitingOrderGroup.getUnitAt(GetRandomInt(0, g_awaitingOrderGroup.size() - 1))
    g_awaitingOrderGroup.removeUnit(utcUnit)
    if (utcUnit != null)
      if (not utcUnit.isAlive())
        if (g_enableUTCLogging)
          Log.debug("UTC", "issueOrders", "", "Unit is dead")
      else
        let metadata = utcUnit.getMetadata()
        if (metadata == null)
          if (g_enableUTCLogging)
            Log.debug("UTC", "issueOrders", "", "Metadata is null")
        else
          let comp = metadata.getUndeadTargetingComponent()
          if (comp == null or not comp.getEnabled())
            if (g_enableUTCLogging)
              Log.debug("UTC", "issueOrders", "", "UTC is null or disabled")
          else
            comp.issueOrderTargetingPlayer_impl()
            executionCount++
            g_numberOfOrdersIssued++
    //}

  Trace.trace("UTC.issueOrders.execute", executionCount)

  g_numberOfTimesIssueOrdersEndCalled++

// ============================================================================
init

  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_ATTACKED, function onUnitAttacked)

  doPeriodically(UPDATE_INTERVAL, (CallbackPeriodic cb) -> issueOrders())
  doPeriodically(DOT_INTERVAL, (CallbackPeriodic cb) -> applyDOT())