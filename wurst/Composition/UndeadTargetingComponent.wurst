package UndeadTargetingComponent
import UnitComponent
import HumanPlayerComponent
import Events
import LinkedList
import RegisterEvents
import HashMap
import HumanPlayers
import TlsUnitIds
import HashList
import GroupUtils
import Unit_WoodFence
import Unit_StoneWall
import Unit_GateCommon
import Unit_MetalWall
import TargetUtility
import UnitExtensions
import ClosureTimers
import Host
import GameConstants
import UnitRecycler
import Unit_BrickWall
import Vector
import TLSFrame
import ColorUtility
import Range
import TimerUtils
import UnitIndexer
import ProjectConstants
import GroupExtensions

constant real ATTACK_TIMER_INTERVAL = 1.0
constant rangeReal ATTACK_TIMER_DURATION_RANGE = rangeReal(10.0, 20.0)

constant real DOT_INTERVAL = 1.0
constant real DOT_PERCENT01 = 0.1

constant int MAX_DEFERRED_EXECUTION_COUNT = 4
constant real UPDATE_INTERVAL = 0.2

@configurable public bool g_enableUTCLogging = false

HashMap<player, LinkedList<unit>> g_validHumanStructureTargets
HashList<int> g_validTargetStructureIds
conditionfunc g_filterUnitIsValidTargetStructure = Condition(function filterUnitIsValidTargetStructure)
conditionfunc g_filterUnitIsValidTargetNonStructure = Condition(function filterUnitIsValidTargetNonStructure)
IterableMap<unit, HashList<UndeadTargetingComponent>> g_targetedUnitToUTCMap = new IterableMap<unit, HashList<UndeadTargetingComponent>>()
group g_dealDOTGroup = CreateGroup()
UTCDebugger g_utcDebugger
group g_awaitingOrderGroup = CreateGroup()
CallbackPeriodic g_issueOrderTimer

/*

  This component is used to direct spawned enemies to attack a target player.
  
  It works by first attempting to target one of the player's "exterior structures"
  such as barricades, walls, gates, etc. We can reasonably assume that players
  will build at least one of these structures at some point. This works whether
  the player's base is completely closed off or has a pathable opening.
  
  We keep track of all of these exterior structures to make the operation as
  efficient as possible; issueOrderTargetingPlayer() is called at least once
  per enemy. We need to remember to update g_validTargetStructureIds with any
  new exterior structures added to the game.

  If the player has built no exterior structure then the unit will target the
  player's camp tent. If the player has no camp tent the unit will target the
  player's hero.

  Finally, if there is nothing to target so far the unit will increase it's
  acquisition range to the maximum. It should find SOMETHING to attack.

  We use the attack-move order in hopes of having the unit wander into range
  of a player's unit to attack. However, this can also mean that it can wander
  by another player's camp and attack it instead. This is fine.

*/

// ============================================================================
public class UndeadTargetingComponent extends UnitComponent
  protected player m_targetPlayer
  protected Event m_targetPlayerChangedEvent
  protected unit m_targetUnit
  protected int m_nextAttackTime
  protected bool m_preferOrganicTargets
  protected CallbackManual m_attackTimer

  protected string m_orderFailedReason
  protected Vector<string> m_notes
  protected int m_numberOfTimesFailedOrder = 0

  // --------------------------------------------------------------------------
  construct(IUnitMetadata owner)
    super(owner)
    m_targetPlayer = null
    m_targetPlayerChangedEvent = null
    m_targetUnit = null 
    m_nextAttackTime = 0
    m_preferOrganicTargets = false
    m_notes = new Vector<string>()
    m_numberOfTimesFailedOrder = 0

  // --------------------------------------------------------------------------
  ondestroy
    if (m_targetPlayerChangedEvent != null)
      destroy m_targetPlayerChangedEvent
      m_targetPlayerChangedEvent = null

    destroy m_notes

    // Make sure to remove this component
    for key in g_targetedUnitToUTCMap
      let list = g_targetedUnitToUTCMap.get(key)
      if (list != null)
        list.remove(this)

  // --------------------------------------------------------------------------
  override function onEnabled()
    super.onEnabled()

  // --------------------------------------------------------------------------
  override function onDisabled()
    super.onDisabled()
    m_targetPlayer = null
    m_targetUnit = null
    m_numberOfTimesFailedOrder = 0

    unregisterUnitAwaitingOrder(getOwnerUnit())
    setTargetUnit_impl(null)
    stopDOT()

    if (m_attackTimer != null)
      destroy m_attackTimer
      m_attackTimer = null

  // --------------------------------------------------------------------------
  function getIsAwaitingOrder() returns bool
    return g_awaitingOrderGroup.contains(getOwnerUnit())

  // --------------------------------------------------------------------------
  function getIsInDOTGroup() returns bool
    return g_dealDOTGroup.contains(getOwnerUnit())

  // --------------------------------------------------------------------------
  function getTargetPlayerChangedEvent() returns Event
    if (m_targetPlayerChangedEvent == null)
      m_targetPlayerChangedEvent = new Event()
    return m_targetPlayerChangedEvent

  // --------------------------------------------------------------------------
  function getTargetUnit() returns unit
    return m_targetUnit

  // --------------------------------------------------------------------------
  function getTargetPlayer() returns player
    return m_targetPlayer

  // --------------------------------------------------------------------------
  function setPreferOrganicTargets(bool value)
    m_preferOrganicTargets = value

  // --------------------------------------------------------------------------
  function getPreferOrganicTargets() returns bool
    return m_preferOrganicTargets

  // --------------------------------------------------------------------------
  function shouldTargetOrganicUnits() returns bool
    if (m_preferOrganicTargets)
      return true
    if (m_targetPlayer == null)
      return false
    let metadata = m_targetPlayer.getHumanPlayerComponent()
    if (metadata == null)
      return false
    return metadata.getCanPathToHeadquartersOrHero()

  // --------------------------------------------------------------------------
  function setTargetPlayer(player targetPlayer) returns bool
    let setPlayer = setTargetPlayer_impl(targetPlayer)
    if (setPlayer)
      setTargetUnit_impl(null)
      raiseTargetPlayerChangedEvent()
      issueOrderTargetingPlayer()
    return setPlayer

  // --------------------------------------------------------------------------
  function setTargetUnit(unit targetUnit) returns bool
    let targetPlayer = targetUnit != null ? targetUnit.getOwner() : null
    let setPlayer = setTargetPlayer_impl(targetPlayer)
    let setUnit = setTargetUnit_impl(targetUnit)
    if (setUnit)
      issueOrderTargetingPlayer()
    return setPlayer

  // --------------------------------------------------------------------------
  function setTargetPlayer_impl(player targetPlayer) returns bool
    let ownerUnit = getOwnerUnit()

    // This should really never happen but if it does fuckit kill the unit
    if (targetPlayer == null)
      recordNote("sTP_i", "Target player was set to null")
      nullTimer(() -> ownerUnit.kill())
      return false

    if (targetPlayer == m_targetPlayer)
      return false
    
    m_targetPlayer = targetPlayer

    return true

  // --------------------------------------------------------------------------
  protected function recordNote(string methodName, string note)
    m_notes.add("[{0}] {1}".format(methodName, note))

  // --------------------------------------------------------------------------
  function issueOrderTargetingNewPlayerUnit()
    recordNote("iOTNPU", "")
    setTargetUnit_impl(null)
    issueOrderTargetingPlayer()

  // --------------------------------------------------------------------------
  function issueOrderTargetingPlayer()

    let ownerUnit = getOwnerUnit()
    if (not ownerUnit.isAlive())
      recordNote("iOTP", "UTC owner unit is dead")
      m_orderFailedReason = "UTC owner unit is dead"
      return

    // We're already awaiting a call to issueOrderTargetingPlayer_impl so early out
    if (getIsAwaitingOrder())
      recordNote("iOTP", "Awaiting order")
      m_orderFailedReason = "Still awaiting order"
      return 
    
    if (getIsInDOTGroup())
      recordNote("iOTP", "Is in dot group")
      m_orderFailedReason = "In DOT group"
      return

    if (registerUnitAwaitingOrder(ownerUnit))
      recordNote("iOTP", "Added to waiting group")

    recordNote("iOTP", "Dispatching order")

    m_orderFailedReason = "Awaiting order"

  // --------------------------------------------------------------------------
  protected function issueOrderTargetingPlayer_impl()

    if (unregisterUnitAwaitingOrder(getOwnerUnit()))
      recordNote("iOTP_i", "Removed from waiting group")      

    recordNote("iOTP_i", "Order dispatched")

    if (m_targetUnit == null)
      recordNote("iOTP_i", "1 m_targetUnit == null")

      // 1. Try targetting the nearest structure
      // 2. Try targetting the nearest non-structure
      tryTargetClosestUnit()

      // Unable to find a target unit
      if (m_targetUnit == null)
        recordNote("iOTP_i", "2 m_targetUnit == null")

        // 3. Try attack-moving to the target player's camp center (the HQ tent or the hero)
        if (tryTargetCampCenter())
          recordNote("iOTP_i", "Could not find target unit, attack-moving to camp center")
        
        // 4. The target player is either null or considered dead, so start damaging the unit over time
        if (m_targetUnit == null)
          recordNote("iOTP_i", "3 m_targetUnit == null")
          startDOT()
          return

    restartAttackTimer()

    if (not tryIssueOrder())
      m_orderFailedReason = "Failed to issue attack order"
      m_numberOfTimesFailedOrder++
      if (m_numberOfTimesFailedOrder > 3)
        m_notes.clear()
      recordNote("iOTP_i", "Unable to issue order ({0}), trying again".format(m_numberOfTimesFailedOrder.toString()))
      // Unable to issue the order so clear the target unit and try again later
      setTargetUnit_impl(null)
      issueOrderTargetingPlayer()
    else
      m_numberOfTimesFailedOrder = 0
      m_notes.add("Success!")
      m_orderFailedReason = "Success"

  // --------------------------------------------------------------------------
  function tryIssueOrder() returns bool
    if (m_targetUnit == null)
      recordNote("tIO", "m_targetUnit == null")
      m_orderFailedReason = "m_targetUnit == null"
      return false
    bool issuedOrder
    if (m_targetUnit.isStructure())
      recordNote("tIO", "ordering attack on " + m_targetUnit.getName())
      issuedOrder = getOwnerUnit().issueTargetOrder("attack", m_targetUnit)
    else
      recordNote("tIO", "ordering attack-move on " + m_targetUnit.getName())
      issuedOrder = getOwnerUnit().issuePointOrder("attack", m_targetUnit.getPos())
    if (issuedOrder == false)
      m_orderFailedReason = "Failed to issue order"
    return issuedOrder

  // --------------------------------------------------------------------------
  function getNearestTargettableUnit() returns unit
    let targetPlayer = getTargetPlayer()
    if (targetPlayer == null)
      recordNote("gNTU", "getTargetPlayer() == null")
      return null
    let ownerUnit = getOwnerUnit()
    unit targetUnit
    if (shouldTargetOrganicUnits())
      recordNote("gNTU", "shouldTargetOrganicUnits() == true")
      targetUnit = getNearestUnitOfPlayer(targetPlayer, ownerUnit.getPos(), g_filterUnitIsValidTargetNonStructure)
      if (targetUnit != null)
        recordNote("gNTU", "getNearestUnitOfPlayer() != null")
        return targetUnit
      else
        recordNote("gNTU", "getNearestUnitOfPlayer() == null")
      targetUnit = getClosestValidHumanStructureTarget(targetPlayer, ownerUnit.getPos())
      if (targetUnit != null)        
        recordNote("gNTU", "getClosestValidHumanStructureTarget() != null")
      else
        recordNote("gNTU", "getClosestValidHumanStructureTarget() == null")
    else
      recordNote("gNTU", "shouldTargetOrganicUnits() == false")
      targetUnit = getClosestValidHumanStructureTarget(targetPlayer, ownerUnit.getPos())
      if (targetUnit != null)
        recordNote("gNTU", "getClosestValidHumanStructureTarget() != null")
        return targetUnit
      else
        recordNote("gNTU", "getClosestValidHumanStructureTarget() == null")
      targetUnit = getNearestUnitOfPlayer(targetPlayer, ownerUnit.getPos(), g_filterUnitIsValidTargetNonStructure)
      if (targetUnit != null)        
        recordNote("gNTU", "getNearestUnitOfPlayer() != null")
      else
        recordNote("gNTU", "getNearestUnitOfPlayer() == null")
    return targetUnit

  // --------------------------------------------------------------------------
  private function setTargetUnit_impl(unit targetUnit) returns bool
    if (m_targetUnit == targetUnit)
      recordNote("sTU_i", "m_targetUnit == targetUnit, m_targetUnit = " + (m_targetUnit != null ? m_targetUnit.getName() : "null"))
      return false

    if (m_targetUnit != null)
      recordNote("sTU_i", "Target unit was not null : " + m_targetUnit.getName())
      unregisterTargetedUnit(m_targetUnit, this)

    m_targetUnit = targetUnit

    if (m_targetUnit != null)
      recordNote("sTU_i", "Target unit is not null : " + m_targetUnit.getName())
      registerTargetedUnit(m_targetUnit, this)
      restartAttackTimer()
    else
      recordNote("sTU_i", "Target unit is null")

    return true

  // --------------------------------------------------------------------------
  // Returns true if a closest unit target was found
  function tryTargetClosestUnit() returns bool
    let targetPlayer = getTargetPlayer()
    if (targetPlayer == null)
      recordNote("tTCU", "getTargetPlayer() == null")
      return false

    let targetUnit = getNearestTargettableUnit()
    if (targetUnit == null)
      recordNote("tTCU", "getNearestTargettableUnit() == null")
      return false

    setTargetUnit_impl(targetUnit)
    return true

  // --------------------------------------------------------------------------
  protected function tryTargetCampCenter() returns bool    
    let targetPlayer = getTargetPlayer()
    if (targetPlayer == null)
      recordNote("tTCC", "getTargetPlayer() == null")
      return false

    let playerMetadata = targetPlayer.getHumanPlayerComponent()
    if (playerMetadata == null)
      recordNote("tTCC", "playerMetadata == null")
      return false

    let campCenter = playerMetadata.getHQOrHero()
    if (campCenter == null or not campCenter.isAlive())
      recordNote("tTCC", "campCenter == null or campCenter.isAlive()")
      return false

    return setTargetUnit_impl(campCenter)

  // --------------------------------------------------------------------------
  protected function onTargetUnitDied()
    issueOrderTargetingNewPlayerUnit()

  // --------------------------------------------------------------------------
  protected function onAttackedUnit(unit attackedUnit)
    if (m_targetUnit == null)
      issueOrderTargetingNewPlayerUnit()
    else if (m_targetUnit == attackedUnit)
      restartAttackTimer()

  // --------------------------------------------------------------------------
  private function raiseTargetPlayerChangedEvent()
    if (m_targetPlayerChangedEvent != null)
      m_targetPlayerChangedEvent.call()

  // --------------------------------------------------------------------------
  protected static function onAttackTimer(unit utcUnit)
    let metadata = utcUnit.getMetadata()
    if (metadata == null)
      return
    let comp = metadata.getUndeadTargetingComponent()
    if (comp == null)
      return
    comp.onAttackTimer()

  // --------------------------------------------------------------------------
  protected function onAttackTimer()
    if (getIsAwaitingOrder())
      recordNote("onAttackTimer", "Awaiting order")
      return
    // If the timer has expired then this unit hasn't been able to attack
    // it's target in a while so try to target a new enemy
    recordNote("onAttackTimer", "Timer has expired, issuing new order")
    issueOrderTargetingNewPlayerUnit()

  // --------------------------------------------------------------------------
  protected function restartAttackTimer()
    if (m_attackTimer == null)
      m_attackTimer = getTimer().doManual(ATTACK_TIMER_DURATION_RANGE.getRandom(), true) -> 
        onAttackTimer()
    else
      m_attackTimer.restart(ATTACK_TIMER_DURATION_RANGE.getRandom())

  // --------------------------------------------------------------------------
  private function startDOT()
    if (not getIsInDOTGroup() and not getOwnerUnit().getOwner().isHumanPlayer())
      recordNote("startDOT", "Adding UTC owner unit to dot group")
      g_dealDOTGroup.addUnit(getOwnerUnit())

  // --------------------------------------------------------------------------
  private function stopDOT()
    if (getIsInDOTGroup())
      recordNote("startDOT", "Removing UTC owner unit from dot group")
      g_dealDOTGroup.removeUnit(getOwnerUnit())

// ============================================================================
public function IUnitMetadata.getUndeadTargetingComponent() returns UndeadTargetingComponent
  return this.getComponent(UndeadTargetingComponent.typeId) castTo UndeadTargetingComponent

// ============================================================================
public function IUnitMetadata.getOrAddUndeadTargetingComponent() returns UndeadTargetingComponent
  var component = this.getUndeadTargetingComponent()
  if (component == null)
    component = this.addComponent(new UndeadTargetingComponent(this)) castTo UndeadTargetingComponent
  return component

// ============================================================================
public function unit.getUndeadTargetingComponent() returns UndeadTargetingComponent
  let metadata = this.getMetadata()
  return metadata != null ? metadata.getUndeadTargetingComponent() : null

// ============================================================================
public function unit.getOrAddUndeadTargetingComponent() returns UndeadTargetingComponent
  let metadata = this.getMetadata()
  return metadata != null ? metadata.getOrAddUndeadTargetingComponent() : null

// ============================================================================
function getClosestValidHumanStructureTarget(player p, vec2 pos) returns unit
  let targetList = g_validHumanStructureTargets.get(p)
  if (targetList.isEmpty())
    return null
  
  var distance = REAL_MAX
  unit target = null

  for u in targetList
    let d = u.getPos().distanceToSq(pos)
    if (d < distance)
      target = u
      distance = d

  return target

// ============================================================================
function unitIsValidTargetStructure(unit u) returns bool
  return g_validTargetStructureIds.has(u.getTypeId())

// ============================================================================
function filterUnitIsValidTargetStructure() returns bool
  return unitIsValidTargetStructure(GetFilterUnit())

// ============================================================================
function unitIsValidTargetNonStructure(unit u) returns bool
  return u.isAlive() and not u.isInvulnerable() and (u.isCampHeadquarters() or not u.isStructure())

// ============================================================================
function filterUnitIsValidTargetNonStructure() returns bool
  return unitIsValidTargetNonStructure(GetFilterUnit())

// ============================================================================
function registerPlayerTargetStructure(unit targetStructure)
  if (not unitIsValidTargetStructure(targetStructure))
    return
  let targetList = g_validHumanStructureTargets.get(targetStructure.getOwner())
  targetList.add(targetStructure)

// ============================================================================
function unregisterPlayerTargetStructure(unit targetStructure)
  let owningPlayer = targetStructure.getOwner()
  if (owningPlayer.isHumanPlayer() and unitIsValidTargetStructure(targetStructure))
    let targetList = g_validHumanStructureTargets.get(owningPlayer)
    targetList.remove(targetStructure)
  unregisterTargetedUnit(targetStructure)

// ============================================================================
function onUnitIndexed()
  let indexingUnit = getIndexingUnit()
  if (indexingUnit.getOwner().isHumanPlayer() and indexingUnit.isStructure())
    registerPlayerTargetStructure(indexingUnit)

// ============================================================================
function onUnitDeindexed()
  let indexingUnit = getIndexingUnit()
  if (indexingUnit.getOwner().isHumanPlayer() and indexingUnit.isStructure())
    unregisterPlayerTargetStructure(indexingUnit)

// ============================================================================
function onUnitDeath()
  let dyingUnit = GetDyingUnit()
  if (dyingUnit.getOwner().isHumanPlayer() and dyingUnit.isStructure())
    unregisterPlayerTargetStructure(dyingUnit)

// ============================================================================
function onUnitAttacked()
  let attackingUnit = GetAttacker()

  let metadata = attackingUnit.getMetadata()
  if (metadata == null)
    return
  
  let undeadTargetingComponent = metadata.getUndeadTargetingComponent()
  if (undeadTargetingComponent == null)
    return
  
  undeadTargetingComponent.onAttackedUnit(GetAttackedUnitBJ())

// ============================================================================
function populateInitialValidHumanStructureTargets()
  let cond = Condition(function filterUnitIsValidTargetStructure)
  let tempGroup = getGroup()
  for p in g_PlayingHumanPlayers
    let list = g_validHumanStructureTargets.get(p)
    tempGroup.clear()
    tempGroup.enumUnitsOfPlayer(p, cond)
    for u in tempGroup
      list.add(u)
  cond.destr()
  tempGroup.release()

// ============================================================================
function registerTargetedUnit(unit targetedUnit, UndeadTargetingComponent comp)
  HashList<UndeadTargetingComponent> attackerList
  if (g_targetedUnitToUTCMap.has(targetedUnit))
    attackerList = g_targetedUnitToUTCMap.get(targetedUnit)
  else
    attackerList = new HashList<UndeadTargetingComponent>()
    g_targetedUnitToUTCMap.put(targetedUnit, attackerList)
  attackerList.add(comp)

// ============================================================================
function unregisterTargetedUnit(unit targetedUnit, UndeadTargetingComponent comp)
  if (not g_targetedUnitToUTCMap.has(targetedUnit))
    return
  let attackerList = g_targetedUnitToUTCMap.get(targetedUnit)
  attackerList.remove(comp)

// ============================================================================
function unregisterTargetedUnit(unit targetedUnit)
  if (not g_targetedUnitToUTCMap.has(targetedUnit))
    return
  let attackerList = g_targetedUnitToUTCMap.get(targetedUnit)
  g_targetedUnitToUTCMap.remove(targetedUnit)
  for comp in attackerList
    comp.onTargetUnitDied()
  destroy attackerList

// ============================================================================
function applyDOT()
  for _unit in g_dealDOTGroup
    if (_unit != null and _unit.isAlive())
      _unit.subHP(_unit.getMaxHP() * DOT_PERCENT01)

// ============================================================================
function registerUnitAwaitingOrder(unit utcUnit) returns bool
  let didNotContainUnit = not g_awaitingOrderGroup.contains(utcUnit)
  g_awaitingOrderGroup.addUnit(utcUnit)
  return didNotContainUnit and g_awaitingOrderGroup.contains(utcUnit)

// ============================================================================
function unregisterUnitAwaitingOrder(unit utcUnit) returns bool
  let didContainUnit = g_awaitingOrderGroup.contains(utcUnit)
  g_awaitingOrderGroup.removeUnit(utcUnit)
  return didContainUnit and not g_awaitingOrderGroup.contains(utcUnit)

int g_numberOfTimesIssueOrdersStartCalled = 0
int g_numberOfTimesIssueOrdersEndCalled = 0
int g_numberOfOrdersIssued = 0

// ============================================================================
function issueOrders()
  let maxUpdateExecutionCount = MAX_DEFERRED_EXECUTION_COUNT
  var executionCount = 0
 
  g_numberOfTimesIssueOrdersStartCalled++

  // Occasionally we get a unit that has been removed from the game but not from
  // our g_awaitingOrderGroup group. In which case g_awaitingOrderGroup.isEmpty()
  // was returning null since it uses FirstOfGroup() which will return null when
  // one of those ghost units is the first unit in the group. So, we need use
  // refresh() here to get rid of any ghost units.
  if (g_awaitingOrderGroup.isEmpty() and g_awaitingOrderGroup.size() > 0)
    g_awaitingOrderGroup.refresh()

  while (not g_awaitingOrderGroup.isEmpty() and executionCount < maxUpdateExecutionCount)
  //{
    let utcUnit = g_awaitingOrderGroup.getUnitAt(GetRandomInt(0, g_awaitingOrderGroup.size() - 1))
    g_awaitingOrderGroup.removeUnit(utcUnit)
    if (utcUnit != null)
      if (not utcUnit.isAlive())
        if (g_enableUTCLogging)
          Log.debug("UTC", "issueOrders", "", "Unit is dead")
      else
        let metadata = utcUnit.getMetadata()
        if (metadata == null)
          if (g_enableUTCLogging)
            Log.debug("UTC", "issueOrders", "", "Metadata is null")
        else
          let comp = metadata.getUndeadTargetingComponent()
          if (comp == null or not comp.getEnabled())
            if (g_enableUTCLogging)
              Log.debug("UTC", "issueOrders", "", "UTC is null or disabled")
          else
            comp.issueOrderTargetingPlayer_impl()
            executionCount++
            g_numberOfOrdersIssued++
    //}

  g_numberOfTimesIssueOrdersEndCalled++

// ============================================================================
class UTCDebugger extends TLSFrame
  private framehandle m_textArea
  private unit m_selectedUnit

  // --------------------------------------------------------------------------
  construct()
    super(createFrame("FRAME", "UTCDebugger", GAME_UI, "", 0))

  // --------------------------------------------------------------------------
  override function initialize()
    super.initialize()

    let frame = getFrameHandle()
    ..setWidth(0.35)
    ..setHeight(0.4)
    ..setAbsPoint(FRAMEPOINT_TOPLEFT, 0.46, 0.56)
    ..show()

    createFrame("BACKDROP", "UTCDebuggerBackdrop", GAME_UI, "BattleNetControlBackdropTemplate", 0)
    ..setParent(frame)
    ..setAllPoints(frame)

    m_textArea = createFrame("TEXTAREA", "UTCDebuggerTextArea", GAME_UI, "ConsoleTextArea", 0)
    ..setParent(frame)
    ..setAllPoints(frame)

    doPeriodically(0.1) (CallbackPeriodic cb) ->
      update()

  // --------------------------------------------------------------------------
  function setSelectedUnit(unit context)
    m_selectedUnit = context

  // --------------------------------------------------------------------------
  function update()

    if (getFrameHandle().isVisible() == false)
      return

    BlzFrameSetText(m_textArea, "Orders : a:{0}, t:{1}, c:{2}-{3}".format(g_awaitingOrderGroup.size().toString(), g_numberOfOrdersIssued.toString(), g_numberOfTimesIssueOrdersStartCalled.toString(), g_numberOfTimesIssueOrdersEndCalled.toString()))

    if (m_selectedUnit == null)
      BlzFrameAddText(m_textArea, "Selected unit : null")
      return

    BlzFrameAddText(m_textArea, "Selected unit : " + m_selectedUnit.getName())

    let metadata = m_selectedUnit.getMetadata()
    if (metadata == null)
      BlzFrameAddText(m_textArea, "Selected unit metadata is null".colorize(Colors.red))
      return

    let utc = metadata.getUndeadTargetingComponent()
    if (utc == null)
      BlzFrameAddText(m_textArea, "Selected unit UTC is null".colorize(Colors.red))
      return
    
    BlzFrameAddText(m_textArea, "UTC enabled : " + utc.getEnabled().toString())
    BlzFrameAddText(m_textArea, "Target player : " + ((utc.m_targetPlayer != null) ? utc.m_targetPlayer.getName() : "null"))
    BlzFrameAddText(m_textArea, "Target unit : " + ((utc.m_targetUnit != null) ? utc.m_targetUnit.getName() : "null"))
    BlzFrameAddText(m_textArea, "Awaiting Order : " + utc.getIsAwaitingOrder().toString())
    BlzFrameAddText(m_textArea, "Failed Order : " + utc.m_orderFailedReason)
    BlzFrameAddText(m_textArea, "Times Failed Order : " + utc.m_numberOfTimesFailedOrder.toString())
    BlzFrameAddText(m_textArea, "Order : {0} ({1})".format(OrderId2String(GetUnitCurrentOrder(utc.getOwnerUnit())), GetUnitCurrentOrder(utc.getOwnerUnit()).toString()))
    BlzFrameAddText(m_textArea, "In DOT Group : " + utc.getIsInDOTGroup().toString())

    let recycler = m_selectedUnit.getRecycler()
    if (recycler != null)
      BlzFrameAddText(m_textArea, "Active in recycler \"{0}\" : {1}".format(UnitId2String(recycler.getUnitId()), recycler.isUnitActive(m_selectedUnit).toString()))

    if (utc.m_notes.isEmpty() == false)
      BlzFrameAddText(m_textArea, "=== Notes: === ")
      for note in utc.m_notes
        BlzFrameAddText(m_textArea, note)

// ============================================================================
function onIssuedOrder()
  let orderedUnit = GetOrderedUnit()
  let comp = orderedUnit.getUndeadTargetingComponent()
  if (comp == null)
    return
  if (GetTriggerEventId() == EVENT_PLAYER_UNIT_ISSUED_ORDER)
    comp.recordNote("onIssuedOrder", "Issued order: {0} ({1})".format(OrderId2String(orderedUnit.getCurrentOrder()), orderedUnit.getCurrentOrder().toString()))
  if (GetTriggerEventId() == EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER)
    comp.recordNote("onIssuedOrder", "Issued point order: {0} ({1}) -> [{2}, {3}]".format(OrderId2String(orderedUnit.getCurrentOrder()), orderedUnit.getCurrentOrder().toString(), GetOrderPointX().toString(), GetOrderPointY().toString()))
  if (GetTriggerEventId() == EVENT_PLAYER_UNIT_ISSUED_UNIT_ORDER)
    comp.recordNote("onIssuedOrder", "Issued unit order: {0} ({1}) -> {2}".format(OrderId2String(orderedUnit.getCurrentOrder()), orderedUnit.getCurrentOrder().toString(), GetOrderTargetUnit().getName()))

// ============================================================================
init
  g_validHumanStructureTargets = new HashMap<player, LinkedList<unit>>()

  for p in g_PlayingHumanPlayers
    g_validHumanStructureTargets.put(p, new LinkedList<unit>())

  g_validTargetStructureIds = new HashList<int>()
  ..add(TlsUnitIds.barricade1)
  ..add(TlsUnitIds.barricade2)
  ..add(TlsUnitIds.barricade3)
  ..add(TlsUnitIds.barricade4)
  ..add(TlsUnitIds.scoutTower1)
  ..add(TlsUnitIds.scoutTower2)
  ..add(TlsUnitIds.scoutTower3)
  ..add(TlsUnitIds.scoutTower4)
  ..add(TlsUnitIds.scoutTower5)
  ..addAll(g_woodFenceIds)
  ..addAll(g_stoneWallIds)
  ..addAll(g_brickWallIds)
  ..addAll(g_metalWallIds)
  ..addAll(g_allGateIds)

  onUnitIndex(() -> onUnitIndexed())
  onUnitDeindex(() -> onUnitDeindexed())
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_DEATH, function onUnitDeath)
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_ATTACKED, function onUnitAttacked)
  
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_ISSUED_ORDER, function onIssuedOrder)
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER, function onIssuedOrder)
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER, function onIssuedOrder)

  // Populate with initial structures (for debug purposes)
  populateInitialValidHumanStructureTargets()

  doPeriodically(UPDATE_INTERVAL, (CallbackPeriodic cb) -> issueOrders())
  doPeriodically(DOT_INTERVAL, (CallbackPeriodic cb) -> applyDOT())

  if (DEV_ENVIRONMENT)
  //{
    nullTimer() () ->
      g_utcDebugger = new UTCDebugger()

    doPeriodically(1.0) (CallbackPeriodic cb) ->
      let g = getGroup()
      unit selectedUnit = null
      g.enumUnitsSelected(g_HostPlayer, null)
      for u in g
      //{
        if (u.getOwner() == PLAYER_UNDEAD)
          let m = u.getMetadata()
          if (m != null)
            let c1 = m.getUndeadTargetingComponent()
            if (c1 != null)
              selectedUnit = u
      //}
      g.release()
      g_utcDebugger.setSelectedUnit(selectedUnit)
      if (selectedUnit != null)
        g_utcDebugger.show()
      else
        g_utcDebugger.hide()
  //}