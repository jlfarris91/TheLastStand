package CryptFiendComponent
import ClosureEvents
import TlsAbilityIds
import ClosureTimers
import TimerUtils
import GameConstants
import UnitExtensions
import TlsUnitIds
import RealtimeUnitComponent
import AbilityIds
import Vector
import Suspend
import DebuggerDialog
import Host
import PlayerExtensions
import ColorUtility
import ProjectConstants
import Range
import GroupExtensions
import UndeadTargetingComponent
import Math
import Fear

constant real BURROW_SETTLE_DURATION = 1.0
constant real BURROW_TRAVEL_DURATION = 3.0
constant real BURROW_FINALIZE_DURATION = 3.0
constant real array BURROW_CAST_INTERVAL = [ 15.0, 12.5, 10.0 ]
constant rangeReal BURROW_CAST_RANGE = rangeReal(400.0, 1200.0)
constant rangeReal BURROW_CAST_RANGE_SQ = rangeReal(BURROW_CAST_RANGE.min*BURROW_CAST_RANGE.min, BURROW_CAST_RANGE.max*BURROW_CAST_RANGE.max)
constant real BURROW_LIFETIME_TIMER = 5.0

constant int MORPH_ANIM_INDEX = 7
constant real MORPH_ANIM_DURATION = 1.0

constant int STAND_ALTERNATE_ANIM_INDEX = 8

constant int MORPH_ALTERNATE_ANIM_INDEX = 9
constant real MORPH_ALTERNATE_ANIM_DURATION = 1.0

constant int EFFECT_COUNT = 16
constant real EFFECT_SCALE = 0.3
constant colorA EFFECT_COLOR = colorA(150, 150, 150, 255)
constant string EFFECT_PATH = "abilities\\Burrow\\BurrowDirtClump.mdl"
constant real EFFECT_LIFETIME = 1.0

constant group g_tempGroup = CreateGroup()

constant conditionfunc g_burrowTargetFilter = Condition(function isFilterUnitValidBurrowTarget)

constant real FEAR_RANGE = 200.0
constant real FEAR_DURATION = 3.0

enum BurrowState
  Unburrowed
  Burrowing
  Burrowed
  Traveling
  Unburrowing

function BurrowState.toString() returns string
  switch this
    case Unburrowed
      return "Unburrowed"
    case Burrowing
      return "Burrowing"
    case Burrowed
      return "Burrowed"
    case Traveling
      return "Traveling"
    case Unburrowing
      return "Unburrowing"

// ============================================================================
public class CryptFiendComponent extends UnitComponent
  protected bool m_isBurrowing = false
  protected angle m_facingAngle
  protected unit m_targetUnit = null
  protected unit m_dummyUnit = null
  protected CallbackManual m_burrowCastTimer = null
  protected CallbackPeriodic m_burrowTravelTimer = null
  protected BurrowState m_burrowState = Unburrowed
  protected BurrowTravelOperation m_burrowTravelOperation = null

  // --------------------------------------------------------------------------
  construct(IUnitMetadata owner)
    super(owner)

  // --------------------------------------------------------------------------
  ondestroy
    cleanup()

    if (m_burrowTravelOperation != null)
      destroy m_burrowTravelOperation
      m_burrowTravelOperation = null

    if (m_burrowCastTimer != null)
      destroy m_burrowCastTimer
      m_burrowCastTimer = null

  // --------------------------------------------------------------------------
  function getIsBurrowing() returns bool
    return m_isBurrowing

  // --------------------------------------------------------------------------
  override function onEnabled()
    super.onEnabled()

    let ownerUnit = getOwnerUnit()
    var burrowCastInterval = REAL_MAX

    switch (ownerUnit.getTypeId())
      case TlsUnitIds.Undead.fiends[0]
        burrowCastInterval = BURROW_CAST_INTERVAL[0]
      case TlsUnitIds.Undead.fiends[1]
        burrowCastInterval = BURROW_CAST_INTERVAL[1]
      case TlsUnitIds.Undead.fiends[2]
        burrowCastInterval = BURROW_CAST_INTERVAL[2]

    m_burrowCastTimer = getTimer().doManual(burrowCastInterval, true) ->
      burrowToNextTarget()

  // --------------------------------------------------------------------------
  override function onDisabled()
    super.onDisabled()

    cancelBurrow()

  // --------------------------------------------------------------------------
  function burrow(unit targetUnit)
    if (m_isBurrowing)
      return

    m_isBurrowing = true
    m_targetUnit = targetUnit

    m_burrowState = Burrowing

    let ownerUnit = getOwnerUnit()

    m_facingAngle = ownerUnit.getFacingAngle()

    // Pause the unit so that it can't be given any more orders
    ownerUnit.suspend()

    // Make the crypt fiend invulnerable while burrowed
    ownerUnit.addAbility(AbilityIds.invulnerable)

    // Start the burrowing animation
    ownerUnit.setAnimation(MORPH_ANIM_INDEX)

    doAfter(MORPH_ANIM_DURATION, () -> burrow_animationFinished(ownerUnit))
  
  // --------------------------------------------------------------------------
  static function burrow_animationFinished(unit ownerUnit)
    let comp = ownerUnit.getCryptFiendComponent()
    if (comp == null)
      return

    if (comp.isBurrowStillValid() == false)
      comp.cancelBurrow()
      return

    comp.m_burrowState = Burrowed

    // Play the stand alternate animation
    ownerUnit.setAnimation(STAND_ALTERNATE_ANIM_INDEX)
    
    comp.m_burrowTravelOperation = new BurrowTravelOperation(ownerUnit, ownerUnit.getPos(), comp.m_targetUnit)

  // --------------------------------------------------------------------------
  function unburrow()
    if (not m_isBurrowing)
      return

    let ownerUnit = getOwnerUnit()

    // If the target is no longer valid we can unburrow in the current spot
    vec2 targetPos = ownerUnit.getPos()
    
    if (m_targetUnit.isValidBurrowTarget())
      targetPos = m_targetUnit.getPos()

    if (m_dummyUnit != null)
      targetPos = m_dummyUnit.getPos()
      m_dummyUnit.remove()
      m_dummyUnit = null

    m_burrowState = Unburrowing

    // Move the unit to the end position while it's invisible
    ownerUnit.setX(targetPos.x)
    ownerUnit.setY(targetPos.y)
    BlzSetUnitFacingEx(ownerUnit, m_facingAngle.degrees())
    
    // Now that the unit is in the new location play the unburrow animation
    ownerUnit.setAnimation(MORPH_ALTERNATE_ANIM_INDEX)

    // Let the unburrow animation finish
    doAfter(MORPH_ALTERNATE_ANIM_DURATION, () -> unburrow_animationFinished(ownerUnit))

  // --------------------------------------------------------------------------
  static function unburrow_animationFinished(unit ownerUnit)

    // Unpause the unit so that it can continue on with its plans
    ownerUnit.unsuspend()
    
    // Make the crypt fiend vulnerable again
    if (ownerUnit.hasAbility(AbilityIds.invulnerable))
      ownerUnit.removeAbility(AbilityIds.invulnerable)

    let metadata = ownerUnit.getMetadata()
    if (metadata != null)
      let comp = metadata.getCryptFiendComponent()
      let utc = metadata.getUndeadTargetingComponent()
      if (comp != null and utc != null)
        utc.setTargetUnit(comp.m_targetUnit)

    flashEffect("Abilities\\Spells\\Other\\HowlOfTerror\\HowlCaster.mdl", ownerUnit.getPos())

    g_tempGroup.enumUnitsInRange(ownerUnit.getPos(), FEAR_RANGE, g_burrowTargetFilter)
    for u in g_tempGroup
      u.fear(ownerUnit, FEAR_DURATION)

    // Delay cleanup
    doAfter(BURROW_FINALIZE_DURATION, () -> unburrow_finalizeFinished(ownerUnit))

  // --------------------------------------------------------------------------
  static function unburrow_finalizeFinished(unit ownerUnit)
    let comp = ownerUnit.getCryptFiendComponent()
    if (comp == null)
      return

    comp.cleanup()

  // --------------------------------------------------------------------------
  function cancelBurrow()
    if (m_isBurrowing)
      unburrow()

  // --------------------------------------------------------------------------
  function burrowToNextTarget() returns bool
    if (m_isBurrowing)
      return false
    
    let pos = getOwnerUnit().getPos()
    
    g_tempGroup.enumUnitsInRange(pos, BURROW_CAST_RANGE.max, g_burrowTargetFilter)
    var nearestTarget = g_tempGroup.getRandomUnitInRange(pos, BURROW_CAST_RANGE)
    if (nearestTarget == null)

      // Couldn't burrow to a target since the only targets in the group are too close
      // So, just tell the fiend to attack a random unit instead so he doesn't burst down one
      let utc = getOwner().getUndeadTargetingComponent()
      if (utc != null)
        nearestTarget = g_tempGroup.getRandomUnit()
        if (nearestTarget != null)
          utc.setTargetUnit(nearestTarget)

      restartCastTimer()
      return false

    burrow(nearestTarget)
    return true

  // --------------------------------------------------------------------------
  private function isBurrowStillValid() returns bool
    return getOwnerUnit().isAlive() and m_targetUnit != null and m_targetUnit.isValidBurrowTarget()

  // --------------------------------------------------------------------------
  private function restartCastTimer()
    if (m_burrowCastTimer != null)
      m_burrowCastTimer.restart()

  // --------------------------------------------------------------------------
  private function cleanup()
    let ownerUnit = getOwnerUnit()
    if (ownerUnit.isSuspended())
      ownerUnit.unsuspend()
      
    // Make sure the crypt fiend is not invulnerable
    if (ownerUnit.hasAbility(AbilityIds.invulnerable))
      ownerUnit.removeAbility(AbilityIds.invulnerable)
    
    m_burrowState = Unburrowed

    if (m_burrowTravelOperation != null)
      destroy m_burrowTravelOperation
      m_burrowTravelOperation = null

    m_isBurrowing = false
    m_targetUnit = null
    m_facingAngle = angle(0)

    if (m_dummyUnit != null)
      m_dummyUnit.remove()
      m_dummyUnit = null

    restartCastTimer()

// ============================================================================
class BurrowTravelOperation implements IRealtimeListener
  constant real MAX_DIST_SQ = 40.0*40.0
  constant real ARRIVAL_DIST_SQ = 100.0*100.0
  constant real DIST_PER_SEC = 64.0

  protected unit m_fiend
  protected vec2 m_start
  protected vec2 m_curr
  protected unit m_target
  protected vec2 m_vel
  protected vec2 m_lastClumpPos

  // --------------------------------------------------------------------------
  construct (unit fiend, vec2 start, unit target)
    m_fiend = fiend
    m_start = start
    m_curr = start
    m_target = target
    m_vel = ZERO2
    m_lastClumpPos = start

    this.registerForRealtimeUpdate(RealtimeUpdatePriority.Fast)

  // --------------------------------------------------------------------------
  ondestroy
    this.unregisterForRealtimeUpdate()

  // --------------------------------------------------------------------------
  override function realtimeUpdate(real dt)

    if (m_target == null or not m_target.isAlive())
      this.unregisterForRealtimeUpdate()
      doAfter(BURROW_SETTLE_DURATION, () -> delayedUnborrow(m_fiend))
      return

    let targetPos = m_target.getPos()

    let result = smoothDamp(m_curr, targetPos, m_vel, 0.1, 500, dt)
    m_curr = result.value
    m_vel = result.vel

    if (m_lastClumpPos.distanceToSq(m_curr) > MAX_DIST_SQ)
      m_lastClumpPos = m_curr
      createBurrowDirtClump(m_curr, m_curr.angleBetween(targetPos))

    if (m_lastClumpPos.distanceToSq(targetPos) < MAX_DIST_SQ)
      m_lastClumpPos = m_curr
      createBurrowDirtClump(m_curr, m_curr.angleBetween(targetPos))
      this.unregisterForRealtimeUpdate()
      doAfter(BURROW_SETTLE_DURATION, () -> delayedUnborrow(m_fiend))

  // --------------------------------------------------------------------------
  static function delayedUnborrow(unit fiend)
    let comp = fiend.getCryptFiendComponent()
    if (comp != null and comp.getEnabled())
      comp.unburrow()

// ============================================================================
public function unit.getCryptFiendComponent() returns CryptFiendComponent
  if (this == null)
    return null
  let metadata = this.getMetadata()
  if (metadata == null)
    return null
  return metadata.getComponent(CryptFiendComponent.typeId) castTo CryptFiendComponent

// ============================================================================
public function IUnitMetadata.getCryptFiendComponent() returns CryptFiendComponent
  return this.getComponent(CryptFiendComponent.typeId) castTo CryptFiendComponent

// ============================================================================
public function IUnitMetadata.getOrAddCryptFiendComponent() returns CryptFiendComponent
  var component = this.getCryptFiendComponent()
  if (component == null)
    component = this.addComponent(new CryptFiendComponent(this)) castTo CryptFiendComponent
  return component

Vector<BurrowDirtClump> g_activeBurrowClumps = new Vector<BurrowDirtClump>(256)

// ============================================================================
function createBurrowDirtClump(vec2 pos, real yaw) returns BurrowDirtClump
  for clump in g_activeBurrowClumps
    if (not clump.getIsActive())
      clump.reset(pos, yaw)
      return clump
  let clump2 = new BurrowDirtClump()
  clump2.reset(pos, yaw)
  g_activeBurrowClumps.add(clump2)
  return clump2

// ============================================================================
class BurrowDirtClump
  private effect m_effect
  private bool m_isActive

  // --------------------------------------------------------------------------
  construct()
    m_isActive = false

  // --------------------------------------------------------------------------
  ondestroy
    if (m_effect != null)
      m_effect.destr()
      m_effect = null

  // --------------------------------------------------------------------------
  function getIsActive() returns bool
    return m_isActive

  // --------------------------------------------------------------------------
  function reset(vec2 pos, real yaw)
    m_isActive = true

    m_effect = AddSpecialEffect(EFFECT_PATH, pos.x, pos.y)
    ..setScale(EFFECT_SCALE * GetRandomReal(0.9, 1.1))
    ..setColor(EFFECT_COLOR)
    ..setYaw(yaw)
    ..setHeight(0)
    ..setTimeScale(2.0)

    m_effect.setPos(pos.withTerrainZ())

    doAfter(EFFECT_LIFETIME) () ->
      m_effect.destr()
      m_effect = null
      m_isActive = false

// ============================================================================
function unit.isValidBurrowTarget() returns bool
  return this.isAlive() and
         this.isEnemyOf(PLAYER_UNDEAD) and
         not this.isBuilding() and
         not this.isInvulnerable() and
         not this.isTypeOfFiend()

// ============================================================================
function isFilterUnitValidBurrowTarget() returns bool
  return GetFilterUnit().isValidBurrowTarget()

// ============================================================================
function onCryptFiendBurrowCast(unit sender, unit target)
  if (not target.isValidBurrowTarget())
    return
  let metadata = sender.getMetadata()
  if (metadata == null)
    return
  let comp = metadata.getCryptFiendComponent()
  if (comp == null)
    return
  comp.burrow(target)

// ============================================================================
class CFCDebugger extends DebuggerRealtimeUpdateFrame

  // --------------------------------------------------------------------------
  construct()
    super(createFrame("TEXTAREA", "CFC", GAME_UI, "", 0))

  // --------------------------------------------------------------------------
  override function realtimeUpdate(real _)

    let frame = getFrameHandle()

    let selectedUnit = g_HostPlayer.getFirstSelectedUnit()
    if (selectedUnit == null)
      BlzFrameSetText(frame, "Select a unit")
      return

    BlzFrameSetText(frame, "Selected unit : " + selectedUnit.getName())

    let metadata = selectedUnit.getMetadata()
    if (metadata == null)
      BlzFrameAddText(frame, "Selected unit metadata is null".colorize(Colors.red))
      return

    let cfc = metadata.getCryptFiendComponent()
    if (cfc == null)
      BlzFrameAddText(frame, "Selected unit CFC is null".colorize(Colors.red))
      return
    
    frame.addText("Burrowing: " + cfc.m_isBurrowing.toString())
    frame.addText("State: " + cfc.m_burrowState.toString())
    frame.addText("Target unit: " + (cfc.m_targetUnit != null ? cfc.m_targetUnit.getName() : "null"))
    frame.addText("Cast timer: " + (cfc.m_burrowCastTimer != null ? cfc.m_burrowCastTimer.getRemaining().toString() : "null"))
    frame.addText("Dummy unit: " + (cfc.m_dummyUnit != null ? "alive" : "none"))

// ============================================================================
init
  
  if (DEV_ENVIRONMENT)
    DebuggerDialog.registerFrame("CFC", () -> new CFCDebugger())

  EventListener.onTargetCast(TlsAbilityIds.cryptFiendBurrow, (sender, target) -> onCryptFiendBurrowCast(sender, target))