package CryptFiendComponent
import ClosureEvents
import TlsAbilityIds
import UnitAnimations
import ClosureTimers
import Orders
import TimerUtils
import GameConstants
import UnitExtensions
import TargetUtility
import TlsUnitIds
import UnitIds
import UnitObjEditing
import RealtimeUnitComponent
import ObjectIds
import AbilityIds
import Vector
import Suspend
// import GroupUtils
// import Host

constant real BURROW_SETTLE_DURATION = 1.0
constant real BURROW_TRAVEL_DURATION = 3.0
constant real BURROW_FINALIZE_DURATION = 3.0
constant real BURROW_CAST_INTERVAL = 5.0
constant real BURROW_CAST_RANGE_MIN = 200.0
constant real BURROW_CAST_RANGE_MIN_SQ = BURROW_CAST_RANGE_MIN*BURROW_CAST_RANGE_MIN
constant real BURROW_CAST_RANGE_MAX = 800.0
constant real BURROW_LIFETIME_TIMER = 5.0

constant int EFFECT_COUNT = 16
constant real EFFECT_SCALE = 0.3
constant colorA EFFECT_COLOR = colorA(150, 150, 150, 255)
constant string EFFECT_PATH = "abilities\\Burrow\\BurrowDirtClump.mdl"
constant real EFFECT_LIFETIME = 1.0

constant conditionfunc g_burrowTargetFilter = Condition(function isFilterUnitValidBurrowTarget)

enum BurrowState
  Unburrowed
  Burrowing
  Burrowed
  Traveling
  Unburrowing

function BurrowState.toString() returns string
  switch this
    case Unburrowed
      return "Unburrowed"
    case Burrowing
      return "Burrowing"
    case Burrowed
      return "Burrowed"
    case Traveling
      return "Traveling"
    case Unburrowing
      return "Unburrowing"

// ============================================================================
public class CryptFiendComponent extends UnitComponent
  protected bool m_isBurrowing
  protected angle m_facingAngle
  protected unit m_targetUnit
  protected unit m_dummyUnit
  protected CallbackManual m_burrowCastTimer

  protected BurrowState m_burrowState

  // --------------------------------------------------------------------------
  construct(IUnitMetadata owner)
    super(owner)
    m_burrowState = Unburrowed

  // --------------------------------------------------------------------------
  ondestroy
    cleanup()

    if (m_burrowCastTimer != null)
      destroy m_burrowCastTimer
      m_burrowCastTimer = null

  // --------------------------------------------------------------------------
  override function getTypeId() returns int
    return CryptFiendComponent.typeId

  // --------------------------------------------------------------------------
  function getIsBurrowing() returns bool
    return m_isBurrowing

  // --------------------------------------------------------------------------
  override function onEnabled()
    super.onEnabled()

    m_burrowCastTimer = getTimer().doManual(BURROW_CAST_INTERVAL, true) ->
      burrowToNearestTarget()

  // --------------------------------------------------------------------------
  function burrow(unit targetUnit)
    if (m_isBurrowing)
      return

    m_isBurrowing = true
    m_targetUnit = targetUnit

    m_burrowState = Burrowing

    let ownerUnit = getOwnerUnit()

    m_facingAngle = ownerUnit.getFacingAngle()

    // Pause the unit so that it can't be given any more orders
    ownerUnit.suspend()

    // Make the crypt fiend invulnerable while burrowed
    ownerUnit.addAbility(AbilityIds.invulnerable)

    // Start the burrowing animation
    ownerUnit.setAnimation(UnitAnimations.CryptFiend.morph.idx)
    // Log.info("line 118 UnitAnimations.CryptFiend.morph.idx")

    doAfter(UnitAnimations.CryptFiend.morph.duration, () -> burrow_animationFinished(ownerUnit))
  
  // --------------------------------------------------------------------------
  static function burrow_animationFinished(unit ownerUnit)
    let comp = ownerUnit.getCryptFiendComponent()
    if (comp == null)
      return

    if (comp.isBurrowStillValid() == false)
      comp.cancelBurrow()
      return

    comp.m_burrowState = Burrowed

    // Play the stand alternate animation
    ownerUnit.setAnimation(UnitAnimations.CryptFiend.standAlternate.idx)
    // Log.info("line 155 UnitAnimations.CryptFiend.standAlternate.idx")

    comp.m_dummyUnit = createUnit(Player(PLAYER_NEUTRAL_PASSIVE), TlsUnitIds.Undead.cryptFiendBurrowDummy, ownerUnit.getPos(), comp.m_facingAngle)
    comp.m_dummyUnit.issueTargetOrderById(OrderIds.attack, comp.m_targetUnit)
    comp.m_dummyUnit.getMetadataRequired().getCryptFiendDummyComponent()
      ..setCryptFiend(ownerUnit)
      ..setTargetUnit(comp.m_targetUnit)

  // --------------------------------------------------------------------------
  function unburrow()
    if (not m_isBurrowing)
      return

    let ownerUnit = getOwnerUnit()

    // If the target is no longer valid we can unburrow in the current spot
    vec2 targetPos = ownerUnit.getPos()
    
    if (m_targetUnit.isValidBurrowTarget())
      targetPos = m_targetUnit.getPos()

    if (m_dummyUnit != null)
      targetPos = m_dummyUnit.getPos()
      m_dummyUnit.remove()
      m_dummyUnit = null

    m_burrowState = Unburrowing

    // Move the unit to the end position while it's invisible
    ownerUnit.setX(targetPos.x)
    ownerUnit.setY(targetPos.y)
    BlzSetUnitFacingEx(ownerUnit, m_facingAngle.degrees())
    
    // Now that the unit is in the new location play the unburrow animation
    ownerUnit.setAnimation(UnitAnimations.CryptFiend.morphAlternate.idx)

    // Let the unburrow animation finish
    doAfter(UnitAnimations.CryptFiend.morphAlternate.duration, () -> unburrow_animationFinished(ownerUnit))

  // --------------------------------------------------------------------------
  static function unburrow_animationFinished(unit ownerUnit)

    // Unpause the unit so that it can continue on with its plans
    ownerUnit.unsuspend()
    
    // Make the crypt fiend vulnerable again
    if (ownerUnit.hasAbility(AbilityIds.invulnerable))
      ownerUnit.removeAbility(AbilityIds.invulnerable)

    bool issuedOrderToAttackTargetUnit = false
    let metadata = ownerUnit.getMetadata()
    if (metadata != null)
      let comp = metadata.getCryptFiendComponent()
      if (comp != null and comp.m_targetUnit != null and comp.m_targetUnit.isAlive())
        issuedOrderToAttackTargetUnit = ownerUnit.issueTargetOrderById(OrderIds.attack, ownerUnit)

    if (not issuedOrderToAttackTargetUnit)
      ownerUnit.issuePointOrderById(OrderIds.attack, ownerUnit.getPos())

    // Delay cleanup
    doAfter(BURROW_FINALIZE_DURATION, () -> unburrow_finalizeFinished(ownerUnit))

  // --------------------------------------------------------------------------
  static function unburrow_finalizeFinished(unit ownerUnit)
    let comp = ownerUnit.getCryptFiendComponent()
    if (comp == null)
      return

    comp.cleanup()

  // --------------------------------------------------------------------------
  function cancelBurrow()
    if (m_isBurrowing)
      unburrow()

  // --------------------------------------------------------------------------
  function burrowToNearestTarget() returns bool
    if (m_isBurrowing)
      return false
    
    let nearestTarget = getNearestTarget()
    if (nearestTarget == null)
      restartCastTimer()
      return false

    if (nearestTarget.getPos().distanceToSq(getOwnerUnit().getPos()) < BURROW_CAST_RANGE_MIN_SQ)
      restartCastTimer()
      return false

    burrow(nearestTarget)
    return true

  // --------------------------------------------------------------------------
  private function getNearestTarget() returns unit
    return getNearestUnit(getOwnerUnit().getPos(), BURROW_CAST_RANGE_MAX, g_burrowTargetFilter)

  // --------------------------------------------------------------------------
  private function isBurrowStillValid() returns bool
    return getOwnerUnit().isAlive() and m_targetUnit != null and m_targetUnit.isValidBurrowTarget()

  // --------------------------------------------------------------------------
  private function restartCastTimer()
    if (m_burrowCastTimer != null)
      m_burrowCastTimer.restart()

  // --------------------------------------------------------------------------
  private function cleanup()
    let ownerUnit = getOwnerUnit()
    if (ownerUnit.isSuspended())
      ownerUnit.unsuspend()
      
    // Make sure the crypt fiend is not invulnerable
    if (ownerUnit.hasAbility(AbilityIds.invulnerable))
      ownerUnit.removeAbility(AbilityIds.invulnerable)
    
    m_burrowState = Unburrowed

    m_isBurrowing = false
    m_targetUnit = null
    m_facingAngle = angle(0)

    if (m_dummyUnit != null)
      m_dummyUnit.remove()
      m_dummyUnit = null

    restartCastTimer()

// ============================================================================
public function unit.getCryptFiendComponent() returns CryptFiendComponent
  if (this == null)
    return null
  let metadata = this.getMetadata()
  if (metadata == null)
    return null
  return metadata.getComponent(typeInfo(CryptFiendComponent.typeId)) castTo CryptFiendComponent

// ============================================================================
public function IUnitMetadata.getCryptFiendComponent() returns CryptFiendComponent
  return this.getComponent(typeInfo(CryptFiendComponent.typeId)) castTo CryptFiendComponent

// ============================================================================
public function IUnitMetadata.getOrAddCryptFiendComponent() returns CryptFiendComponent
  var component = this.getCryptFiendComponent()
  if (component == null)
    component = this.addComponent(new CryptFiendComponent(this)) castTo CryptFiendComponent
  return component

Vector<BurrowDirtClump> g_activeBurrowClumps = new Vector<BurrowDirtClump>(256)

// ============================================================================
function createBurrowDirtClump(vec2 pos, real yaw) returns BurrowDirtClump
  for clump in g_activeBurrowClumps
    if (not clump.getIsActive())
      clump.reset(pos, yaw)
      return clump
  let clump2 = new BurrowDirtClump()
  clump2.reset(pos, yaw)
  g_activeBurrowClumps.add(clump2)
  return clump2

// ============================================================================
class BurrowDirtClump
  private effect m_effect
  private bool m_isActive

  // --------------------------------------------------------------------------
  construct()
    m_isActive = false

  // --------------------------------------------------------------------------
  ondestroy
    if (m_effect != null)
      m_effect.destr()
      m_effect = null

  // --------------------------------------------------------------------------
  function getIsActive() returns bool
    return m_isActive

  // --------------------------------------------------------------------------
  function reset(vec2 pos, real yaw)
    m_isActive = true

    m_effect = AddSpecialEffect(EFFECT_PATH, pos.x, pos.y)
    ..setScale(EFFECT_SCALE * GetRandomReal(0.9, 1.1))
    ..setColor(EFFECT_COLOR)
    ..setYaw(yaw)
    ..setHeight(0)
    ..setTimeScale(2.0)

    doAfter(EFFECT_LIFETIME) () ->
      m_effect.destr()
      m_effect = null
      m_isActive = false

// ============================================================================
public class CryptFiendDummyComponent extends RealtimeUnitComponent
  private constant real MAX_DIST = 40.0
  private constant real MAX_DIST_SQ = MAX_DIST * MAX_DIST
  private constant real APPROACH_DIST = 64.0
  private constant real APPROACH_DIST_SQ = APPROACH_DIST*APPROACH_DIST

  protected vec2 m_lastPos
  protected unit m_targetUnit
  protected unit m_cryptFiend

  // --------------------------------------------------------------------------
  construct(IUnitMetadata owner)
    super(owner)

  // --------------------------------------------------------------------------
  ondestroy
    m_cryptFiend = null
    m_targetUnit = null

  // --------------------------------------------------------------------------
  override function getTypeId() returns int
    return CryptFiendDummyComponent.typeId

  // --------------------------------------------------------------------------
  function getTargetUnit() returns unit
    return m_targetUnit

  // --------------------------------------------------------------------------
  function setTargetUnit(unit value)
    m_targetUnit = value

  // --------------------------------------------------------------------------
  function getCryptFiendUnit() returns unit
    return m_cryptFiend

  // --------------------------------------------------------------------------
  function setCryptFiend(unit value)
    m_cryptFiend = value

  // --------------------------------------------------------------------------
  function getCryptFiendComponent() returns CryptFiendComponent
    let metadata = m_cryptFiend.getMetadata()
    if (metadata == null)
      return null
    return metadata.getCryptFiendComponent()

  // --------------------------------------------------------------------------
  override function onEnabled()
    super.onEnabled()

    let ownerUnit = getOwnerUnit()

    this.registerForRealtimeUpdate(RealtimeUpdatePriority.Realtime)
    m_lastPos = ownerUnit.getPos()

    // The dummy has a max lifespan
    doAfter(BURROW_LIFETIME_TIMER, () -> destroyDummy(ownerUnit))

    // Log.info("[CFDC] enabled")

  // --------------------------------------------------------------------------
  override function realtimeUpdate(real dt)
    super.realtimeUpdate(dt)

    let ownerUnit = getOwnerUnit()

    if (m_cryptFiend == null or not m_targetUnit.isValidBurrowTarget())
      // Log.info("[CFDC] target is not valid")
      let comp = getCryptFiendComponent()
      if (comp != null)
        comp.cancelBurrow()
      ownerUnit.remove()
      return
    
    // Log.info("[CFDC] current order " + OrderId2String(getOwnerUnit().getCurrentOrder()))

    ownerUnit.issuePointOrderById(OrderIds.move, m_targetUnit.getPos())

    let pos = ownerUnit.getPos()
    let dist = m_lastPos.distanceToSq(pos)
    if (dist > MAX_DIST_SQ)
      m_lastPos = pos
      createBurrowDirtClump(pos, ownerUnit.getFacingAngle().degrees())

    let distToTargetSq = pos.distanceToSq(m_targetUnit.getPos())
    if (distToTargetSq < APPROACH_DIST_SQ)
      // Log.info("[CFDC] reached destination")
      this.unregisterForRealtimeUpdate()
      doAfter(BURROW_SETTLE_DURATION, () -> delayedUnborrow(ownerUnit))
      return

  // --------------------------------------------------------------------------
  private static function delayedUnborrow(unit dummyUnit)
    let metadata = dummyUnit.getMetadata()
    if (metadata != null)
      let comp = metadata.getCryptFiendDummyComponent()
      if (comp != null)
        let cryptFiend = comp.getCryptFiendComponent()
        if (cryptFiend != null)
          cryptFiend.unburrow()
    dummyUnit.remove()

  // --------------------------------------------------------------------------
  private static function destroyDummy(unit dummyUnit)
    let metadata = dummyUnit.getMetadata()
    if (metadata != null)
      let comp = metadata.getCryptFiendDummyComponent()
      if (comp != null)
        let cryptFiend = comp.getCryptFiendComponent()
        if (cryptFiend != null and cryptFiend.getIsBurrowing())
          cryptFiend.cancelBurrow()
    dummyUnit.remove()

// ============================================================================
public function IUnitMetadata.getCryptFiendDummyComponent() returns CryptFiendDummyComponent
  return this.getComponent(typeInfo(CryptFiendDummyComponent.typeId)) castTo CryptFiendDummyComponent

// ============================================================================
public function IUnitMetadata.getOrAddCryptFiendDummyComponent() returns CryptFiendDummyComponent
  var component = this.getCryptFiendDummyComponent()
  if (component == null)
    component = this.addComponent(new CryptFiendDummyComponent(this)) castTo CryptFiendDummyComponent
  return component

// ============================================================================
@compiletime function createDummyUnit()
  new UnitDefinition(TlsUnitIds.Undead.cryptFiendBurrowDummy, UnitIds.locust)
    ..setNormalAbilities(commaList(AbilityIds.locust, AbilityIds.invulnerable, AbilityIds.invisibility))
    ..setModelFile("")
    ..setSpeedBase(400)
    ..setMovementType(MovementType.Fly)
    ..setShadowImageWidth(0)
    ..setShadowImageHeight(0)
    ..setCollisionSize(0)
    ..setAttack1CooldownTime(5)
    ..setAttack1DamageBase(1)
    ..setAttack1Range(32)

// ============================================================================
function unit.isValidBurrowTarget() returns bool
  return this.isAlive() and
         this.isEnemyOf(PLAYER_UNDEAD) and
         not this.isStructure() and
         not this.isInvulnerable() and
         this.getTypeId() != TlsUnitIds.Undead.cryptFiend

// ============================================================================
function isFilterUnitValidBurrowTarget() returns bool
  return GetFilterUnit().isValidBurrowTarget()

// ============================================================================
function onCryptFiendBurrowCast(unit sender, unit target)
  if (not target.isValidBurrowTarget())
    return
  let metadata = sender.getMetadata()
  if (metadata == null)
    return
  let comp = metadata.getCryptFiendComponent()
  if (comp == null)
    return
  comp.burrow(target)

// ============================================================================
init
  EventListener.onTargetCast(TlsAbilityIds.cryptFiendBurrow, (sender, target) -> onCryptFiendBurrowCast(sender, target))

  // doPeriodically(0.25) (CallbackPeriodic cb) ->
  //   let g = getGroup()
  //   g.enumUnitsSelected(g_HostPlayer, null)
  //   for u in g
  //   //{
  //     if (u.getOwner() == PLAYER_UNDEAD)
  //       let m = u.getMetadata()
  //       if (m == null)
  //         Log.info("Metadata is null")
  //       else
  //         let c1 = m.getCryptFiendComponent()
  //         if (c1 == null)
  //           Log.info("CFC is null")
  //         else
  //         //{
  //           Log.info("[CFC] burrowing " + c1.getIsBurrowing().toString() )

  //           if (c1.m_targetUnit != null)
  //             Log.info("[CFC] target unit " + c1.m_targetUnit.getName())
  //           else
  //             Log.info("[CFC] target unit is null")

  //           Log.info("[CFC] state " + c1.m_burrowState.toString())

  //           if (c1.m_dummyUnit != null)
  //             let dummyComp = c1.m_dummyUnit.getMetadataRequired().getCryptFiendDummyComponent()
  //             if (dummyComp != null)
  //               Log.info("[CFDC] pos: " + c1.m_dummyUnit.getPos().toString() + ", lastPos: " + dummyComp.m_lastPos.toString())
  //               if (dummyComp.m_targetUnit != null)
  //                 Log.info("[CFDC] target unit: " + dummyComp.m_targetUnit.getName())
  //               else
  //                 Log.info("[CFDC] target unit is null")

  //             else
  //               Log.info("[CFDC] dummy unit component is null")
  //           else
  //             Log.info("[CFDC] dummy unit is null")

  //         //}
  //   //}
  //   g.release()