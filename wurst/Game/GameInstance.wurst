package GameInstance
import GameSettings
import GameConstants
import HumanPlayers
import HumanPlayerComponent
import Heroes
import ClosureTimers
import BaseUnitsRectProvider
import Time
import RandomWeatherPlayer
import DisplayTextToPlayer
import ColorUtility
import Bases
import Execute
import ErrorHandling
import Range
import PlayerSaveData

import initlater PlayerWaves
import initlater IWaveGenerator
import initlater GameStatsMultiboard
import initlater NightWaveGenerator
import initlater DayWaveGenerator

public GameInstance g_GameInstance = new GameInstance()

constant real TIME_OF_DAY_INITIAL = 5.5
constant real GAME_SPEED_INITIAL = 100.0

//                                           1      2      3      4      5      6      7      8      9     10     11     12     13     14     15     16
constant real array g_dayTodScalars =   [ 50.0,  87.5, 125.0, 125.0, 125.0, 125.0, 125.0, 125.0, 125.0, 125.0, 125.0, 125.0, 125.0, 125.0, 125.0, 125.0]
constant real array g_nightTodScalars = [250.0, 250.0, 250.0, 250.0, 250.0, 250.0, 250.0, 250.0, 250.0, 250.0, 250.0, 250.0, 250.0, 250.0, 250.0, 250.0]

// ============================================================================
public class GameInstance
  private bool m_gracePeriod
  private bool m_updateGracePeriod
  private int m_day
  private int m_night
  private real m_gameDifficulty = 1.0
  private real m_gameSpeedScale = 1.0
  private real m_unscaledTimeOfDaySpeedScale = 1.0
  private PlayerWavesMap m_playerWaves
  private IDayWaveGenerator m_normalDayWaveGenerator
  private IDayWaveGenerator m_hardPlusDayWaveGenerator
  private INightWaveGenerator m_normalNightWaveGenerator
  private INightWaveGenerator m_hardPlusNightWaveGenerator
  private RandomWeatherPlayer m_weatherPlayer
  private time m_startTime
  private time m_endTime
  private bool m_hasStarted = false

  // --------------------------------------------------------------------------
  ondestroy
    destroy m_weatherPlayer

  // --------------------------------------------------------------------------
  function getDay() returns int
    return m_day

  // --------------------------------------------------------------------------
  function getNight() returns int
    return m_night

  // --------------------------------------------------------------------------
  function getDaysSurvived() returns int
    return max(m_night - 1, 0)

  // --------------------------------------------------------------------------
  function getNightsSurvived() returns int
    return max(m_day - 1, 0)

  // --------------------------------------------------------------------------
  function isGracePeriodActive() returns bool
    return m_gracePeriod

  // --------------------------------------------------------------------------
  function setGracePeriodActive(bool value)
    m_gracePeriod = value

  // --------------------------------------------------------------------------
  function setUpdateGracePeriod(bool value)
    m_updateGracePeriod = value

  // --------------------------------------------------------------------------
  function getGameSpeed() returns real
    return m_gameSpeedScale

  // --------------------------------------------------------------------------
  function setGameSpeed(real value)
    if (m_gameSpeedScale != value)
      m_gameSpeedScale = value
      setTimeOfDayScale(m_unscaledTimeOfDaySpeedScale)

  // --------------------------------------------------------------------------
  function setTimeOfDayScale(real value)
    m_unscaledTimeOfDaySpeedScale = value
    SetTimeOfDayScale(m_unscaledTimeOfDaySpeedScale * m_gameSpeedScale)

  // --------------------------------------------------------------------------
  function setTimeOfDayScalePercent(real percent)
    setTimeOfDayScale(percent / 100.0)

  // --------------------------------------------------------------------------
  function getGameDifficulty01() returns real
    return m_gameDifficulty

  // --------------------------------------------------------------------------
  function updateGameDifficulty()
    int alivePlayerCount = 0
    real totalDifficulty = 0.0
    for _player in g_PlayingHumanPlayers
      let metadata = _player.getMetadata()
      let playerComp = metadata.getHumanPlayerComponent()
      if (metadata != null and not metadata.getHasLeftGame() and not metadata.getHasLostGame())
        alivePlayerCount++    
        totalDifficulty += playerComp.getDifficulty()
    if (alivePlayerCount == 0)
      m_gameDifficulty = 1.0
      return
    m_gameDifficulty = totalDifficulty / alivePlayerCount

    updatePlayerTierChances()

  // --------------------------------------------------------------------------
  private function updatePlayerTierChances()
    for _player in g_PlayingHumanPlayers
    //{
      let metadata = _player.getMetadata()
      if (metadata != null and not metadata.getHasLeftGame() and not metadata.getHasLostGame())
      //{
        let playerComp = metadata.getHumanPlayerComponent()
        // let waveDifficulty = metadata.getDifficulty() * 0.7 + m_gameDifficulty * 0.3
        let waveDifficulty = playerComp.getDifficulty()

        // TODO : oh boy this sucks!
        if (waveDifficulty < 1.0)
          playerComp.setTierChance(0, 1)
          playerComp.setTierChance(1, 0)
          playerComp.setTierChance(2, 0)
        else if (waveDifficulty >= 1.0 and waveDifficulty < 3.0)
          let t = rangeReal(1.0, 3.0).parameterize01(waveDifficulty)
          playerComp.setTierChance(0, rangeReal(1.0, 0.0).lerp(t))
          playerComp.setTierChance(1, rangeReal(0.0, 1.0).lerp(t))
          playerComp.setTierChance(2, 0)
        else if (waveDifficulty > 3.0)
          let t = rangeReal(3.0, 5.0).parameterize01(waveDifficulty)
          playerComp.setTierChance(0, 0)
          playerComp.setTierChance(1, rangeReal(1.0, 0.0).lerp(t))
          playerComp.setTierChance(2, rangeReal(0.0, 1.0).lerp(t))
        //}
    //}

  // --------------------------------------------------------------------------
  function getWaves() returns PlayerWavesMap
    return m_playerWaves

  // --------------------------------------------------------------------------
  function getPlayerWaves(player p) returns PlayerWaves
    return m_playerWaves.getOrCreatePlayerWaves(p)

  // --------------------------------------------------------------------------
  function getGameProgress01() returns real
    return getGameTime().parameterize(m_startTime, m_endTime)

  // --------------------------------------------------------------------------
  function startNextDay()
    SetTimeOfDay(TIME_OF_DAY)

  // --------------------------------------------------------------------------
  function startNextNight()
    SetTimeOfDay(TIME_OF_NIGHT)

  // --------------------------------------------------------------------------
  function skipToDay(int day)
    m_day = day - 1
    startNextDay()

  // --------------------------------------------------------------------------
  function skipToNight(int night)
    m_night = night - 1
    startNextNight()

  // --------------------------------------------------------------------------
  function reset()    
    m_day = 0
    m_night = 0
    SetTimeOfDay(TIME_OF_DAY_INITIAL)
    SetTimeOfDayScalePercentBJ(GAME_SPEED_INITIAL)

  // --------------------------------------------------------------------------
  function start()

    m_updateGracePeriod = true

    SetTimeOfDayScale(0.0)
    SetTimeOfDay(TIME_OF_DAY - 0.5)

    m_hasStarted = true

    m_startTime = makeTime(getGameTime().getDay(), TIME_OF_DAY.floor(), 0)
    m_endTime = m_startTime + makeTimespan(TOTAL_NIGHTS, 0, 0)

    // These should move to a place that sets up the GameInstance
    execute() () ->
      m_normalDayWaveGenerator = new NormalDayWaveGenerator()
      
    execute() () ->
      m_hardPlusDayWaveGenerator = new HardPlusDayWaveGenerator()
    
    execute() () ->
      m_normalNightWaveGenerator = new NormalNightWaveGenerator()
      
    execute() () ->
      m_hardPlusNightWaveGenerator = new HardPlusNightWaveGenerator()

    m_weatherPlayer = new RandomWeatherPlayer()

    m_weatherPlayer.start()

    updateGameDifficulty()

    initializeGeneral()
    initializeAlliances()
    initializeWaves()

    doAfter(1.0) ->
      postStart()

  // --------------------------------------------------------------------------
  function complete()

    m_weatherPlayer.stop()

    destroy m_playerWaves
    m_playerWaves = null

    if (m_normalNightWaveGenerator != null)
      destroy m_normalNightWaveGenerator
      m_normalNightWaveGenerator = null

    if (m_hardPlusNightWaveGenerator != null)
      destroy m_hardPlusNightWaveGenerator
      m_hardPlusNightWaveGenerator = null

    if (m_normalDayWaveGenerator != null)
      destroy m_normalDayWaveGenerator
      m_normalDayWaveGenerator = null

    if (m_hardPlusDayWaveGenerator != null)
      destroy m_hardPlusDayWaveGenerator
      m_hardPlusDayWaveGenerator = null

  // --------------------------------------------------------------------------
  private function postStart()
    for p in g_PlayingHumanPlayers
      initializePlayer(p)
      showPlayerBases(p, 60.0)

  // --------------------------------------------------------------------------
  private function initializePlayer(player p)
    
    spawnInitialPlayerUnitsAtRandomPoint(p, true)

    // Create a visible region around the base units
    createVision(p, getBaseUnitsRect(), false)

    p.setGold(GameSettings.startingGold)
    p.setLumber(GameSettings.startingMaterials)

    // Initialize camera settings
    SetCameraFieldForPlayer(p, CAMERA_FIELD_FARZ, CAMERA_FARZ, 0.0)

  // --------------------------------------------------------------------------
  function updateGracePeriod()
    let wasGracePeriod = m_gracePeriod
    m_gracePeriod = m_day < GRACE_PERIOD_END_DAY
    
    doAfter(3.0) () ->
    //{
      if (m_gracePeriod)
        if (m_day == GRACE_PERIOD_END_DAY - 1)
          displayMessageToPlayers("Grace period ends tomorrow!".colorize(COLOR_GOLD))
        else
          displayMessageToPlayers("Grace period ends in {0} days!".format((GRACE_PERIOD_END_DAY - m_day).toString()).colorize(COLOR_GOLD))
      else if (wasGracePeriod)
        displayMessageToPlayers("Grace period has ended. Hero death is now permanent.".colorize(COLOR_GOLD))
    //}

  // --------------------------------------------------------------------------
  function startDay()
    if (not m_hasStarted)
      return

    m_day++

    Log.debug("Starting day {0}...".format(m_day.toString()))

    if (GameSettings.allowRespawn and m_gracePeriod)
      respawnDeadPlayers()

    if (m_updateGracePeriod)
      updateGracePeriod()

    // Show the player's multiboards on day 1
    if (m_day == 1)
      showMultiboardsForPlayers()

    doAfter(0.1, () -> setTimeOfDayScalePercent(g_dayTodScalars[m_day]))

    // Start day waves for players
    for p in g_PlayingHumanPlayers
      let waves = m_playerWaves.getOrCreatePlayerWaves(p)
      Log.debug("Starting day wave {0} for player {1}".format(m_day.toString(), p.getName()))
      waves.getRunner().startDayWave(m_day)

    Log.debug("Day {0} started.".format(m_day.toString()))

    // End the game
    if (m_day > TOTAL_NIGHTS)
      doAfter(30.0) () ->
        setTimeOfDayScale(0.0)
        for p in g_PlayingHumanPlayers
          if (p.getMetadata().getHasLostGame())
            CustomDefeatBJ( p, "You lose. Better luck next time!" )
          else
            PlayerSaveData.save(p)

  // --------------------------------------------------------------------------
  function showMultiboardsForPlayers()
    for _player in g_PlayingHumanPlayers
      new GameStatsMultiboard(_player).show()
  
    if (PLAYER_SPECTATOR.isPlayingHumanPlayer())
      new GameStatsMultiboard(PLAYER_SPECTATOR).show()

  // --------------------------------------------------------------------------
  function startNight()

    if (not m_hasStarted)
      return

    m_night++

    Log.debug("Starting night {0}...".format(m_night.toString()))

    doAfter(0.1, () -> setTimeOfDayScalePercent(g_nightTodScalars[m_night]))

    // Start night waves for players
    for p in g_PlayingHumanPlayers
      let waves = m_playerWaves.getOrCreatePlayerWaves(p)
      Log.debug("Starting night wave {0} for player {1}".format(m_night.toString(), p.getName()))
      waves.getRunner().startNightWave(m_night)

    Log.debug("Night {0} started.".format(m_night.toString()))

  // --------------------------------------------------------------------------
  private function respawnDeadPlayers()
    for p in g_PlayingHumanPlayers
      if (p.getHumanPlayerComponent().getIsHeroDead())
        spawnInitialPlayerUnitsAtRandomPoint(p, false)

  // --------------------------------------------------------------------------
  private function initializeGeneral()
    EnableMinimapFilterButtons(true, false)
    SetPlayerFlagBJ(PLAYER_STATE_GIVES_BOUNTY, true, PLAYER_UNDEAD)
    CameraSetSmoothingFactor(5.0)
    SetCreepCampFilterState(false)
    SetTimeOfDayScalePercentBJ(GAME_SPEED_INITIAL)
    SetTimeOfDay(TIME_OF_DAY_INITIAL)

    // Tells the AI to not use guard positions?
    RemoveAllGuardPositions(PLAYER_UNDEAD)
    
    FogEnableOn()
    FogMaskEnableOff()
    
    createFogOfWar(PLAYER_UNDEAD, GetPlayableMapRect(), false, false).start()
    createBlackMask(PLAYER_UNDEAD, GetPlayableMapRect(), false, false).start()

    initializeSpectator()

    // We control experience gain manually
    for p in g_HumanPlayers
      SetPlayerHandicapXPBJ(p, 0.00)

  // --------------------------------------------------------------------------
  private function initializeWaves()
    m_playerWaves = new PlayerWavesMap()

    Log.debug("Generating waves...")

    for p in g_PlayingHumanPlayers
      generateWavesForPlayer(p)

    Log.debug("Done generating waves.")

  // --------------------------------------------------------------------------
  private function generateWavesForPlayer(player _player) returns bool
    if (_player == null)
      argumentNullError("_player")

    let playerWaves = m_playerWaves.getOrCreatePlayerWaves(_player)
    let playerDifficulty = _player.getHumanPlayerComponentRequired().getDifficulty()
    let playerNightWaveGenerator = getNightWaveGenerator(playerDifficulty)
    let playerDayWaveGenerator = getDayWaveGenerator(playerDifficulty)

    execute() () ->
      Log.debug("Generating night waves for player " + _player.getName() + " ...")
      let nightWaves = playerWaves.getNightWaves()
      playerNightWaveGenerator.generateWavesForPlayer(_player, nightWaves)

    execute() () ->
      Log.debug("Generating day waves for player " + _player.getName() + " ...")
      let dayWaves = playerWaves.getDayWaves()
      playerDayWaveGenerator.generateWavesForPlayer(_player, dayWaves)

    return true

  // --------------------------------------------------------------------------
  private function getNightWaveGenerator(real difficulty) returns INightWaveGenerator
    if (difficulty.floor() == 1)
      return m_normalNightWaveGenerator
    else
      return m_hardPlusNightWaveGenerator

  // --------------------------------------------------------------------------
  private function getDayWaveGenerator(real difficulty) returns IDayWaveGenerator
    if (difficulty.floor() == 1)
      return m_normalDayWaveGenerator
    else
      return m_hardPlusDayWaveGenerator

  // --------------------------------------------------------------------------
  private function initializeAlliances()  
    for p in g_HumanPlayers
      // Make player treat undead as an enemy
      SetPlayerAllianceStateBJ(p, PLAYER_UNDEAD, bj_ALLIANCE_UNALLIED)
      // Make undead treat player as an enemy
      SetPlayerAllianceStateBJ(PLAYER_UNDEAD, p, bj_ALLIANCE_UNALLIED )
      // Make player treat villagers as neutral
      SetPlayerAllianceStateBJ(p, PLAYER_VILLAGERS, bj_ALLIANCE_NEUTRAL )
      // Make villagers treat player as neutral
      SetPlayerAllianceStateBJ(PLAYER_VILLAGERS, p, bj_ALLIANCE_NEUTRAL )
      // Make player treat lootables as neutral
      SetPlayerAllianceStateBJ(p, PLAYER_LOOTABLES, bj_ALLIANCE_NEUTRAL )
      // Make lootables treat player as neutral
      SetPlayerAllianceStateBJ(PLAYER_LOOTABLES, p, bj_ALLIANCE_NEUTRAL )
      // Make player treat raiders as an enemy
      SetPlayerAllianceStateBJ(p, PLAYER_UNDEAD, bj_ALLIANCE_UNALLIED)
      // Make raiders treat player as an enemy
      SetPlayerAllianceStateBJ(PLAYER_UNDEAD, p, bj_ALLIANCE_UNALLIED)
      // Make player treat the spectator as neutral
      SetPlayerAllianceStateBJ(p, PLAYER_SPECTATOR, bj_ALLIANCE_NEUTRAL )
      // Make the spectator treat player as neutral
      SetPlayerAllianceStateBJ(PLAYER_SPECTATOR, p, bj_ALLIANCE_NEUTRAL )

  // --------------------------------------------------------------------------
  private function initializeSpectator()
    createVision(PLAYER_SPECTATOR, GetPlayableMapRect(), false).start()

    displayMessageToPlayer(PLAYER_SPECTATOR, "You are spectating")

    // Make player treat villagers as neutral
    SetPlayerAllianceStateBJ(PLAYER_SPECTATOR, PLAYER_VILLAGERS, bj_ALLIANCE_NEUTRAL )
    // Make villagers treat player as neutral
    SetPlayerAllianceStateBJ(PLAYER_VILLAGERS, PLAYER_SPECTATOR, bj_ALLIANCE_NEUTRAL )

    // Make player treat lootables as neutral
    SetPlayerAllianceStateBJ(PLAYER_SPECTATOR, PLAYER_LOOTABLES, bj_ALLIANCE_NEUTRAL )
    // Make lootables treat player as neutral
    SetPlayerAllianceStateBJ(PLAYER_LOOTABLES, PLAYER_SPECTATOR, bj_ALLIANCE_NEUTRAL )

// ============================================================================
function onDayStart()
  // Wait to allow Waves and SpawnWaves to complete
  nullTimer(() -> g_GameInstance.startDay())

// ============================================================================
function onNightStart()
  // Wait to allow Waves and SpawnWaves to complete
  nullTimer(() -> g_GameInstance.startNight())

// ============================================================================
init
  registerDayEvent(function onDayStart)
  registerNightEvent(function onNightStart)
