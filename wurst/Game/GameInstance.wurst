package GameInstance
import GameSettings
import GameConstants
import HumanPlayers
import HumanPlayerComponent
import ClosureTimers
import BaseUnitsRectProvider
import Time
import RandomWeatherPlayer
import DisplayTextToPlayer
import ColorUtility
import PlayerSaveData
import Math
import SmartValue
import GameProperties
import Dialog
import GroupUtils
import TlsUnitIds
import ErrorHandling
import UnitMetadata
import Orders
import TlsItemIds
import InvulnerableComponent
import Spawning
import PlayerSetup
import ItemType
import PlayerSpawnPointProviders
import Difficulties
import Events
import RegisterEvents

public GameInstance g_GameInstance = new GameInstance()

// ============================================================================
public class GameInstance
  private bool m_gracePeriod
  private bool m_updateGracePeriod
  private int m_day = 0
  private real m_averagePlayerDifficulty = 1.0
  private RandomWeatherPlayer m_weatherPlayer
  private time m_startTime
  private time m_endTime
  private bool m_hasStarted = false
  private bool m_spawnPedestals = false
  private Event m_gameStartedEvent = null

  // --------------------------------------------------------------------------
  ondestroy
    destroy m_weatherPlayer

    if (m_gameStartedEvent != null)
      destroy m_gameStartedEvent
      m_gameStartedEvent = null

  // --------------------------------------------------------------------------
  function now() returns time
    let tod = GetTimeOfDay()
    return makeTime(m_day + (tod < TIME_OF_DAY ? 1 : 0), tod)

  // --------------------------------------------------------------------------
  function getDay() returns int
    return max(m_day, 0)

  // --------------------------------------------------------------------------
  function getDaysSurvived() returns real
    var days = m_day - 1.0
    let thisMorning = makeTime(m_day, TIME_OF_DAY)
    let tonight = makeTime(m_day, TIME_OF_NIGHT)
    days += clamp01(now().parameterize(thisMorning, tonight))
    return days

  // --------------------------------------------------------------------------
  function getNight() returns int
    return getDay()

  // --------------------------------------------------------------------------
  function getNightsSurvived() returns real
    var nights = m_day - 1.0
    let lastNight = makeTime(m_day, TIME_OF_NIGHT)
    let tomorrowMorning = makeTime(m_day + 1, TIME_OF_DAY)
    nights += clamp01(now().parameterize(lastNight, tomorrowMorning))
    return nights

  // --------------------------------------------------------------------------
  function getBossesSurvived() returns int
    return (getDay() / 5).floor()

  // ----------------------------------------------------------------------------
  function getTODScale() returns real
    return g_GameProperties.getProperty(GameProperty.TOD_SCALE).getValue()

  // --------------------------------------------------------------------------
  function isGracePeriodActive() returns bool
    return m_gracePeriod

  // --------------------------------------------------------------------------
  function setGracePeriodActive(bool value)
    m_gracePeriod = value

  // --------------------------------------------------------------------------
  function setUpdateGracePeriod(bool value)
    m_updateGracePeriod = value

  // --------------------------------------------------------------------------
  function getWorldDifficulty() returns real
    return m_averagePlayerDifficulty

  // --------------------------------------------------------------------------
  function updateWorldDifficulty()
    int alivePlayerCount = 0
    real totalDifficulty = 0.0
    
    for _player in g_PlayingHumanPlayers
    //{
      let metadata = _player.getMetadata()
      let playerComp = metadata.getHumanPlayerComponent()
      if (metadata != null and _player.isIngame() and not metadata.getHasLostGame())
        alivePlayerCount++    
        totalDifficulty += playerComp.getDifficulty()
    //}

    m_averagePlayerDifficulty = alivePlayerCount != 0 ? totalDifficulty / alivePlayerCount : 1.0

    updatePlayerTierChances()

  // --------------------------------------------------------------------------
  function getWorldDifficultyCoeff() returns real
    return getGeneralDifficultyCoeff(getWorldDifficulty(), g_PlayingHumanPlayerCount)

  // --------------------------------------------------------------------------
  function getPlayerDifficulty(player p) returns real
    return p.getHumanPlayerComponentRequired().getDifficulty()

  // --------------------------------------------------------------------------
  function getPlayerDifficultyCoeff(player p) returns real
    let playerDifficulty = getPlayerDifficulty(p)
    return getPlayerDifficultyCoeff(playerDifficulty)

  // --------------------------------------------------------------------------
  function getPlayerDifficultyCoeff(real playerDifficulty) returns real
    return getGeneralDifficultyCoeff(playerDifficulty, 1)

  // --------------------------------------------------------------------------
  function getGameProgressCoeff() returns real
    return (getDaysSurvived() * 0.5 + getNightsSurvived()) * 0.5

  // --------------------------------------------------------------------------
  function getGeneralDifficultyCoeff(real difficulty, int playerCount) returns real
    return DifficultyScaling.getGeneralDifficultyCoeff(getGameProgressCoeff(), difficulty, playerCount)

  // --------------------------------------------------------------------------
  private function updatePlayerTierChances()
    // for _player in g_PlayingHumanPlayers
    // //{
    //   let metadata = _player.getMetadata()
    //   if (metadata != null and _player.isIngame() and not metadata.getHasLostGame())
    //   //{
    //     let playerComp = metadata.getHumanPlayerComponent()
    //     let waveDifficulty = playerComp.getDifficulty()
        
    //     let d = clamp(waveDifficulty.floor(), 0, NUM_TIER_CHANCES-1)
    //     let d2 = clamp(d + 1, 0, NUM_TIER_CHANCES-1)
    //     let t = waveDifficulty - d

    //     playerComp.setTierWeight(0, lerp(TIER_1_CHANCES[d], TIER_1_CHANCES[d2], t))
    //     playerComp.setTierWeight(1, lerp(TIER_2_CHANCES[d], TIER_2_CHANCES[d2], t))
    //     playerComp.setTierWeight(2, lerp(TIER_3_CHANCES[d], TIER_3_CHANCES[d2], t))
    // //}

  // --------------------------------------------------------------------------
  function getGameProgress() returns real
    return getDaysSurvived() + getNightsSurvived()

  // --------------------------------------------------------------------------
  function getSpawnPedestals() returns bool
    return m_spawnPedestals

  // --------------------------------------------------------------------------
  function startNextDay()
    SetTimeOfDay(TIME_OF_DAY)

  // --------------------------------------------------------------------------
  function startNextNight()
    SetTimeOfDay(TIME_OF_NIGHT)

  // --------------------------------------------------------------------------
  function skipToDay(int day)
    m_day = day - 1
    startNextDay()

  // --------------------------------------------------------------------------
  function skipToNight(int night)
    m_day = night
    startNextNight()

  // --------------------------------------------------------------------------
  function reset()
    m_day = 0
    SetTimeOfDay(TIME_OF_DAY_INITIAL)
    g_GameProperties.setTODScale(TOD_SCALE_INITIAL)

  // --------------------------------------------------------------------------
  function start()

    m_updateGracePeriod = true
    m_spawnPedestals = true

    g_GameProperties.setTODScale(0.0)
    SetTimeOfDay(TIME_OF_DAY - 0.5)

    m_hasStarted = true

    m_startTime = makeTime(getGameTime().getDay(), TIME_OF_DAY.floor(), 0)
    m_endTime = m_startTime + makeTimespan(TOTAL_NIGHTS, 0, 0)

    m_weatherPlayer = new RandomWeatherPlayer()

    m_weatherPlayer.start()

    updateWorldDifficulty()

    initializeGeneral()
    initializeAlliances()

    doAfter(1.0) ->
      postStart()

  // ----------------------------------------------------------------------------
  function onTODScaleValueChanged()

  // --------------------------------------------------------------------------
  function complete()
    m_weatherPlayer.stop()

  // --------------------------------------------------------------------------
  private function postStart()
    for p in g_PlayingHumanPlayers
      initializePlayer(p)

    if (m_gameStartedEvent != null)
      m_gameStartedEvent.call()

  // --------------------------------------------------------------------------
  function onGameStarted() returns IEvent
    if (m_gameStartedEvent == null)
      m_gameStartedEvent = new Event()
    return m_gameStartedEvent

  // --------------------------------------------------------------------------
  private function initializePlayer(player p)
    
    spawnWispForPlayer(p)

    // Create a visible region around the base units
    createVision(p, getBaseUnitsRect(), false)

    p.setGold(GameSettings.startingGold)
    p.setLumber(GameSettings.startingLumber)

    // Initialize camera settings
    SetCameraFieldForPlayer(p, CAMERA_FIELD_FARZ, CAMERA_FARZ, 0.0)

  // --------------------------------------------------------------------------
  function updateGracePeriod()
    let wasGracePeriod = m_gracePeriod
    m_gracePeriod = m_day < GRACE_PERIOD_END_DAY
    
    doAfter(3.0) () ->
    //{
      if (m_gracePeriod)
        if (m_day == GRACE_PERIOD_END_DAY - 1)
          displayMessageToPlayers("Grace period ends tomorrow!".colorize(COLOR_GOLD))
        else
          displayMessageToPlayers("Grace period ends in {0} days!".format((GRACE_PERIOD_END_DAY - m_day).toString()).colorize(COLOR_GOLD))
      else if (wasGracePeriod)
        displayMessageToPlayers("Grace period has ended. Hero death is now permanent.".colorize(COLOR_GOLD))
    //}

  // --------------------------------------------------------------------------
  function startDay()
    if (not m_hasStarted)
      return

    m_day++

    Log.debug("Starting day {0}...".format(m_day.toString()))

    if (GameSettings.allowRespawn and m_gracePeriod)
      respawnDeadPlayers()

    if (m_updateGracePeriod)
      updateGracePeriod()

    g_GameProperties.getProperty(GameProperty.TOD_SCALE).setBase(TOD_DAY_SCALARS[m_day - 1])

    // Start day waves for players
    // for p in g_PlayingHumanPlayers
    //   let waves = m_playerWaves.getOrCreatePlayerWaves(p)
    //   Log.debug("Starting day wave {0} for player {1}".format(m_day.toString(), p.getName()))
    //   waves.getRunner().startDayWave(m_day)

    Log.debug("Day {0} started.".format(m_day.toString()))

    // End the game
    if (m_day > TOTAL_NIGHTS)
    //{
      g_GameProperties.setTODScale(0.0)
      doAfter(30.0) () ->
        for p in g_PlayingHumanPlayers
        //{
          PlayerSaveData.save(p, true)
          
          let d = DialogCreate()
          d.setMessage(p.getMetadata().getHasLostGame() ? "You lose. Better luck next time!" : "You win!")
          d.addButton("OK")
          d.display(p, true)
        //}
    //}

  // --------------------------------------------------------------------------
  function startNight()

    if (not m_hasStarted)
      return

    m_spawnPedestals = false

    let temp = getGroup()
    temp.enumUnitsOfType(TlsUnitIds.pedestal, null)
    for u in temp
      u.remove()
    temp.release()

    let night = getNight()

    Log.debug("Starting night {0}...".format(night.toString()))

    g_GameProperties.getProperty(GameProperty.TOD_SCALE).setBase(TOD_NIGHT_SCALARS[night - 1])

    // Start night waves for players
    // for p in g_PlayingHumanPlayers
    //   let waves = m_playerWaves.getOrCreatePlayerWaves(p)
    //   Log.debug("Starting night wave {0} for player {1}".format(m_night.toString(), p.getName()))
    //   waves.getRunner().startNightWave(m_night)

    Log.debug("Night {0} started.".format(night.toString()))

  // --------------------------------------------------------------------------
  private function respawnDeadPlayers()
    for p in g_PlayingHumanPlayers
      if (p.getHumanPlayerComponent().getIsHeroDead())
        respawnHeroForPlayer(p)

  // --------------------------------------------------------------------------
  private function initializeGeneral()
    EnableMinimapFilterButtons(true, false)
    SetPlayerFlagBJ(PLAYER_STATE_GIVES_BOUNTY, true, PLAYER_UNDEAD)
    CameraSetSmoothingFactor(5.0)
    SetCreepCampFilterState(false)

    g_GameProperties.setTODScale(TOD_SCALE_INITIAL)
    SetTimeOfDay(TIME_OF_DAY_INITIAL)

    // Tells the AI to not use guard positions?
    RemoveAllGuardPositions(PLAYER_UNDEAD)
    
    FogEnableOn()
    FogMaskEnableOff()
    
    // Undead should have no vision
    // CreateFogModifierRectBJ(true, PLAYER_UNDEAD, FOG_OF_WAR_VISIBLE, GetPlayableMapRect())

    initializeSpectator()

    // We control experience gain manually
    for p in g_HumanPlayers
      SetPlayerHandicapXPBJ(p, 0.00)

  // --------------------------------------------------------------------------
  private function initializeAlliances()  
    for p in g_HumanPlayers
      // Make player treat undead as an enemy
      SetPlayerAllianceStateBJ(p, PLAYER_UNDEAD, bj_ALLIANCE_UNALLIED)
      // Make undead treat player as an enemy
      SetPlayerAllianceStateBJ(PLAYER_UNDEAD, p, bj_ALLIANCE_UNALLIED )
      // Make player treat villagers as neutral
      SetPlayerAllianceStateBJ(p, PLAYER_VILLAGERS, bj_ALLIANCE_NEUTRAL )
      // Make villagers treat player as neutral
      SetPlayerAllianceStateBJ(PLAYER_VILLAGERS, p, bj_ALLIANCE_NEUTRAL )
      // Make player treat lootables as neutral
      SetPlayerAllianceStateBJ(p, PLAYER_LOOTABLES, bj_ALLIANCE_NEUTRAL )
      // Make lootables treat player as neutral
      SetPlayerAllianceStateBJ(PLAYER_LOOTABLES, p, bj_ALLIANCE_NEUTRAL )
      // Make player treat raiders as an enemy
      SetPlayerAllianceStateBJ(p, PLAYER_UNDEAD, bj_ALLIANCE_UNALLIED)
      // Make raiders treat player as an enemy
      SetPlayerAllianceStateBJ(PLAYER_UNDEAD, p, bj_ALLIANCE_UNALLIED)
      // Make player treat the spectator as neutral
      SetPlayerAllianceStateBJ(p, PLAYER_SPECTATOR, bj_ALLIANCE_NEUTRAL )
      // Make the spectator treat player as neutral
      SetPlayerAllianceStateBJ(PLAYER_SPECTATOR, p, bj_ALLIANCE_NEUTRAL )

  // --------------------------------------------------------------------------
  private function initializeSpectator()
    createVision(PLAYER_SPECTATOR, GetPlayableMapRect(), false).start()

    displayMessageToPlayer(PLAYER_SPECTATOR, "You are spectating")

    // Make player treat villagers as neutral
    SetPlayerAllianceStateBJ(PLAYER_SPECTATOR, PLAYER_VILLAGERS, bj_ALLIANCE_NEUTRAL )
    // Make villagers treat player as neutral
    SetPlayerAllianceStateBJ(PLAYER_VILLAGERS, PLAYER_SPECTATOR, bj_ALLIANCE_NEUTRAL )

    // Make player treat lootables as neutral
    SetPlayerAllianceStateBJ(PLAYER_SPECTATOR, PLAYER_LOOTABLES, bj_ALLIANCE_NEUTRAL )
    // Make lootables treat player as neutral
    SetPlayerAllianceStateBJ(PLAYER_LOOTABLES, PLAYER_SPECTATOR, bj_ALLIANCE_NEUTRAL )

// ============================================================================
public function spawnHeroForPlayer(player p, vec2 pos, bool firstTime) returns unit
  let playerMetadata = p.getMetadata()
  let playerComp = playerMetadata.getHumanPlayerComponent()

  unit hero = playerComp.getHero()
  let firstTimeSpawned = hero == null

  // This is the first time the hero has been spawned for the player
  // new hero metadata will be automatically generated
  if (firstTimeSpawned)
    hero = createUnitTLS(p, playerComp.getHeroTypeId(), pos, 270.0.asAngleDegrees())
    PlayerSetup.getSetupForPlayer(p).setupHero(hero)
  else
    hero.revive(pos, false)

  // Reset player's camera to look at new hero
  if (not firstTime and p == localPlayer)
    PanCameraToTimedForPlayer(p, pos.x, pos.y, 0)
  
  SelectUnitForPlayerSingle(hero, p)

  // Set player name back to normal if they were deceased
  playerMetadata.resetDisplayName()

  // Give starting items
  if (playerComp.getHeadquarters() == null)
    ItemType.createItemForUnit(TlsItemIds.headquarters1, hero)

  if (firstTimeSpawned)
    ItemType.createItemForUnit(TlsItemIds.flintAndTinder, hero)

  // Make hero invulnerable for a short period of time
  if (not firstTime)
    hero.makeInvulnerable(HERO_RESPAWN_INVULNERABLE_DURATION)

  return hero

// ============================================================================
public function respawnHeroForPlayer(player p)
  let sp = getDynamicFriendlySpawnPointProvider(p).getRandomSpawnPointInPlayableMap()
  if (not sp.succeeded)
    error("Could not find a safe spawn point to spawn hero for player " + p.getName())
    return

  respawnHeroForPlayer(p, sp.spawnPoint)

// ============================================================================
public function respawnHeroForPlayer(player p, vec2 pos)
  let playerMetadata = p.getMetadata()
  let playerComp = playerMetadata.getHumanPlayerComponent()

  let hero = playerComp.getHero()
  if (hero == null or hero.isAlive())
    // hero hasn't been spawned yet or is still alive
    return

  hero.revive(pos, false)

  // Reset player's camera to look at new hero
  if (p == localPlayer)
    PanCameraToTimedForPlayer(p, pos.x, pos.y, 0)
  
  SelectUnitForPlayerSingle(hero, p)

  // Set player name back to normal if they were deceased
  playerMetadata.resetDisplayName()

  // Make hero invulnerable for a short period of time
  hero.makeInvulnerable(HERO_RESPAWN_INVULNERABLE_DURATION)

// ============================================================================
function spawnWispForPlayer(player p)
  let sp = getDynamicFriendlySpawnPointProvider(p).getRandomSpawnPointInPlayableMap()
  if (not sp.succeeded)
    error("Could not find a safe spawn point to spawn hero for player " + p.getName())
    return

  spawnWispForPlayer(p, sp.spawnPoint)

// ============================================================================
function spawnWispForPlayer(player p, vec2 pos)

  let wisp = createUnitTLS(p, TlsUnitIds.wisp, pos, 270.0.asAngleDegrees())
  SelectUnitForPlayerSingle(wisp, p)

  // Reset player's camera to look at new hero
  if (p == localPlayer)
    PanCameraToTimedForPlayer(p, pos.x, pos.y, 0)

// ============================================================================
function spawnInitialSurvivorsForPlayer(player p, unit hero)
  let pos = hero.getPos()
  for i = 1 to GameSettings.startingSurvivors
    let survivor = createUnitTLS(p, TlsUnitIds.Survivors.survivorMale, pos, GetRandomDirectionDeg().asAngleDegrees())
    survivor.issueTargetOrderById(OrderIds.move, hero)

// ============================================================================
function onDayStart()
  // Wait to allow Waves and SpawnWaves to complete
  nullTimer(() -> g_GameInstance.startDay())

// ============================================================================
function onNightStart()
  // Wait to allow Waves and SpawnWaves to complete
  nullTimer(() -> g_GameInstance.startNight())

// ============================================================================
function onUnitKilled()
  let dyingUnit = GetDyingUnit()
  if (dyingUnit.isTlsHero() and g_GameInstance.isGracePeriodActive())
    displayMessageToPlayer(dyingUnit.getOwner(), "Your hero died during the grace period. Don't worry. They will respawn tomorrow morning.")

// ============================================================================
init
  registerDayEvent(function onDayStart)
  registerNightEvent(function onNightStart)
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_DEATH, function onUnitKilled)
