package SpawnWave
import WaveSpawning
import Events
import LinkedList
import HumanPlayerComponent
import GameConstants
import ErrorHandling
import ClosureEvents
import Math
import IProgress
import HashMap
import UnitRecycler
import UnitMetadata
import UndeadTargetingComponent
import Runnable
import TlsItemIds
import ItemSet
import UnitModifiers
import Coins
import DropItemOnDeathComponent
import Range
import Spawning
import UnitExtensions
import TlsUnitDefinition
import SoundUtils
import MinimapIconComponent
import Elites
import Suspend
import UndeadTargetService
import ClosureTimers
import RealTime

constant real PROCESS_SPAWN_REQUEST_INTERVAL = 0.3
constant int MAX_SPAWNS_PER_PROCESS = 1

constant real GOLD_CHANCE_MIN = 0.01
constant real GOLD_CHANCE_MAX = 1.0

HashMap<unit, SpawnWave> g_unitToSpawnWaveMap

@configurable public bool g_enableSpawnWaveLogging = false

ItemSet g_coinItemSet = new ItemSet("Coins", COLOR_GOLD.withoutAlpha())

LinkedList<SpawnWaveSpawnRequest> g_spawnWaveRequestPool = new LinkedList<SpawnWaveSpawnRequest>()

// ============================================================================
enum SpawnRestriction
  None  // Go ahead and spawn
  Wait  // Waiting for full group
  Done  // Done spawning units for this wave

// ============================================================================
public class SpawnWave extends Runnable
  private SpawnWaveDefinition m_definition
  private _handle m_onActivatedHandler
  private _handle m_onDefProgressChangedEventHandler
  private LinkedList<unit> m_aliveSpawnedUnits
  private int m_numSpawned
  private int m_numSpawnedInGroup
  private int m_groupId
  private string m_id
  protected player m_targetPlayer
  private int m_totalGoldAwarded
  private SpawnWaveContext m_context
  private string m_debugState
  
  // Cached spawn def values
  private int m_maxSpawns
  private int m_maxAlive
  private int m_spawnsPerActivation
  private real m_spawnGroupingFactor
  private bool m_waitForFullSpawnGroup
  private rangeReal m_facingAngleRange

  // --------------------------------------------------------------------------
  construct(player targetPlayer, int index, SpawnWaveDefinition def)
    if (targetPlayer == null)
      argumentNullError("targetPlayer")
    if (def == null)
      argumentNullError("def")

    m_targetPlayer = targetPlayer
    m_definition = def
    m_aliveSpawnedUnits = new LinkedList<unit>()
    m_numSpawned = 0
    m_numSpawnedInGroup = 0
    m_groupId = 0
    m_totalGoldAwarded = 0
    m_id = def.getName()
    m_debugState = ""

    m_context = new SpawnWaveContext()
    m_context.definition = m_definition
    m_context.waveNumber = index

  // --------------------------------------------------------------------------
  ondestroy
    unlistenToActivatedEvent()
    unlistenToDefProgressChangedEvent()
    
    m_aliveSpawnedUnits.clear()
    destroy m_aliveSpawnedUnits
    
    m_definition = null

    if (m_context != null)
      destroy m_context
      m_context = null

  // --------------------------------------------------------------------------
  function getDefinition() returns SpawnWaveDefinition
    return m_definition

  // --------------------------------------------------------------------------
  function getId() returns string
    return m_id

  // --------------------------------------------------------------------------
  function getDebugState() returns string
    return m_debugState

  // --------------------------------------------------------------------------
  override function onStarted()
    super.onStarted()

    listenToActivatedEvent()
    listenToDefProgressChangedEvent()

    m_aliveSpawnedUnits.clear()
    m_numSpawned = 0

    // Update context
    let playerMetadata = m_targetPlayer.getHumanPlayerComponentRequired()
    m_context.playerDifficulty = playerMetadata.getDifficulty()
    for i = 0 to MAX_ELITE_TIER-1
      m_context.tierChances[i] = playerMetadata.getTierChance(i)
    m_context.unitTier = 0

    m_maxAlive = m_definition.getMaxAliveCount(m_context)
    m_maxSpawns = m_definition.getMaxSpawnCount(m_context)
    m_spawnsPerActivation = m_definition.getSpawnsPerActivation(m_context)
    m_spawnGroupingFactor = m_definition.getSpawnGroupingFactor(m_context)
    m_waitForFullSpawnGroup = m_definition.getWaitForFullSpawnGroup()
    m_facingAngleRange = m_definition.getFacingAngleRange()

    // Do this one frame later so that all player spawn waves that share these
    // spawn def services get started
    nullTimer() () ->
    //{
      m_definition.getActivator().start()

      let runnableProgress = (m_definition.getProgress() castTo int) castTo IRunnable
      if (runnableProgress != null)
        runnableProgress.start()
    //}

  // --------------------------------------------------------------------------
  override function onCompleted()
    super.onCompleted()

    unlistenToActivatedEvent()
    unlistenToDefProgressChangedEvent()

    // Do this one frame later so that all player spawn waves that share these
    // spawn def services get complete first
    nullTimer() () ->
    //{
      m_definition.getActivator().complete()

      let runnableProgress = (m_definition.getProgress() castTo int) castTo IRunnable
      if (runnableProgress != null)
        runnableProgress.complete()
    //}

    // Show minimap icons for whatever units are left
    for u in m_aliveSpawnedUnits
      if (u.getMinimapIconComponent() == null)
        let iconPath = getMinimapIconPath(u.getTypeId())
        if (iconPath != null)
          let iconComp = u.getOrAddMinimapIconComponent()
          iconComp.update(iconPath, getMinimapIconColor(u.getTypeId()))
          iconComp.showOnlyFor(m_targetPlayer)

  // --------------------------------------------------------------------------
  override function getProgress() returns real
    return clamp01(m_definition.getProgress().getProgress())

  // --------------------------------------------------------------------------
  function getContext() returns SpawnWaveContext
    return m_context

  // --------------------------------------------------------------------------
  function activate() returns bool
    return activate(false)

  // --------------------------------------------------------------------------
  function activate(bool forceActivation) returns bool
    
    m_debugState = "Spawning"

    if (canSpawnNextUnit() != SpawnRestriction.None)
      return false
 
    if (m_targetPlayer == null)
      error("[SpawnWave.onActivated] Target player has not been set")
      return false

    if (not forceActivation and isCompleted())
      log("activateForPlayer", m_targetPlayer.getName() + " : Spawn wave has already completed")
      m_debugState = "Spawn wave has completed"
      return false

    let playerMetadata = m_targetPlayer.getMetadata()
    if (playerMetadata == null)
      m_debugState = "Player metadata is null"
      return false

    if (playerMetadata.getHasLeftGame())
      m_debugState = "Player left"
      return false

    if (playerMetadata.getHasLostGame())
      m_debugState = "Player lost"
      return false

    let playerHumanComp = playerMetadata.getHumanPlayerComponent()
    if (playerHumanComp == null)
      m_debugState = "PlayerHumanComp is null"
      return false

    let targetProvider = getUndeadTargetProviderForPlayer(m_targetPlayer)
    if (targetProvider == null)
      m_debugState = "No target unit provider found for target player"
      return false

    let numSpawnGroups = max(R2I(I2R(m_spawnsPerActivation) * (1.0 - m_spawnGroupingFactor)), 1)
    let spawnGroupSize = max(R2I(I2R(m_spawnsPerActivation) * m_spawnGroupingFactor), 1)

    for i = 0 to numSpawnGroups-1
    //{
      let targetUnit = targetProvider.getRandomTargetUnit(false) // TODO: prefer organic targets?
      if (targetUnit == null)
        m_debugState = "No target unit provided"
      else
        SpawnController.enqueue(createSpawnWaveRequest(this, m_groupId, spawnGroupSize, targetUnit, m_definition.getWaitForFullSpawnGroup()))
        m_groupId++
    //}

    return true

  // --------------------------------------------------------------------------
  function shouldGrantGoldReward() returns int
    let def = getDefinition()
    let goldReward = def.getGoldReward(m_context)
    if (m_totalGoldAwarded == goldReward)
      return 0
    let waveProgress = clamp01(def.getProgress().getProgress() * 1.1)
    let chance = lerp(GOLD_CHANCE_MIN, GOLD_CHANCE_MAX, waveProgress)
    if (not passesChanceCheck01(chance))
      return 0
    let goldRewardRemaining = goldReward - m_totalGoldAwarded
    let goldToGive = (goldRewardRemaining * waveProgress).floor()
    return max(goldToGive, 0)

  // --------------------------------------------------------------------------
  function registerSpawnedUnit(unit spawnedUnit)

    if (g_unitToSpawnWaveMap.has(spawnedUnit))
      return

    g_unitToSpawnWaveMap.put(spawnedUnit, this)
    m_aliveSpawnedUnits.add(spawnedUnit)
    m_numSpawned++
  
  // --------------------------------------------------------------------------
  function unregisterSpawnedUnit(unit spawnedUnit)
    g_unitToSpawnWaveMap.remove(spawnedUnit)
    m_aliveSpawnedUnits.remove(spawnedUnit)

  // --------------------------------------------------------------------------
  function getSpawnedCount() returns int
    return m_numSpawned

  // --------------------------------------------------------------------------
  function getAliveCount() returns int
    return m_aliveSpawnedUnits.size()

  // --------------------------------------------------------------------------
  function getGoldAwarded() returns int
    return m_totalGoldAwarded

  // --------------------------------------------------------------------------
  protected function recordGoldAwarded(int value)
    m_totalGoldAwarded += value

  // --------------------------------------------------------------------------
  private function requestActivation()
    activate()

  // --------------------------------------------------------------------------
  private function listenToActivatedEvent()
    unlistenToActivatedEvent()

    let activator = m_definition.getActivator()
    if (activator == null)
      return
    
    let e = activator.getActivatedEvent()
    if (e == null)
      return

    if (e.isHandleValid(m_onActivatedHandler))
      return

    m_onActivatedHandler = e.register(() -> requestActivation())

  // --------------------------------------------------------------------------
  private function unlistenToActivatedEvent()
    let activatedEvent = m_definition.getActivator().getActivatedEvent()
    if (activatedEvent != null)
      activatedEvent.unregister(m_onActivatedHandler)
    m_onActivatedHandler = INVALID_HANDLE

  // --------------------------------------------------------------------------
  private function onDefProgressChanged()
    raiseProgressChangedEvent()
    if (getProgress() == 1.0)
      // log("onDefProgressChanged", m_targetPlayer.getName() + " : progress finished!")
      complete()

  // --------------------------------------------------------------------------
  private function listenToDefProgressChangedEvent()
    unlistenToDefProgressChangedEvent()

    let progressChangedEvent = m_definition.getProgress().onProgressChanged()
    if (progressChangedEvent != null)
      m_onDefProgressChangedEventHandler = progressChangedEvent.register((progress) -> onDefProgressChanged())

  // --------------------------------------------------------------------------
  private function unlistenToDefProgressChangedEvent()
    let progressChangedEvent = m_definition.getProgress().onProgressChanged()
    if (progressChangedEvent != null)
      progressChangedEvent.unregister(m_onDefProgressChangedEventHandler)
    m_onDefProgressChangedEventHandler = INVALID_HANDLE

  // --------------------------------------------------------------------------
  private function log(string funcName, string message)
    if (g_enableSpawnWaveLogging)
      Log.debug("SpawnWave", funcName, getId(), message)

  // --------------------------------------------------------------------------
  protected function canSpawnNextUnit() returns SpawnRestriction
  
    if (isCompleted())
      m_debugState = "done"
      return SpawnRestriction.Done

    if (m_numSpawned == m_maxSpawns)
      m_debugState = "max spawns"
      return SpawnRestriction.Done

    if (getAliveCount() == m_maxAlive)
      m_debugState = "max alive"
      return SpawnRestriction.Wait

    m_debugState = "spawning"
    return SpawnRestriction.None

// ============================================================================
function onUnitDeath()
  let dyingUnit = GetDyingUnit()

  if (not g_unitToSpawnWaveMap.has(dyingUnit))
    return

  let spawnWave = g_unitToSpawnWaveMap.get(dyingUnit)
  spawnWave.unregisterSpawnedUnit(dyingUnit)

// ============================================================================
function createSpawnWaveRequest(SpawnWave spawnWave, int groupId, int count, unit targetUnit, bool groupTogether) returns SpawnWaveSpawnRequest
  SpawnWaveSpawnRequest request
  if (g_spawnWaveRequestPool.isEmpty())
    request = new SpawnWaveSpawnRequest()
  else
    request = g_spawnWaveRequestPool.dequeue()
  request.reset(spawnWave, groupId, count, targetUnit, groupTogether)
  return request

// ============================================================================
public class SpawnWaveSpawnRequest extends SpawnRequestBase
  private SpawnWave m_spawnWave
  private int m_groupId
  private int m_count
  private unit m_targetUnit
  private bool m_groupTogether  
  private group m_spawnedUnits
  private SpawnWaveDefinition m_definition
  private SpawnWaveContext m_context
  private ISpawnPointProvider m_spawnPointProvider
  private vec2 m_cachedSpawnPoint = ZERO2
  private SpawnWaveUnitTypeCollection m_unitTypes
  private int m_unitTypeIndex = 0

  // --------------------------------------------------------------------------
  construct ()
    super(10.0)

  // --------------------------------------------------------------------------
  ondestroy

    if (m_spawnedUnits != null)
      m_spawnedUnits.destr()
      m_spawnedUnits = null

    if (m_unitTypes != null)
      destroy m_unitTypes
      m_unitTypes = null

  // --------------------------------------------------------------------------
  function reset(SpawnWave spawnWave, int groupId, int count, unit targetUnit, bool groupTogether)

    m_spawnWave = spawnWave
    m_groupId = groupId
    m_count = count
    m_targetUnit = targetUnit
    m_groupTogether = groupTogether

    m_definition = spawnWave.getDefinition()
    m_context = spawnWave.getContext()
    m_spawnPointProvider = getSpawnPointProvider(spawnWave.m_targetPlayer, m_definition.getSpawnPointProviderType())

    if (m_spawnedUnits == null)
      m_spawnedUnits = CreateGroup()
    else
      m_spawnedUnits.clear()

    m_cachedSpawnPoint = ZERO2

    m_unitTypeIndex = 0

    if (m_unitTypes == null)
      m_unitTypes = new SpawnWaveUnitTypeCollection()
    else
      m_unitTypes.clear()

    m_definition.getUnitTypeProvider().getUnitTypes(m_context, count, m_unitTypes)

  // --------------------------------------------------------------------------
  override function next() returns int

    let restriction = m_spawnWave.canSpawnNextUnit()

    if (restriction == SpawnRestriction.Done)
      // Wave is done spawning units
      return 0

    if (restriction == SpawnRestriction.Wait)
      // Too many alive currently
      return 0

    let unitType = m_unitTypes.get(m_unitTypeIndex)
    let unitTypeId = unitType.unitTypeId
    m_unitTypeIndex = wrap(m_unitTypeIndex + 1, 0, m_unitTypes.size() - 1)

    m_context.groupId = m_groupId
    m_context.waveProgress = m_spawnWave.getProgress()
    m_context.unitTier = unitType.tier

    if (m_context.unitTier == -1)
      error("Unit tier is -1")

    var spawnPos = m_cachedSpawnPoint
    if (spawnPos == ZERO2 or not m_groupTogether)
    //{
      let result = m_spawnPointProvider.getRandomSpawnPointInRange(m_targetUnit.getPos(), m_definition.getSpawnRange().toRangeReal())
      if (not result.succeeded)
        Log.warn("[SpawnWave.onActivated] Found no spawn points!")
        return 0

      m_cachedSpawnPoint = result.spawnPoint
      spawnPos = m_cachedSpawnPoint
    //}

    let spawnedUnit = createUnit(unitTypeId, spawnPos)

    if (spawnedUnit == null)
      Log.error("SpawnWaveSpawnRequest", "spawnSingleUnit", "", "Unable to spawn unit " + UnitId2String(unitTypeId))
      return 0

    let unitMetadata = spawnedUnit.getMetadata()
    if (unitMetadata == null)
      Log.error("[SpawnWave.setTargetPlayer] : Unit has no metadata! : {0} ({1} : {2})".format(
        spawnedUnit.getName(),
        spawnedUnit.getTypeId().toString(),
        UnitId2StringBJ(spawnedUnit.getTypeId())))
      return 0

    let goldReward = m_spawnWave.shouldGrantGoldReward()
    if (goldReward != 0)
      let coinTypeId = getCoinItemTypeFromGoldReward(goldReward)
      spawnedUnit.awardItemOnDeath(g_coinItemSet, coinTypeId, 1.0)

    let commonUnitModifier = m_definition.getCommonUnitModifier()
    if (commonUnitModifier != null)
      commonUnitModifier.call(spawnedUnit, m_context)

    let unitModifier = m_definition.getUnitModifier(unitTypeId)
    if (unitModifier != null)
      unitModifier.call(spawnedUnit, m_context)

    // If the unit is going to drop a coin, track that
    let dropItemOnDeathComp = unitMetadata.getDropItemOnDeathComponent()
    if (dropItemOnDeathComp != null)
    //{
      if (dropItemOnDeathComp.hasItem(TlsItemIds.coinSmall))
        m_spawnWave.recordGoldAwarded(getGoldRewardFromCoinItemType(TlsItemIds.coinSmall))
      if (dropItemOnDeathComp.hasItem(TlsItemIds.coinMedium))
        m_spawnWave.recordGoldAwarded(getGoldRewardFromCoinItemType(TlsItemIds.coinMedium))
      if (dropItemOnDeathComp.hasItem(TlsItemIds.coinLarge))
        m_spawnWave.recordGoldAwarded(getGoldRewardFromCoinItemType(TlsItemIds.coinLarge))
      if (dropItemOnDeathComp.hasItem(TlsItemIds.coinEpic))
        m_spawnWave.recordGoldAwarded(getGoldRewardFromCoinItemType(TlsItemIds.coinEpic))
    //}

    m_spawnedUnits.addUnit(spawnedUnit)
    m_spawnWave.registerSpawnedUnit(spawnedUnit)

    m_context.groupId = -1
    m_context.unitTier = 0

    return 1

  // --------------------------------------------------------------------------
  override function hasNext() returns bool
    return m_spawnedUnits.size() < m_count and m_spawnWave.canSpawnNextUnit() != SpawnRestriction.Done

  // --------------------------------------------------------------------------
  override function complete()

    for spawnedUnit in m_spawnedUnits
    //{
      spawnedUnit.unsuspend()
      spawnedUnit.show()

      let unitMetadata = spawnedUnit.getMetadata()

      let utc = unitMetadata.getUndeadTargetingComponent()
      if (utc != null)
        utc.setTargetUnit(m_targetUnit)

      let unitDef = getUnitDefinition(spawnedUnit.getTypeId())
      if (unitDef != null)
        spawnedUnit.fadeIn(unitDef.getVertexColor())
      else
        spawnedUnit.fadeIn()

      if (m_definition.getMinimapIconPath() != null)
        spawnedUnit.getOrAddMinimapIconComponent()
        ..update(m_definition.getMinimapIconPath(), m_definition.getMinimapIconColor())
        ..showOnlyFor(m_targetUnit.getOwner())

      if (m_definition.getPingOnGroupSpawn())
        let color = m_definition.getPingOnGroupSpawnColor()
        PingMinimapEx(spawnedUnit.getX(), spawnedUnit.getY(), 3.0, color.red, color.green, color.blue, true)
    //}
    
    m_spawnedUnits.clear()

    let playSoundOnGroupSpawn = m_definition.getPlaySoundOnGroupSpawn()
    if (playSoundOnGroupSpawn != null)
      playSoundOnGroupSpawn.playForPlayer(m_targetUnit.getOwner())

  // --------------------------------------------------------------------------
  override function close()

    for u in m_spawnedUnits
      m_spawnWave.unregisterSpawnedUnit(u)
      u.remove()

    g_spawnWaveRequestPool.add(this)
  
  // --------------------------------------------------------------------------
  private function createUnit(int unitTypeId, vec2 pos) returns unit

    unit spawnedUnit

    let facingAngleRange = m_definition.getFacingAngleRange()
    
    let facingAngle = facingAngleRange.getLength() != 0
      ? facingAngleRange.getRandom().asAngleDegrees()
      : pos.angleTo(m_targetUnit.getPos())

    if (m_definition.getUseUnitRecycler())
      spawnedUnit = createUnitRecycled(PLAYER_UNDEAD, unitTypeId, pos, facingAngle)
    else
      spawnedUnit = createUnitTLS(PLAYER_UNDEAD, unitTypeId, pos, facingAngle.degrees())
    
    spawnedUnit.suspend()
    spawnedUnit.hide()

    return spawnedUnit

  // --------------------------------------------------------------------------
  override function getDebuggerStateString() returns string

    string state

    switch (m_spawnWave.canSpawnNextUnit())
      case SpawnRestriction.None
        state = "Spwn"
      case SpawnRestriction.Wait
        state = "Wait"
      case SpawnRestriction.Done
        state = "Done"

    return "Wave {0} P{1} {2} ({3}/{4}) G{5} {6}s -> {7}".format(
      m_definition.getName(), m_spawnWave.m_targetPlayer.getId().toString(), state,
      m_spawnedUnits.size().toString(), m_count.toString(), m_groupId.toString(),
      (getRealTimeSeconds() - m_startTime).toString(), m_targetUnit.getName())    

// ============================================================================
init
  g_unitToSpawnWaveMap = new HashMap<unit, SpawnWave>()
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_DEATH, function onUnitDeath)

  g_coinItemSet.add(TlsItemIds.coinSmall, 1.0)
  g_coinItemSet.add(TlsItemIds.coinMedium, 1.0)
  g_coinItemSet.add(TlsItemIds.coinLarge, 1.0)
  g_coinItemSet.add(TlsItemIds.coinEpic, 1.0)