package SpawnWave
import SpawnWaveDefinition
import Events
import LinkedList
import WaveActivator
import HumanPlayerMetadata
import GameConstants
import ErrorHandling
import ClosureEvents
import Math
import IProgress
import HashMap
import SpawnManager
import UnitRecycler
import PlayerSpawnPointProviders
import UnitMetadata
import UndeadTargetingComponent
import Runnable

HashMap<unit, SpawnWave> g_unitToSpawnWaveMap

// ============================================================================
public class SpawnWave extends Runnable
  private SpawnWaveDefinition m_definition
  private EventCallback m_onActivatedHandler
  private Event1Callback<IProgress> m_onDefProgressChangedEventHandler
  private LinkedList<unit> m_aliveSpawnedUnits
  private int m_numSpawned
  private string m_id
  private player m_targetPlayer

  // --------------------------------------------------------------------------
  construct(player targetPlayer, SpawnWaveDefinition def)
    m_targetPlayer = targetPlayer
    m_definition = def
    m_aliveSpawnedUnits = new LinkedList<unit>()
    m_numSpawned = 0
    m_id = def.getName()

  // --------------------------------------------------------------------------
  ondestroy
    unlistenToActivatedEvent()
    unlistenToDefProgressChangedEvent()
    
    m_aliveSpawnedUnits.clear()
    destroy m_aliveSpawnedUnits
    
    m_definition = null

  // --------------------------------------------------------------------------
  function getDefinition() returns SpawnWaveDefinition
    return m_definition

  // --------------------------------------------------------------------------
  function getId() returns string
    return m_id

  // --------------------------------------------------------------------------
  override function onStarted()
    super.onStarted()

    listenToActivatedEvent()
    listenToDefProgressChangedEvent()

    m_aliveSpawnedUnits.clear()
    m_numSpawned = 0

    m_definition.getActivator().start()

    let runnableProgress = (m_definition.getProgress() castTo int) castTo IRunnable
    if (runnableProgress != null)
      runnableProgress.start()

  // --------------------------------------------------------------------------
  override function onCompleted()
    super.onCompleted()

    unlistenToActivatedEvent()
    unlistenToDefProgressChangedEvent()

    m_definition.getActivator().complete()

    let runnableProgress = (m_definition.getProgress() castTo int) castTo IRunnable
    if (runnableProgress != null)
      runnableProgress.complete()

  // --------------------------------------------------------------------------
  override function getProgress() returns real
    return clamp01(m_definition.getProgress().getProgress())

  // --------------------------------------------------------------------------
  function activateOnce()
    activateForPlayer(m_targetPlayer)

  // --------------------------------------------------------------------------
  function activateForPlayer(player targetPlayer)
 
    if (targetPlayer == null)
      error("[SpawnWave.onActivated] Target player has not been set")
      return
      
    log("activateForPlayer", m_targetPlayer.getName() + "========================")

    if (isCompleted())
      log("activateForPlayer", m_targetPlayer.getName() + " : Spawn wave has already completed")
      return

    let playerMetadata = targetPlayer.getHumanMetadata()
    if (playerMetadata == null or playerMetadata.getIsDead())
      log("activateForPlayer", m_targetPlayer.getName() + " : Player is dead")
      return

    let waveProgress = getProgress()
    let aliveCountMax = m_definition.getMaxAliveCount(waveProgress)
    let spawnCountMax = m_definition.getMaxSpawnCount(waveProgress)
    let spawnsPerActivation = m_definition.getSpawnsPerActivation(waveProgress)
    let spawnGroupingFactor = m_definition.getSpawnGroupingFactor(waveProgress)
    let waitForFullSpawnGroup = m_definition.getWaitForFullSpawnGroup()

    let numSpawnGroups = max(R2I(I2R(spawnsPerActivation) * (1.0 - spawnGroupingFactor)), 1)
    let spawnGroupSize = max(R2I(I2R(spawnsPerActivation) * spawnGroupingFactor), 1)

    let spawnPointProvider = getSpawnPointProviderForPlayer(targetPlayer, m_definition.getSpawnRange())

    let spawnPointsResult = spawnPointProvider.getSpawnPoints(numSpawnGroups)
    if (not spawnPointsResult.succeeded)
      error("[SpawnWave.onActivated] Found no spawn points!")
      return

    var numSpawnsAvailable = getNumSpawnsAvailable(aliveCountMax, spawnCountMax)

    var numberSpawned = 0

    // For each spawn point
    for sp in spawnPointsResult.spawnPoints
      
      // Until we reach max alive or max spawned
      if (numSpawnsAvailable == 0)
        break

      // Sometimes we want to spawn the entire group at once
      if (waitForFullSpawnGroup and numSpawnsAvailable < spawnGroupSize)
        break

      // Spawn N units to form a group
      for i = 0 to spawnGroupSize - 1

        // Until we reach max alive or max spawned
        if (numSpawnsAvailable == 0)
          break

        let spawnCount = min(numSpawnsAvailable, spawnGroupSize)

        // Sample unit types, one type for each unit in the group
        let unitTypes = m_definition.getUnitTypeProvider().getUnitTypes(spawnCount)
        for unitType in unitTypes
        
          // Until we reach max alive or max spawned
          if (numSpawnsAvailable == 0)
            break

          if (spawnSingleUnit(unitType, sp, targetPlayer))
            numberSpawned++

          numSpawnsAvailable = getNumSpawnsAvailable(aliveCountMax, spawnCountMax)

        // Clean up the unitTypes list
        destroy unitTypes

    // Clean up the spawnPoints list
    destroy spawnPointsResult.spawnPoints

    if (numberSpawned == 0)
      log("activateForPlayer", m_targetPlayer.getName() + " : No unit was spawned")

  // --------------------------------------------------------------------------
  private function getNumSpawnsAvailable(int aliveCountMax, int spawnCountMax) returns int
    let aliveCount = getAliveCount()
    let spawnedCount = getSpawnedCount()
    let remainingAlive = aliveCountMax - aliveCount
    let remainingSpawn = spawnCountMax - spawnedCount
    let numSpawnsAvailable = max(min(remainingAlive, remainingSpawn), 0)

    if (spawnedCount >= spawnCountMax)
      log("getNumSpawnsAvailable", m_targetPlayer.getName() + " : Reached max number of spawns for wave")
      return 0

    if (aliveCount >= aliveCountMax)
      log("getNumSpawnsAvailable", m_targetPlayer.getName() + " : Reached max number of concurrent alive")
      return 0

    return numSpawnsAvailable

  // --------------------------------------------------------------------------
  private function spawnSingleUnit(int unitTypeId, vec2 pos, player targetPlayer) returns bool
    
    unit spawnedUnit
    
    if (getDefinition().getUseUnitRecycler())
      spawnedUnit = createUnitRecycled(
        PLAYER_UNDEAD,
        unitTypeId,
        pos,
        GetRandomDirectionDeg().asAngleDegrees())
    else
      spawnedUnit = createUnitTLS(
        PLAYER_UNDEAD,
        unitTypeId,
        pos,
        GetRandomDirectionDeg())

    if (spawnedUnit == null)
      error("Unable to spawn unit for spawn wave : " + UnitId2String(unitTypeId))
      return false

    registerSpawnedUnit(spawnedUnit)
  
    let progress = getProgress()

    let commonUnitModifier = m_definition.getCommonUnitModifier()
    if (commonUnitModifier != null)
      commonUnitModifier.call(spawnedUnit, progress)

    let unitModifier = m_definition.getUnitModifier(unitTypeId)
    if (unitModifier != null)
      unitModifier.call(spawnedUnit, progress)

    setTargetPlayer(spawnedUnit, targetPlayer)

    return true

  // --------------------------------------------------------------------------
  private function setTargetPlayer(unit _unit, player targetPlayer)
    
    let unitMetadata = _unit.getMetadata()
    if (unitMetadata == null)
      Log.error("[SpawnWave.setTargetPlayer] : Unit has no metadata! : {0} ({1} : {2})".format(_unit.getName(), _unit.getTypeId().toString(), UnitId2StringBJ(_unit.getTypeId())))
      return

    let playerMetadata = targetPlayer.getHumanMetadataRequired()
    if (playerMetadata == null)
      Log.error("[SpawnWave.setTargetPlayer] : target player has no metadata")
      return

    if (playerMetadata.getIsDead())
      return

    unitMetadata.getOrAddUndeadTargetingComponent()
    ..setTargetPlayer(targetPlayer)
    ..issueOrderTargetingPlayer()

  // --------------------------------------------------------------------------
  function registerSpawnedUnit(unit spawnedUnit)

    if (g_unitToSpawnWaveMap.has(spawnedUnit))
      return

    g_unitToSpawnWaveMap.put(spawnedUnit, this)
    m_aliveSpawnedUnits.add(spawnedUnit)
    m_numSpawned++
  
  // --------------------------------------------------------------------------
  function unregisterSpawnedUnit(unit spawnedUnit)
    g_unitToSpawnWaveMap.remove(spawnedUnit)
    m_aliveSpawnedUnits.remove(spawnedUnit)

  // --------------------------------------------------------------------------
  function getSpawnedCount() returns int
    return m_numSpawned

  // --------------------------------------------------------------------------
  function getAliveCount() returns int
    return m_aliveSpawnedUnits.size()

  // --------------------------------------------------------------------------
  private function listenToActivatedEvent()
    unlistenToActivatedEvent()

    if (m_onActivatedHandler != null)
      return

    let activator = m_definition.getActivator()
    if (activator == null)
      return
    
    let e = activator.getActivatedEvent()
    if (e == null)
      return

    m_onActivatedHandler = e.register(() -> activateOnce())

  // --------------------------------------------------------------------------
  private function unlistenToActivatedEvent()
    if (m_onActivatedHandler != null)
      destroy m_onActivatedHandler
      m_onActivatedHandler = null

  // --------------------------------------------------------------------------
  private function onDefProgressChanged()
    raiseProgressChangedEvent()
    if (getProgress() == 1.0)
      log("onDefProgressChanged", m_targetPlayer.getName() + " : progress finished!")
      complete()

  // --------------------------------------------------------------------------
  private function listenToDefProgressChangedEvent()
    unlistenToDefProgressChangedEvent()

    if (m_onDefProgressChangedEventHandler != null)
      return

    let progressChangedEvent = m_definition.getProgress().getProgressChangedEvent()
    if (progressChangedEvent == null)
      return

    m_onDefProgressChangedEventHandler = progressChangedEvent.register((progress) -> onDefProgressChanged())

  // --------------------------------------------------------------------------
  private function unlistenToDefProgressChangedEvent()
    if (m_onDefProgressChangedEventHandler != null)
      destroy m_onDefProgressChangedEventHandler
      m_onDefProgressChangedEventHandler = null

// ============================================================================
function onUnitDeath()
  let dyingUnit = GetDyingUnit()

  if (not g_unitToSpawnWaveMap.has(dyingUnit))
    return

  let spawnWave = g_unitToSpawnWaveMap.get(dyingUnit)
  spawnWave.unregisterSpawnedUnit(dyingUnit)

// ============================================================================
init
  g_unitToSpawnWaveMap = new HashMap<unit, SpawnWave>()
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_DEATH, function onUnitDeath)