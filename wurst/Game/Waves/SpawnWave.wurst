package SpawnWave
import Runnable
import SpawnWaveDefinition
import Events
import LinkedList
import WaveActivator
import HumanPlayerMetadata
import UnitMetadata
import GameConstants
import ErrorHandling
import ClosureEvents
import Math
import IProgress
import HashMap
import SpawnManager

HashMap<unit, SpawnWave> g_unitToSpawnWaveMap

// ============================================================================
public class SpawnWave extends Runnable implements IProgress
  private SpawnWaveDefinition m_definition
  private EventCallback m_onActivatedHandler
  private Event1<IProgress> m_progressChangedEvent
  private Event1Callback<IProgress> m_onDefProgressChangedEventHandler
  private player m_targetPlayer
  private LinkedList<unit> m_aliveSpawnedUnits
  private int m_numSpawned
  private string m_id

  // --------------------------------------------------------------------------
  construct(SpawnWaveDefinition def, player targetPlayer)
    m_definition = def
    m_aliveSpawnedUnits = new LinkedList<unit>()
    m_id = "[P{0}:{1}]".format(targetPlayer.getId().toString(), def.getName())
    setTargetPlayer(targetPlayer)

  // --------------------------------------------------------------------------
  ondestroy
    unlistenToActivatedEvent()
    unlistenToDefProgressChangedEvent()
    
    for u in m_aliveSpawnedUnits
      unregisterSpawnedUnit(u)
    destroy m_aliveSpawnedUnits
    
    m_definition = null
    m_targetPlayer = null

    if (m_progressChangedEvent != null)
      destroy m_progressChangedEvent
      m_progressChangedEvent = null

  // --------------------------------------------------------------------------
  function getTargetPlayer() returns player
    return m_targetPlayer

  // --------------------------------------------------------------------------
  function setTargetPlayer(player p)
    m_targetPlayer = p

  // --------------------------------------------------------------------------
  function getDefinition() returns SpawnWaveDefinition
    return m_definition

  // --------------------------------------------------------------------------
  function getId() returns string
    return m_id

  // --------------------------------------------------------------------------
  override function onStarted()
    super.onStarted()
    listenToActivatedEvent()
    listenToDefProgressChangedEvent()

    let runnableProgress = (m_definition.getProgress() castTo int) castTo IRunnable
    if (runnableProgress != null)
      runnableProgress.start()    

    m_aliveSpawnedUnits.clear()
    m_numSpawned = 0

    m_definition.getActivator().start()

  // --------------------------------------------------------------------------
  override function onPaused()
    super.onPaused()
    unlistenToActivatedEvent()
    unlistenToDefProgressChangedEvent()

    m_definition.getActivator().pause()

    let runnableProgress = (m_definition.getProgress() castTo int) castTo IRunnable
    if (runnableProgress != null)
      runnableProgress.pause()

  // --------------------------------------------------------------------------
  override function onResumed()
    super.onResumed()
    listenToActivatedEvent()
    listenToDefProgressChangedEvent()

    m_definition.getActivator().resume()
    
    let runnableProgress = (m_definition.getProgress() castTo int) castTo IRunnable
    if (runnableProgress != null)
      runnableProgress.resume()

  // --------------------------------------------------------------------------
  override function onCompleted()
    super.onCompleted()
    unlistenToActivatedEvent()
    unlistenToDefProgressChangedEvent()
    m_definition.getActivator().complete()

    let runnableProgress = (m_definition.getProgress() castTo int) castTo IRunnable
    if (runnableProgress != null)
      runnableProgress.complete()

  // --------------------------------------------------------------------------
  override function reset()
    super.reset()
    unlistenToActivatedEvent()
    unlistenToDefProgressChangedEvent()

    m_definition.getActivator().reset()

    let runnableProgress = (m_definition.getProgress() castTo int) castTo IRunnable
    if (runnableProgress != null)
      runnableProgress.reset()

    m_aliveSpawnedUnits.clear()
    m_numSpawned = 0

  // --------------------------------------------------------------------------
  override function getProgress() returns real
    return clamp01(m_definition.getProgress().getProgress())

  // --------------------------------------------------------------------------
  override function getProgressChangedEvent() returns Event1<IProgress>
    if (m_progressChangedEvent == null)
      m_progressChangedEvent = new Event1<IProgress>()
    return m_progressChangedEvent

  // --------------------------------------------------------------------------
  function raiseProgressChangedEvent()
    if (m_progressChangedEvent != null)
      m_progressChangedEvent.call(this)

  // --------------------------------------------------------------------------
  function activateOnce()
    onActivated()

  // --------------------------------------------------------------------------
  protected function onActivated()

    let p = getTargetPlayer()
    if (p == null)
      error("[SpawnWave.onActivated] Target player has not been set")
      return

    let playerMetadata = p.getHumanMetadata()
    if (playerMetadata == null or playerMetadata.getIsDead())
      return

    let waveProgress = getProgress()
    let aliveCountMax = m_definition.getMaxAliveCount(waveProgress)
    let spawnCountMax = m_definition.getMaxSpawnCount(waveProgress)
    let spawnsPerActivation = m_definition.getSpawnsPerActivation(waveProgress)    
    let spawnGroupingFactor = m_definition.getSpawnGroupingFactor(waveProgress)
    let waitForFullSpawnGroup = m_definition.getWaitForFullSpawnGroup()

    let numSpawnGroups = max(R2I(I2R(spawnsPerActivation) * (1.0 - spawnGroupingFactor)), 1)
    let spawnGroupSize = max(R2I(I2R(spawnsPerActivation) * spawnGroupingFactor), 1)

    let spawnPointsResult = m_definition.getSpawnPointProvider().getSpawnPoints(numSpawnGroups)
    if (not spawnPointsResult.succeeded)
      error("[SpawnWave.onActivated] Found no spawn points!")
      return

    var numSpawnsAvailable = getNumSpawnsAvailable(aliveCountMax, spawnCountMax)

    // For each spawn point
    for sp in spawnPointsResult.spawnPoints
      
      // Until we reach max alive or max spawned
      if (numSpawnsAvailable == 0)
        break

      // Sometimes we want to spawn the entire group at once
      if (waitForFullSpawnGroup and numSpawnsAvailable < spawnGroupSize)
        break

      // Spawn N units to form a group
      for i = 0 to spawnGroupSize - 1

        // Until we reach max alive or max spawned
        if (numSpawnsAvailable == 0)
          break

        let spawnCount = min(numSpawnsAvailable, spawnGroupSize)

        // Sample unit types, one type for each unit in the group
        let unitTypes = m_definition.getUnitTypeProvider().getUnitTypes(spawnCount)
        for unitType in unitTypes
        
          // Until we reach max alive or max spawned
          if (numSpawnsAvailable == 0)
            break

          spawnSingleUnit(unitType, sp)

          numSpawnsAvailable = getNumSpawnsAvailable(aliveCountMax, spawnCountMax)

        // Clean up the unitTypes list
        destroy unitTypes

    // Clean up the spawnPoints list
    destroy spawnPointsResult.spawnPoints

  // --------------------------------------------------------------------------
  private function getNumSpawnsAvailable(int aliveCountMax, int spawnCountMax) returns int
    let remainingAlive = aliveCountMax - getAliveCount()
    let remainingSpawn = spawnCountMax - getSpawnedCount()
    let numSpawnsAvailable = max(min(remainingAlive, remainingSpawn), 0)

    if (getSpawnedCount() >= spawnCountMax)
      //Log.debug("[SpawnWave.onActivated] Reached max number of spawns for wave")
      return 0

    if (getAliveCount() >= aliveCountMax)
      //Log.debug("[SpawnWave.onActivated] Reached max number of concurrent alive")
      return 0

    return numSpawnsAvailable

  // --------------------------------------------------------------------------
  private function spawnSingleUnit(int unitTypeId, vec2 pos) returns unit
    let spawnedUnit = createUnitTLS(
      PLAYER_UNDEAD,
      unitTypeId,
      pos.x, pos.y,
      GetRandomDirectionDeg())

    let progress = getProgress()

    let commonUnitModifier = m_definition.getCommonUnitModifier()
    if (commonUnitModifier != null)
      commonUnitModifier.apply(spawnedUnit, progress)

    let unitModifier = m_definition.getUnitModifier(unitTypeId)
    if (unitModifier != null)
      unitModifier.apply(spawnedUnit, progress)

    registerSpawnedUnit(spawnedUnit)

    return spawnedUnit

  // --------------------------------------------------------------------------
  function registerSpawnedUnit(unit spawnedUnit)
    if (g_unitToSpawnWaveMap.has(spawnedUnit))
      return
    m_aliveSpawnedUnits.add(spawnedUnit)
    g_unitToSpawnWaveMap.put(spawnedUnit, this)    
    m_numSpawned++
  
  // --------------------------------------------------------------------------
  function unregisterSpawnedUnit(unit spawnedUnit)
    m_aliveSpawnedUnits.remove(spawnedUnit)
    g_unitToSpawnWaveMap.remove(spawnedUnit)

  // --------------------------------------------------------------------------
  function getSpawnedCount() returns int
    return m_numSpawned

  // --------------------------------------------------------------------------
  function getAliveCount() returns int
    return m_aliveSpawnedUnits.size()

  // --------------------------------------------------------------------------
  private function listenToActivatedEvent()
    unlistenToActivatedEvent()

    if (m_onActivatedHandler != null)
      return

    let activator = m_definition.getActivator()
    if (activator == null)
      return
    
    let e = activator.getActivatedEvent()
    if (e == null)
      return

    m_onActivatedHandler = e.register(() -> onActivated())

  // --------------------------------------------------------------------------
  private function unlistenToActivatedEvent()
    if (m_onActivatedHandler != null)
      destroy m_onActivatedHandler
      m_onActivatedHandler = null

  // --------------------------------------------------------------------------
  private function onDefProgressChanged()
    raiseProgressChangedEvent()
    if (getProgress() == 1.0)
      complete()

  // --------------------------------------------------------------------------
  private function listenToDefProgressChangedEvent()
    unlistenToDefProgressChangedEvent()

    if (m_onDefProgressChangedEventHandler != null)
      return

    let progressChangedEvent = m_definition.getProgress().getProgressChangedEvent()
    if (progressChangedEvent == null)
      return

    m_onDefProgressChangedEventHandler = progressChangedEvent.register((progress) -> onDefProgressChanged())

  // --------------------------------------------------------------------------
  private function unlistenToDefProgressChangedEvent()
    if (m_onDefProgressChangedEventHandler != null)
      destroy m_onDefProgressChangedEventHandler
      m_onDefProgressChangedEventHandler = null

// ============================================================================
function onUnitDeath()
  let dyingUnit = GetDyingUnit()

  if (not g_unitToSpawnWaveMap.has(dyingUnit))
    return

  let spawnWave = g_unitToSpawnWaveMap.get(dyingUnit)
  spawnWave.unregisterSpawnedUnit(dyingUnit)

// ============================================================================
init
  g_unitToSpawnWaveMap = new HashMap<unit, SpawnWave>()
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_DEATH, function onUnitDeath)