package LootOperationComponent
import RealtimeUnitComponent
import LootableComponent
import LinkedList
import HashMap
import TimerUtils
import ClosureTimers
import FX
import DisplayTextToPlayer
import TlsAbilityIds
import Orders
import ColorUtility
import RegisterEvents
import WorldProgressBar
import Math
import Ability_Search
import LootableUtility
import LootableTypes
import SoundUtils
import RealTime
import IProgress
import Notifications
import Icons
import Command
import TlsSounds

constant int PROGRESS_BAR_LENGTH = 20
constant colorA PROGRESS_BAR_FOREGROUND = colorA(0, 170, 0, 255)
constant colorA PROGRESS_BAR_BACKGROUND = colorA(0, 64, 0, 255)
constant real PROGRESS_BAR_UPDATE_PERIOD = 0.1

LinkedList<LootOperationComponent> g_activeOperations
HashMap<unit, LootOperationComponent> g_looterToOperationMap = new HashMap<unit, LootOperationComponent>()

SoundDefinition g_notEnoughManaSoundDef
int array g_notEnoughManaLastPlayedTime

// ============================================================================
public class LootOperationComponent extends RealtimeUnitComponent
  private unit m_lootingUnit
  private WorldProgressBar m_worldProgressBar
  private Progress m_progress
  private Notification m_notification
  private real m_duration
  private timer m_timer
  private int m_secondsElapsed
  private real m_manaCost
  private bool m_isRunning

  // --------------------------------------------------------------------------
  construct(IUnitMetadata owner)
    super(owner)
    
    m_timer = getTimer()

    m_worldProgressBar = new WorldProgressBar()
    ..setHeight(128.0)
    ..setScale(16.0)

  // --------------------------------------------------------------------------
  ondestroy

    if (m_timer != null)
      m_timer.release()
      m_timer = null
    
    if (m_worldProgressBar != null)
      destroy m_worldProgressBar
      m_worldProgressBar = null

    if (m_notification != null)
      m_notification.close()
      m_notification.release()
      m_notification = null

    if (m_progress != null)
      destroy m_progress
      m_progress = null

  // --------------------------------------------------------------------------
  override function onEnabled()
    super.onEnabled()
    m_worldProgressBar..setPos(getOwnerUnit().getPos())

  // --------------------------------------------------------------------------
  override function onDisabled()
    super.onDisabled()
    if (getIsRunning())
      cancel()

  // --------------------------------------------------------------------------
  function getTimeRemaining() returns real
    return m_timer != null ? m_timer.getRemaining() : 0.0

  // --------------------------------------------------------------------------
  function getIsRunning() returns bool
    return m_isRunning

  // --------------------------------------------------------------------------
  function getLooter() returns unit
    return m_lootingUnit

  // --------------------------------------------------------------------------
  override function realtimeUpdate(real dt)
    super.realtimeUpdate(dt)

    if (getIsRunning() == false)
      return
    
    let percentage01 = parameterize01(m_duration, 0.0, m_timer.getRemaining())
    m_progress.report(percentage01)

    if (m_worldProgressBar != null)
      m_worldProgressBar.setPercentageNow(percentage01)

    // Remove mana per second
    let secondsElapsed = m_timer.getElapsed().floor()
    if (m_secondsElapsed != secondsElapsed)
      m_secondsElapsed = secondsElapsed
      m_lootingUnit.addMana(-m_manaCost)
      if (m_lootingUnit.getMana() == 0)
        FX.createOutOfManaTag(m_lootingUnit.getPos(), m_lootingUnit.getOwner())
        cancel()

  // --------------------------------------------------------------------------
  function start(unit looter, real duration)
    if (getIsRunning())
      return

    m_isRunning = true
    m_lootingUnit = looter
    m_duration = duration
    
    let lootingPlayer = looter.getOwner()
    let cameraPos = getOwnerUnit().getPos()

    // Avoid implicit capture of 'this' by caching the result of m_lootableUnit
    let lootableUnitCached = getOwnerUnit()
    m_timer.doManual(duration, true, () -> onOperationFinished(lootableUnitCached))

    m_progress = new Progress()
    m_progress.report("Looting {0}...".format(getOwnerUnit().getName()))

    m_worldProgressBar
    ..setPos(looter.getPos())
    ..setSpeed(1.0 / m_duration)
    ..fadeIn()

    m_notification = new Notification(duration)
    ..setProgress(m_progress)
    ..setIconPath(Icons.bTNTelescope)
    ..setMessage("Looting {0}...".format(getOwnerUnit().getName()))
    ..setCanClose(false)
    ..setClickCommand(new RoutedCommand(() -> begin
      if (localPlayer == lootingPlayer)
        PanCameraToTimedForPlayer(lootingPlayer, cameraPos.x, cameraPos.y, 0)
    end))
    ..show(lootingPlayer)
    ..acquire()

    g_looterToOperationMap.put(looter, this)

    m_manaCost = getUnitSearchManaCostPerSecond(m_lootingUnit)

    this.registerForRealtimeUpdate(RealtimeUpdatePriority.Fast)

  // --------------------------------------------------------------------------
  function cancel()
    let lootable = getOwner().getLootableComponent()
    if (lootable != null)
      lootable.onLootingCanceled(m_lootingUnit)
    cleanup()
  
  // --------------------------------------------------------------------------
  private static function onOperationFinished(unit lootable)
    let metadata = lootable.getMetadata()
    if (metadata == null)
      return
    let operation = metadata.getLootOperationComponent()
    if (operation == null or operation.getIsRunning() == false)
      return
    operation.onOperationFinished()

  // --------------------------------------------------------------------------
  private function onOperationFinished()
    let lootable = getOwner().getLootableComponent()
    if (lootable != null)
      lootable.onLootingFinished(m_lootingUnit)
    cleanup()

  // --------------------------------------------------------------------------
  private function cleanup()
    m_isRunning = false
    m_duration = 0.
    m_manaCost = 0
    m_secondsElapsed = 0

    g_looterToOperationMap.remove(m_lootingUnit)
    m_lootingUnit = null

    m_timer.pause()
    m_worldProgressBar.fadeOut()
    
    if (m_notification != null)
      m_notification.close()
      m_notification.release()
      m_notification = null

    if (m_progress != null)
      destroy m_progress
      m_progress = null

    this.unregisterForRealtimeUpdate()

// ============================================================================
public function IUnitMetadata.getLootOperationComponent() returns LootOperationComponent
  return this.getComponent(LootOperationComponent.typeId) castTo LootOperationComponent

// ============================================================================
public function IUnitMetadata.getOrAddLootOperationComponent() returns LootOperationComponent
  var component = this.getLootOperationComponent()
  if (component == null)
    component = this.addComponent(new LootOperationComponent(this)) castTo LootOperationComponent
  return component

// ============================================================================
function onSpellEndCast()
  if (GetSpellAbilityId() != ABILITY_ID_SEARCH)
    return
  
  let lootingUnit = GetSpellAbilityUnit()
  let lootingOperation = g_looterToOperationMap.get(lootingUnit)
  if (lootingOperation == null)
    return

  lootingUnit.resetAbilityCooldown(ABILITY_ID_SEARCH)

// ============================================================================
function resetUnitAnimationAfterRightClickingSameLootable(unit lootingUnit, LootOperationComponent lootOperation)
  // Stand 4 in HD
  lootingUnit.setAnimation(15)
  // Reset the cooldown and other stats since
  prepareSearchSpell(lootingUnit, lootOperation.getTimeRemaining())

// ============================================================================
function prepareSearchSpell(unit lootingUnit, unit lootableUnit)
  let lootableUnitMetadata = lootableUnit.getMetadata()
  if (lootableUnitMetadata == null)
    return
  let lootableComp = lootableUnitMetadata.getLootableComponent()
  if (lootableComp == null)
    return
  let searchDuration = getUnitSearchDuration(lootingUnit, lootableComp.getSearchDuration())
  prepareSearchSpell(lootingUnit, searchDuration)

// ============================================================================
function prepareSearchSpell(unit lootingUnit, real searchDuration)
  let searchAbility = lootingUnit.getAbility(ABILITY_ID_SEARCH)
  if (searchAbility != null)
    let lvl = 0
    lootingUnit.setAbilityLevel(ABILITY_ID_SEARCH, lvl + 1)
    searchAbility.setField(ABILITY_RLF_DURATION_NORMAL, lvl, searchDuration)
    searchAbility.setField(ABILITY_RLF_DURATION_HERO, lvl, searchDuration)
    searchAbility.setField(ABILITY_RLF_ART_DURATION, lvl, searchDuration)
    searchAbility.setField(ABILITY_RLF_FOLLOW_THROUGH_TIME, lvl, searchDuration)
    searchAbility.setField(ABILITY_RLF_COOLDOWN, lvl, searchDuration)
    lootingUnit.setAbilityLevel(ABILITY_ID_SEARCH, lvl)

// ============================================================================
function onSpellChannel()
  if (GetSpellAbilityId() != ABILITY_ID_SEARCH)
    return

  let lootingUnit = GetSpellAbilityUnit()
  let lootableUnit = GetSpellTargetUnit()
  let lootingPlayer = lootingUnit.getOwner()

  let looterMetadata = lootingUnit.getMetadata()
  if (looterMetadata == null)
    Log.debug("Searching unit has no metadata")
    lootingUnit.issueImmediateOrderById(Orders.stop)
    lootingUnit.resetAbilityCooldown(TlsAbilityIds.search)
    return
  
  let lootableMetadata = lootableUnit.getMetadata()
  if (lootableMetadata == null)
    Log.debug("Search target has no metadata")
    lootingUnit.issueImmediateOrderById(Orders.stop)
    lootingUnit.resetAbilityCooldown(TlsAbilityIds.search)
    return

  let lootable = lootableMetadata.getLootableComponent()
  if (lootable == null or not lootable.getEnabled())
    lootingUnit.issueImmediateOrderById(Orders.stop)
    lootingUnit.resetAbilityCooldown(TlsAbilityIds.search)
    displayMessageToPlayer(lootingPlayer, "Failed To Search".colorize(Colors.red) + " Must target a lootable unit to search")
    TlsSounds.errorSoundDef.playForPlayer(lootingPlayer)
    return

  let scaledSearchDuration = getUnitSearchDuration(lootingUnit, lootable.getSearchDuration())
  let manaRemainingAfterSearch = calculateManaRemainingAfterLootOperation(lootingUnit, scaledSearchDuration)
  if (manaRemainingAfterSearch < 0)
  //{
    lootingUnit.issueImmediateOrderById(Orders.stop)
    lootingUnit.resetAbilityCooldown(TlsAbilityIds.search)
    let manaNeeded = (lootingUnit.getMana() + manaRemainingAfterSearch.abs()).floor()
    displayMessageToPlayer(lootingPlayer, "Failed To Search".colorize(Colors.red) + " You need {0} mana to loot this structure.".format(manaNeeded.toString()))
    TlsSounds.errorSoundDef.playForPlayer(lootingPlayer)
    if (getRealTimeSeconds() - g_notEnoughManaLastPlayedTime[lootingPlayer.getId()] > 2)
      g_notEnoughManaLastPlayedTime[lootingPlayer.getId()] = getRealTimeSeconds()
      doAfter(0.5, () -> g_notEnoughManaSoundDef.playForPlayer(lootingPlayer))
    return
  //}

  let lootOperation = lootableMetadata.getLootOperationComponent()
  if (lootOperation != null and lootOperation.getIsRunning())
  //{
    if (lootOperation.getLooter() != lootingUnit)
      lootingUnit.issueImmediateOrderById(Orders.stop)
      lootingUnit.resetAbilityCooldown(TlsAbilityIds.search)
      displayMessageToPlayer(lootingPlayer, "Failed To Search".colorize(Colors.red) + " Lootable is already being looted")
      TlsSounds.errorSoundDef.playForPlayer(lootingPlayer)
      return
    else
      let activeLootingOperation = g_looterToOperationMap.get(lootingUnit)
      if (activeLootingOperation == null or activeLootingOperation != lootOperation)
        Log.error("Expected active looting operation to match")
      // Log.info("unit is actively looting -> resetting")
      resetUnitAnimationAfterRightClickingSameLootable(lootingUnit, activeLootingOperation)
  //}
  else
    // Log.info("unit is starting to loot")
    prepareSearchSpell(lootingUnit, lootableUnit)
    lootable.startLooting(lootingUnit)

// ============================================================================
function onUnitIssuedUnitOrder()
  let orderedUnit = GetOrderedUnit()
  let targetUnit = GetOrderTargetUnit()
  let issuedOrder = GetIssuedOrderId()

  let unitCanSearch = orderedUnit.hasAbility(TlsAbilityIds.search)

  // Stop and issue a search order instead
  if (issuedOrder == Orders.smart and targetUnit.isLootable() and unitCanSearch)
    // Log.info("ordered to search instead")
    if (not orderedUnit.issueTargetOrder(ABILITY_SEARCH_ORDER, targetUnit))
      Log.debug("Could not issue search order")
    return

  if (issuedOrder == OrderId(ABILITY_SEARCH_ORDER_HEROACTION) and targetUnit.isLootable() and unitCanSearch)
    if (not orderedUnit.issueTargetOrder(ABILITY_SEARCH_ORDER, targetUnit))
      Log.debug("Could not issue search order")
    return

  let lootingOperation = g_looterToOperationMap.get(orderedUnit) 
  if (lootingOperation == null)
    // Log.info("unit is not currently looting")
    return

  // If the order issued was search and its the same target lootable dont cancel the operation here.
  // Instead, we'll resume the loot operation as if nothing happened.
  if (issuedOrder == OrderId(ABILITY_SEARCH_ORDER) and lootingOperation.getOwnerUnit() == targetUnit)
    // Log.info("ordered to search same lootable")
    return

  // For any other case cancel the current operation
  // Log.info("issued target order cancels looting")
  lootingOperation.cancel()

// ============================================================================
function onUnitIssuedImmediateOrPointOrder()
  let orderedUnit = GetOrderedUnit()
  let lootingOperation = g_looterToOperationMap.get(orderedUnit)
  if (lootingOperation == null)
    return
  // Log.info("issued immediate or point order cancels looting")
  lootingOperation.cancel()

// ============================================================================
init

  g_activeOperations = new LinkedList<LootOperationComponent>()
  
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_CHANNEL, function onSpellChannel)
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_ENDCAST, function onSpellEndCast)
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_ISSUED_UNIT_ORDER, function onUnitIssuedUnitOrder)
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_ISSUED_ORDER, function onUnitIssuedImmediateOrPointOrder)
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER, function onUnitIssuedImmediateOrPointOrder)

  g_notEnoughManaSoundDef = new SoundDefinition("sound\\dialogue\\genericwarnings\\genericwarningnomana1.flac")