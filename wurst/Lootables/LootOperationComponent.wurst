package LootOperationComponent
import RealtimeUnitComponent
// import TextProgressBarTag
import LootableComponent
import LinkedList
import HashMap
import TextProgressBar
import TimerUtils
import ClosureTimers
import FX
import LootableUtility
import DisplayTextToPlayer
import TlsAbilityIds
import Orders
import ColorUtility
import LootableTypes
import RegisterEvents
import ProgressBar
import Math

constant int PROGRESS_BAR_LENGTH = 20
constant colorA PROGRESS_BAR_FOREGROUND = colorA(0, 170, 0, 255)
constant colorA PROGRESS_BAR_BACKGROUND = colorA(0, 64, 0, 255)
constant real PROGRESS_BAR_UPDATE_PERIOD = 0.1

LinkedList<LootOperationComponent> g_activeOperations
HashMap<unit, LootOperationComponent> g_looterToOperationMap = new HashMap<unit, LootOperationComponent>()

TextProgressBar g_LootOperationProgressBar

// ============================================================================
public class LootOperationComponent extends RealtimeUnitComponent
  private unit m_lootingUnit
  private ProgressBar m_progressBar
  private real m_duration
  private timer m_timer
  private timerdialog m_timerDialog
  private int m_secondsElapsed
  private real m_manaCost
  private bool m_isRunning

  // --------------------------------------------------------------------------
  construct(IUnitMetadata owner)
    super(owner)
    
    m_timer = getTimer()
    m_timerDialog = CreateTimerDialog(m_timer)..display(false)
    m_progressBar = new ProgressBar()..setHeight(128.0)..setScale(16.0)

  // --------------------------------------------------------------------------
  ondestroy

    if (m_timerDialog != null)
      m_timerDialog.destr()
      m_timerDialog = null

    if (m_timer != null)
      m_timer.release()
      m_timer = null
    
    if (m_progressBar != null)
      destroy m_progressBar
      m_progressBar = null

  // --------------------------------------------------------------------------
  override function onEnabled()
    super.onEnabled()
    m_progressBar..setPos(getOwnerUnit().getPos())

  // --------------------------------------------------------------------------
  override function onDisabled()
    super.onDisabled()
    if (getIsRunning())
      cancel()

  // --------------------------------------------------------------------------
  function getTimeRemaining() returns real
    return m_timer != null ? m_timer.getRemaining() : 0.0

  // --------------------------------------------------------------------------
  function getIsRunning() returns bool
    return m_isRunning

  // --------------------------------------------------------------------------
  function getLooter() returns unit
    return m_lootingUnit

  // --------------------------------------------------------------------------
  override function realtimeUpdate(real dt)
    super.realtimeUpdate(dt)

    if (getIsRunning() == false)
      return

    if (m_progressBar != null)
      let percentage01 = parameterize01(m_duration, 0.0, m_timer.getRemaining())
      m_progressBar.setPercentageNow(percentage01)

    // Remove mana per second
    let secondsElapsed = m_timer.getElapsed().floor()
    if (m_secondsElapsed != secondsElapsed)
      m_secondsElapsed = secondsElapsed
      m_lootingUnit.addMana(-m_manaCost)
      if (m_lootingUnit.getMana() == 0)
        FX.createOutOfManaTag(m_lootingUnit.getPos(), m_lootingUnit.getOwner())
        cancel()

  // --------------------------------------------------------------------------
  function start(unit looter, real duration)
    if (getIsRunning())
      return

    m_isRunning = true
    m_lootingUnit = looter
    m_duration = duration

    // Avoid implicit capture of 'this' by caching the result of m_lootableUnit
    let lootableUnitCached = getOwnerUnit()
    m_timer.doManual(duration, true, () -> onOperationFinished(lootableUnitCached))

    // m_progressBar.showForPlayer(looter.getOwner())
    m_progressBar
    ..setPos(looter.getPos())
    ..setSpeed(1.0 / m_duration)
    ..fadeIn()

    m_timerDialog
    ..setTitle("Looting {0}...".format(getOwnerUnit().getName()))
    ..display(looter.getOwner(), true)

    g_looterToOperationMap.put(looter, this)

    m_manaCost = getUnitSearchManaCostPerSecond(m_lootingUnit)

    this.registerForRealtimeUpdate(RealtimeUpdatePriority.Fast)

  // --------------------------------------------------------------------------
  function cancel()
    let lootable = getOwner().getLootableComponent()
    if (lootable != null)
      lootable.onLootingCanceled(m_lootingUnit)
    cleanup()
  
  // --------------------------------------------------------------------------
  private static function onOperationFinished(unit lootable)
    let metadata = lootable.getMetadata()
    if (metadata == null)
      return
    let operation = metadata.getLootOperationComponent()
    if (operation == null or operation.getIsRunning() == false)
      return
    operation.onOperationFinished()

  // --------------------------------------------------------------------------
  private function onOperationFinished()
    let lootable = getOwner().getLootableComponent()
    if (lootable != null)
      lootable.onLootingFinished(m_lootingUnit)
    cleanup()

  // --------------------------------------------------------------------------
  private function cleanup()
    m_isRunning = false
    m_duration = 0.
    m_manaCost = 0
    m_secondsElapsed = 0

    g_looterToOperationMap.remove(m_lootingUnit)
    m_lootingUnit = null

    m_timer.pause()
    m_progressBar.fadeOut()
    m_timerDialog.display(false)

    this.unregisterForRealtimeUpdate()

// ============================================================================
public function IUnitMetadata.getLootOperationComponent() returns LootOperationComponent
  return this.getComponent(LootOperationComponent.typeId) castTo LootOperationComponent

// ============================================================================
public function IUnitMetadata.getOrAddLootOperationComponent() returns LootOperationComponent
  var component = this.getLootOperationComponent()
  if (component == null)
    component = this.addComponent(new LootOperationComponent(this)) castTo LootOperationComponent
  return component

// ============================================================================
function onSpellEndCast()
  if (GetSpellAbilityId() != ABILITY_ID_SEARCH)
    return
  
  let lootingUnit = GetSpellAbilityUnit()
  let lootingOperation = g_looterToOperationMap.get(lootingUnit)
  if (lootingOperation == null)
    return

  lootingUnit.resetAbilityCooldown(ABILITY_ID_SEARCH)

// ============================================================================
function resetUnitAnimationAfterRightClickingSameLootable(unit lootingUnit, LootOperationComponent lootOperation)
  // Stand 4 in HD
  lootingUnit.setAnimation(15)
  // Reset the cooldown and other stats since
  prepareSearchSpell(lootingUnit, lootOperation.getTimeRemaining())

// ============================================================================
function prepareSearchSpell(unit lootingUnit, unit lootableUnit)
  let lootableUnitMetadata = lootableUnit.getMetadata()
  if (lootableUnitMetadata == null)
    return
  let lootableComp = lootableUnitMetadata.getLootableComponent()
  if (lootableComp == null)
    return
  let searchDuration = getUnitSearchDuration(lootingUnit, lootableComp.getSearchDuration())
  prepareSearchSpell(lootingUnit, searchDuration)

// ============================================================================
function prepareSearchSpell(unit lootingUnit, real searchDuration)
  let searchAbility = lootingUnit.getAbility(ABILITY_ID_SEARCH)
  if (searchAbility != null)
    let lvl = 0
    lootingUnit.setAbilityLevel(ABILITY_ID_SEARCH, lvl + 1)
    searchAbility.setField(ABILITY_RLF_DURATION_NORMAL, lvl, searchDuration)
    searchAbility.setField(ABILITY_RLF_DURATION_HERO, lvl, searchDuration)
    searchAbility.setField(ABILITY_RLF_ART_DURATION, lvl, searchDuration)
    searchAbility.setField(ABILITY_RLF_FOLLOW_THROUGH_TIME, lvl, searchDuration)
    searchAbility.setField(ABILITY_RLF_COOLDOWN, lvl, searchDuration)
    lootingUnit.setAbilityLevel(ABILITY_ID_SEARCH, lvl)

// ============================================================================
function onSpellChannel()
  if (GetSpellAbilityId() != ABILITY_ID_SEARCH)
    return

  let lootingUnit = GetSpellAbilityUnit()
  let lootableUnit = GetSpellTargetUnit()

  let looterMetadata = lootingUnit.getMetadata()
  if (looterMetadata == null)
    Log.debug("Searching unit has no metadata")
    lootingUnit.issueImmediateOrderById(Orders.stop)
    lootingUnit.resetAbilityCooldown(TlsAbilityIds.search)
    return
  
  let lootableMetadata = lootableUnit.getMetadata()
  if (lootableMetadata == null)
    Log.debug("Search target has no metadata")
    lootingUnit.issueImmediateOrderById(Orders.stop)
    lootingUnit.resetAbilityCooldown(TlsAbilityIds.search)
    return

  let lootable = lootableMetadata.getLootableComponent()
  if (lootable == null or not lootable.getEnabled())
    lootingUnit.issueImmediateOrderById(Orders.stop)
    lootingUnit.resetAbilityCooldown(TlsAbilityIds.search)
    displayMessageToPlayer(lootingUnit.getOwner(), "Failed To Search".colorize(Colors.red) + " Must target a lootable unit to search")
    return

  let scaledSearchDuration = getUnitSearchDuration(lootingUnit, lootable.getSearchDuration())
  if (canUnitSearchForDuration(lootingUnit, scaledSearchDuration) == false)
    lootingUnit.issueImmediateOrderById(Orders.stop)
    lootingUnit.resetAbilityCooldown(TlsAbilityIds.search)
    displayMessageToPlayer(lootingUnit.getOwner(), "Failed To Search".colorize(Colors.red) + " You do not have enough mana to loot this structure.")
    return

  let lootOperation = lootableMetadata.getLootOperationComponent()
  if (lootOperation != null and lootOperation.getIsRunning())
  //{
    if (lootOperation.getLooter() != lootingUnit)
      lootingUnit.issueImmediateOrderById(Orders.stop)
      lootingUnit.resetAbilityCooldown(TlsAbilityIds.search)
      displayMessageToPlayer(lootingUnit.getOwner(), "Failed To Search".colorize(Colors.red) + " Lootable is already being looted")
      return
    else
      let activeLootingOperation = g_looterToOperationMap.get(lootingUnit)
      if (activeLootingOperation == null or activeLootingOperation != lootOperation)
        Log.error("Expected active looting operation to match")
      // Log.info("unit is actively looting -> resetting")
      resetUnitAnimationAfterRightClickingSameLootable(lootingUnit, activeLootingOperation)
  //}
  else
    // Log.info("unit is starting to loot")
    prepareSearchSpell(lootingUnit, lootableUnit)
    lootable.startLooting(lootingUnit)

// ============================================================================
function onUnitIssuedUnitOrder()
  let orderedUnit = GetOrderedUnit()
  let targetUnit = GetOrderTargetUnit()
  let issuedOrder = GetIssuedOrderId()

  // Stop and issue a search order instead
  if (issuedOrder == Orders.smart and targetUnit.isLootable())
    // Log.info("ordered to search instead")
    orderedUnit.issueTargetOrderById(ABILITY_SEARCH_ORDER, targetUnit)
    return

  let lootingOperation = g_looterToOperationMap.get(orderedUnit) 
  if (lootingOperation == null)
    // Log.info("unit is not currently looting")
    return

  // If the order issued was search and its the same target lootable dont cancel the operation here.
  // Instead, we'll resume the loot operation as if nothing happened.
  if (issuedOrder == ABILITY_SEARCH_ORDER and lootingOperation.getOwnerUnit() == targetUnit)
    // Log.info("ordered to search same lootable")
    return

  // For any other case cancel the current operation
  // Log.info("issued target order cancels looting")
  lootingOperation.cancel()

// ============================================================================
function onUnitIssuedImmediateOrPointOrder()
  let orderedUnit = GetOrderedUnit()
  let lootingOperation = g_looterToOperationMap.get(orderedUnit)
  if (lootingOperation == null)
    return
  // Log.info("issued immediate or point order cancels looting")
  lootingOperation.cancel()

// ============================================================================
init
  
  g_LootOperationProgressBar = new TextProgressBar(PROGRESS_BAR_LENGTH, PROGRESS_BAR_FOREGROUND, PROGRESS_BAR_BACKGROUND)
  g_activeOperations = new LinkedList<LootOperationComponent>()
  
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_CHANNEL, function onSpellChannel)
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_ENDCAST, function onSpellEndCast)
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_ISSUED_UNIT_ORDER, function onUnitIssuedUnitOrder)
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_ISSUED_ORDER, function onUnitIssuedImmediateOrPointOrder)
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER, function onUnitIssuedImmediateOrPointOrder)