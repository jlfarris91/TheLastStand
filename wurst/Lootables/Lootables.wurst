package Lootables
import FullscreenFrame
import ClosureFrames
import StandardTooltip
import UnitPropertiesComponent
import GameConstants
import ErrorHandling
import Time
import FX
import Vector
import UnitExtensions
import UnitIndexer
import Directors
import Math
import LinkedList
import RealtimeUnitComponent
import HashMap
import TimerUtils
import Orders
import ColorUtility
import RegisterEvents
import WorldProgressBar
import Ability_Search
import RealTime
import Notifications
import Icons
import TlsSounds
import DisplayTextToPlayer
import TlsAbilityIds
import HashList
import SoundUtils
import Optional
import ClosureTimers
import GroupUtils
import IProgress
import Command
import GameInstance
import Jobs

// Buildings
public constant int UNIT_ID_LOOTABLE_BARN = 'h01H'
public constant int UNIT_ID_LOOTABLE_BREWERY = 'h013'
public constant int UNIT_ID_LOOTABLE_BUILDING_HORIZONTAL_BLUE = 'h017'
public constant int UNIT_ID_LOOTABLE_BUILDING_HORIZONTAL_GREEN = 'h01X'
public constant int UNIT_ID_LOOTABLE_BUILDING_HORIZONTAL_RED = 'h01J'
public constant int UNIT_ID_LOOTABLE_BUILDING_LARGE_HORIZONTAL_GREEN = 'h01M'
public constant int UNIT_ID_LOOTABLE_BUILDING_LARGE_VERTICAL_PURPLE = 'h01N'
public constant int UNIT_ID_LOOTABLE_BUILDING_CHAPEL = 'h00A'
public constant int UNIT_ID_LOOTABLE_BUILDING_GRANARY = 'h000'
public constant int UNIT_ID_LOOTABLE_HOUSE_LARGE_BLUE = 'h01S'
public constant int UNIT_ID_LOOTABLE_HOUSE_LARGE_RED = 'h005'
public constant int UNIT_ID_LOOTABLE_HOUSE_SMALL_GREEN = 'h001'
public constant int UNIT_ID_LOOTABLE_INN = 'h01L'
public constant int UNIT_ID_LOOTABLE_CATHEDRAL = 'h00G'
public constant int UNIT_ID_LOOTABLE_MARKET = 'h009'
public constant int UNIT_ID_LOOTABLE_MINE = 'h00D'
public constant int UNIT_ID_LOOTABLE_SHIPYARD = 'h008'
public constant int UNIT_ID_LOOTABLE_TAVERN = 'h00B'
public constant int UNIT_ID_LOOTABLE_TENT = 'h01V'
public constant int UNIT_ID_LOOTABLE_TOWER = 'h00C'
public constant int UNIT_ID_LOOTABLE_WINDMILL = 'h00F'

// Objects
public constant int UNIT_ID_LOOTABLE_BARREL = 'h01A'
public constant int UNIT_ID_LOOTABLE_CART = 'h01K'
public constant int UNIT_ID_LOOTABLE_CRATES = 'h007'
public constant int UNIT_ID_LOOTABLE_HAY = 'h002'
public constant int UNIT_ID_LOOTABLE_JUNK_1 = 'h01U'
public constant int UNIT_ID_LOOTABLE_JUNK_2 = 'h01T'
public constant int UNIT_ID_LOOTABLE_MARKET_BAUBLES = 'h006'
public constant int UNIT_ID_LOOTABLE_MARKET_MINECART = 'h00E'
public constant int UNIT_ID_LOOTABLE_MARKET_STALL = 'h004'
public constant int UNIT_ID_LOOTABLE_MARKET_TABLE = 'h003'
public constant int UNIT_ID_LOOTABLE_CAGE = 'h016'

public constant int UNIT_ID_LOOTABLE_SPAWN_OVERRIDE = 'h00M'

constant colorA LOOTABLE_COLOR = colorA(255, 255, 255, 255)
constant colorA LOOTED_COLOR = colorA(150, 150, 150, 150)
constant colorA COUNTDOWN_COLOR = colorA(0, 170, 0, 255)
constant real LOOTABLE_REFRESH_RANGE = 512.0
constant real LOOTABLE_CAMP_RANGE = 512.0
public constant int MAX_LOOT_COUNT = 5

constant int PROGRESS_BAR_LENGTH = 20
constant colorA PROGRESS_BAR_FOREGROUND = colorA(0, 170, 0, 255)
constant colorA PROGRESS_BAR_BACKGROUND = colorA(0, 64, 0, 255)
constant real PROGRESS_BAR_UPDATE_PERIOD = 0.1
constant real LOOTER_STANDING_POS_THRESHOLD_SQ = 64.0 * 64.0

public constant real LOOT_REWARD_NOTIFICATION_DURATION = 15.0

public constant int ABILITY_ID_SEARCH = TlsAbilityIds.search
public constant int ABILITY_ID_LOOTABLE = 'A02C'

constant string LUCKY_HORSHOE_TOOLTIP = "Lucky Horseshoe"
constant string LUCKY_HORSHOE_TOOLTIP_EXTENDED = "This bonus loot was acquired thanks to the Lucky Horseshoe item"

constant string PENDANT_TOOLTIP = "Treasure Hunter's Pendant"
constant string PENDANT_TOOLTIP_EXTENDED = "This loot is a higher rarity thanks to the Treasure Hunter's Pendant item"

Vector<LootableComponent> g_lootableUnits = null
SoundDefinition array[3] g_lootFinishedSound

LinkedList<LootOperationComponent> g_activeOperations
HashMap<unit, LootOperationComponent> g_looterToOperationMap = new HashMap<unit, LootOperationComponent>()

SoundDefinition g_notEnoughManaSoundDef
int array g_notEnoughManaLastPlayedTime

HashList<LootDirector> g_lootDirectors = new HashList<LootDirector>()
int g_lootDirectorsGen = 0
UpdateLootDirectorsJob g_lootDirectorJob = new UpdateLootDirectorsJob()..acquire()

Thread g_lootThread = new Thread("loot")
..setEnabled(true)
..setMaxWorkPerTick(1)
..setTickInterval(0.1)

public HashList<int> g_LootableUnitTypes

SoundDefinition g_lootItemRewardSound

CardInstanceComparator g_cardInstanceComparator = new CardInstanceComparator()

// ============================================================================
public abstract class LootCard extends TieredCard

  static unit s_looter
  static unit s_lootable

  // --------------------------------------------------------------------------
  construct(string id)
    super(id)

  // ----------------------------------------------------------------------------
  static function getLooter() returns unit
    return s_looter

  // ----------------------------------------------------------------------------
  static function getLootable() returns unit
    return s_lootable

  // --------------------------------------------------------------------------
  abstract function activateCard(int tier) returns bool

  // ----------------------------------------------------------------------------
  function getDiscardOnActivate() returns bool
    return false

// ============================================================================
public class LootDirector extends Director
  private LootableComponent m_lootable

  // --------------------------------------------------------------------------
  construct(LootableComponent lootable)
    super("Lootable")
    m_lootable = lootable

  // ----------------------------------------------------------------------------
  override protected function onEnabled()
    super.onEnabled()
    registerActiveLootDirector(this)

    drawLootCards(m_lootable.getMaxLootCount())
    tryUpgradeLootCards()

  // ----------------------------------------------------------------------------
  override protected function onDisabled()
    super.onDisabled()
    unregisterActiveLootDirector(this)

  // --------------------------------------------------------------------------
  override protected function getDifficultyCoefficient() returns real
    return g_GameInstance.getWorldDifficultyCoeff()

  // --------------------------------------------------------------------------
  override function getCreditsPerGeneration() returns real
    return getCreditMultiplier() * (getCreditsOnActivation() / 5) * getDifficultyCoefficient()

  // ----------------------------------------------------------------------------
  private function drawLootCards(int count)

    let maxLootCount = m_lootable.getMaxLootCount()
    let currentLootCount = m_lootable.getLootCount()

    let numCards = clamp(count, 0, max(maxLootCount - currentLootCount, 0))
    if (numCards == 0)
      return

    let deck = getDeck()
    if (deck == null)
      error("Lootable deck is null!")
      return

    var credits = getCredits()
    let deckInstance = deck.createInstance()

    for i = 0 to currentLootCount - 1
      let lootCardInstance = m_lootable.getLoot(i)
      let lootCard = lootCardInstance.card castTo LootCard
      if (lootCard != null and lootCard.getDiscardOnActivate())
        deckInstance.remove(lootCard)

    for i = 0 to numCards - 1
      if (not deckInstance.isEmpty())
        let lootCard = deckInstance.draw() castTo LootCard
        if (lootCard != null)
          let cardInstance = lootCard.getHighestAffordableTier(credits)
          // let cardInstance = new CardInstance(lootCard, 0, lootCard.getCost())
          if (cardInstance != null)
            m_lootable.addLoot(cardInstance)
            credits -= cardInstance.cost
            if (not lootCard.getDiscardOnActivate())
              deckInstance.add(lootCard)

    destroy deckInstance

    setCredits(credits)

  // ----------------------------------------------------------------------------
  private function tryUpgradeLootCards()

    if (not m_lootable.hasLoot())
      return

    var credits = getCredits()
    if (credits == 0)
      return

    // Then loop through each loot reward and try to upgrade its tier using remaining credits.
    // Upgrade in reverse order so that the better loot is at the end of the loot operation.
    // Stop after making a full loop without upgrading any cards.
    let lootCardCount = m_lootable.getLootCount()
    var index = lootCardCount - 1
    var upgradedCard = false
    while (true)
    //{
      let drawnCard = m_lootable.getLoot(index)

      let card = drawnCard.card castTo TieredCard
      let currTier = drawnCard.tier
      let nextTier = currTier + 1
      let currTierCost = drawnCard.cost

      if (card != null and nextTier < card.getTierCount())
        let nextTierCost = card.getCost(nextTier)
        let costToUpgrade = nextTierCost - currTierCost
        if (credits > costToUpgrade)
          drawnCard.tier = nextTier
          drawnCard.cost = nextTierCost
          credits -= costToUpgrade
          upgradedCard = true

      index = wrap(index - 1, 0, lootCardCount - 1)

      // Completed a full loop and wrapped around 
      if (index == lootCardCount - 1)
        if (not upgradedCard)
          break
        upgradedCard = false
    //}

    setCredits(credits)

  // ----------------------------------------------------------------------------
  protected function onDayStart()
    generateCredits()
    drawLootCards(1)
    tryUpgradeLootCards()

// ----------------------------------------------------------------------------
function registerActiveLootDirector(LootDirector director)
  g_lootDirectors.add(director)
  g_lootDirectorsGen++

// ----------------------------------------------------------------------------
function unregisterActiveLootDirector(LootDirector director)
  g_lootDirectors.remove(director)
  g_lootDirectorsGen++

// ============================================================================
class UpdateLootDirectorsJob extends Job
  private HLIterator<LootDirector> m_iter = null
  private int m_lootDirectorsGen = 0
  private int m_count = 0

  // ----------------------------------------------------------------------------
  construct()
    super("uplootdir")

  // ----------------------------------------------------------------------------
  ondestroy
    if (m_iter != null)
      m_iter.close()
      m_iter = null

  // ----------------------------------------------------------------------------
  override function reset()
    super.reset()

    if (m_iter != null)
      m_iter.close()
    m_iter = g_lootDirectors.staticItr()
    m_lootDirectorsGen = g_lootDirectorsGen
    m_count = 0

  // ----------------------------------------------------------------------------
  override function hasNext() returns bool
    return m_iter != null and m_iter.hasNext()

  // ----------------------------------------------------------------------------
  override function next() returns int
    let director = m_iter.next()
    director.onDayStart()
    m_count++
    return 1

  // ----------------------------------------------------------------------------
  override function getDebuggerStateString() returns string
    return m_count.toString() + "/" + g_lootDirectors.size().toString()

// ============================================================================
public class CardInstanceComparator implements Comparator<CardInstance>

  // ----------------------------------------------------------------------------
  override function compare(CardInstance a, CardInstance b) returns int
    return a.cost - b.cost

// ============================================================================
public class LootableComponent extends UnitComponent
  private real m_searchDurationUnscaled
  private unit m_lootingUnit
  private int m_lootRewardMultiplier = 1  
  private int m_dueToLuckyHorseshoe = 0
  private optionalVec2 m_spawnPosOverride = none_vec2()
  private bool m_destroyOnLoot = false
  private LootDirector m_director
  private int m_maxLootCount = 1
  private LinkedList<CardInstance> m_lootCards = new LinkedList<CardInstance>()

  // --------------------------------------------------------------------------
  construct(IUnitMetadata owner)
    super(owner)

    m_searchDurationUnscaled = 3.0
    m_director = new LootDirector(this)

    if (g_lootableUnits == null)
      g_lootableUnits = new Vector<LootableComponent>()

    g_lootableUnits.add(this)

  // --------------------------------------------------------------------------
  ondestroy

    for lootCard in m_lootCards
      destroy lootCard

    destroy m_lootCards
    m_lootCards = null

    if (m_director != null)
      destroy m_director
      m_director = null

  // --------------------------------------------------------------------------
  override function onEnabled()
    super.onEnabled()
    getOwnerUnit().setOwner(PLAYER_LOOTABLES, true)
    m_director.enable()

  // ----------------------------------------------------------------------------
  override function onDisabled()
    super.onDisabled()
    m_director.disable()

  // --------------------------------------------------------------------------
  function canLoot() returns bool
    return hasLoot() and not getIsBeingLooted()

  // --------------------------------------------------------------------------
  function getIsBeingLooted() returns bool
    return m_lootingUnit != null

  // --------------------------------------------------------------------------
  function getSearchDurationPerLoot() returns real
    return m_searchDurationUnscaled

  // --------------------------------------------------------------------------
  function setSearchDurationPerLoot(real duration)
    m_searchDurationUnscaled = duration

  // --------------------------------------------------------------------------
  function getTotalSearchDuration() returns real
    return m_searchDurationUnscaled * getLootCount()

  // ----------------------------------------------------------------------------
  function getMaxLootCount() returns int
    return m_maxLootCount
  
  // ----------------------------------------------------------------------------
  function setMaxLootCount(int value)
    m_maxLootCount = min(value, MAX_LOOT_COUNT)

  // ----------------------------------------------------------------------------
  function getLoot(int index) returns CardInstance
    return m_lootCards.get(index)

  // ----------------------------------------------------------------------------
  function getLootCount() returns int
    return m_lootCards.size()

  // ----------------------------------------------------------------------------
  function addLoot(CardInstance lootCardInstance)
    m_lootCards.insertSorted(lootCardInstance, g_cardInstanceComparator)
    if (m_lootCards.size() == 1)
      makeLootable()

  // ----------------------------------------------------------------------------
  function hasLoot() returns bool
    return not m_lootCards.isEmpty()

  // ----------------------------------------------------------------------------
  function getDirector() returns LootDirector
    return m_director

  // --------------------------------------------------------------------------
  function getSpawnPosition() returns vec2
    return m_spawnPosOverride.reduce(getOwnerUnit().getPos())

  // --------------------------------------------------------------------------
  function setSpawnPosition(vec2 value)
    m_spawnPosOverride = some(value)

  // --------------------------------------------------------------------------
  function setDestroyOnLoot(bool value)
    m_destroyOnLoot = value

  // --------------------------------------------------------------------------
  function startLooting(unit looter, int lootCount)

    if (not canLoot() or getIsBeingLooted())
      return

    let scaledSearchDuration = getUnitSearchDuration(looter, m_searchDurationUnscaled)

    m_lootingUnit = looter

    // Stand 4 in HD
    m_lootingUnit.setAnimation(15)

    let operation = getOwner().getOrAddLootOperationComponent()
    operation.start(looter, scaledSearchDuration, lootCount)

  // --------------------------------------------------------------------------
  protected function onLootingFinished(unit lootingUnit)
    if (m_lootingUnit == null)
      error("m_lootingUnit is null")
      return

    if (lootingUnit == null)
      error("lootingUnit is null")
      return

    if (m_lootingUnit != lootingUnit)
      error("Not the same unit that started looting")
      return

    m_lootingUnit.setAbilityCooldown(ABILITY_ID_SEARCH, 0, 0.0)
    m_lootingUnit = null

  // --------------------------------------------------------------------------
  protected function onLootingCanceled(unit lootingUnit)    
    if (lootingUnit == null)
      return

    if (m_lootingUnit == null)
      return

    if (m_lootingUnit != lootingUnit)
      Log.debug("Not the same unit that started looting")
      makeLootable()
      return

    m_lootingUnit.resetAbilityCooldown(ABILITY_ID_SEARCH)

    FX.createLootingCanceledTag(getOwnerUnit().getPos())

    // reset state so it can be looted again
    m_lootingUnit = null

  // --------------------------------------------------------------------------
  private function makeUnlootable()
    getOwnerUnit().removeAbility(ABILITY_ID_LOOTABLE)
    getOwnerUnit().setVertexColor(LOOTED_COLOR)
    UnitRemoveType(getOwnerUnit(), UNIT_TYPE_ANCIENT)

  // --------------------------------------------------------------------------
  private function makeLootable()
    getOwnerUnit().addAbility(ABILITY_ID_LOOTABLE)
    getOwnerUnit().setVertexColor(LOOTABLE_COLOR)
    // Makes the unit targettable by the search ability
    UnitAddType(getOwnerUnit(), UNIT_TYPE_ANCIENT)

  // --------------------------------------------------------------------------
  function showLootRewardNotification(player _player, LootRewardNotification notification)

    let index = m_lootRewardMultiplier
    let delay = (index - 1) * 0.6
    let dueToLuckyHorseshoe = m_dueToLuckyHorseshoe > 0

    doAfter(delay) () ->
    //{
      notification
      ..setDueToLuckyHorseshoe(dueToLuckyHorseshoe)
      ..show(_player)

      g_lootFinishedSound[index.clamp(0, 2)].playForPlayer(_player)
    //"

    m_lootRewardMultiplier++

  // ----------------------------------------------------------------------------
  function awardLoot(unit lootingUnit)

    if (m_lootCards.isEmpty())
      error("No loot cards available")
      return

    let lootCardInstance = m_lootCards.dequeue()

    if (lootCardInstance == null)
      error("Invalid loot card")
      return

    LootCard.s_lootable = getOwnerUnit()
    LootCard.s_looter = lootingUnit

    let lootCard = lootCardInstance.card castTo LootCard
    if (lootCard != null)
      lootCard.activateCard(lootCardInstance.tier)

    LootCard.s_lootable = null
    LootCard.s_looter = null

    destroy lootCardInstance

    if (m_destroyOnLoot)
      onLootingFinished(lootingUnit)
      getOwnerUnit().remove()
      return

    if (m_lootCards.isEmpty())
      onLootingFinished(lootingUnit)
      makeUnlootable()

  // // --------------------------------------------------------------------------
  // protected function giveRewards(unit lootingUnit)
  //   m_lootRewardMultiplier = 1
  //   let deckInstance = m_director.getDeck().createInstance()
  //   giveRewardsWithChanceToRetrigger(deckInstance, lootingUnit, m_chanceToRetrigger01, true, false)
  //   destroy deckInstance

  // // --------------------------------------------------------------------------
  // private function giveRewardsWithChanceToRetrigger(
  //   DeckInstance deckInstance,
  //   unit lootingUnit,
  //   real chanceToRetrigger01,
  //   bool allowLuckyHorseshoe,
  //   bool rewardDueToLuckyHorseshoe)

  //   // No more rewards to give
  //   if (deckInstance.isEmpty())
  //     return

  //   let ownerUnit = getOwnerUnit()

  //   m_dueToLuckyHorseshoe += rewardDueToLuckyHorseshoe ? 1 : 0

  //   // Give the player their reward
  //   LootCard card = null
  //   while (not deckInstance.isEmpty())
  //   //{
  //     card = deckInstance.drawCard() castTo LootCard

  //     if (card == null)
  //       Log.debug("No reward registered for lootable")
  //       break

  //     if (card.giveReward(ownerUnit, lootingUnit))
  //       break
  //   //}

  //   m_dueToLuckyHorseshoe -= rewardDueToLuckyHorseshoe ? 1 : 0

  //   // Some rewards necessarily must stop the retrigger loop
  //   if (card == null or card.getStopsRetrigger())
  //     return

  //   var chanceToRetriggerWithHoreshoe01 = chanceToRetrigger01
  //   var mutableLuckyHorseshoe = allowLuckyHorseshoe
  //   var mutableRewardDueToLuckyHorseshoe = false

  //   // Lucky Horseshoe item grants a small chance to immediately loot a second time
  //   let metadata = lootingUnit.getMetadata()
  //   if (metadata != null)
  //     let comp = metadata.getUnitPropertiesComponent()
  //     if (comp != null)
  //       chanceToRetriggerWithHoreshoe01 = clamp01(chanceToRetriggerWithHoreshoe01 + comp.getPropertyValue(UnitProperty.LOOT_TWICE_CHANCE_01))
    
  //   let roll = GetRandomReal(0, 1)
  //   if (not passesChanceCheck(chanceToRetriggerWithHoreshoe01, roll))
  //     return

  //   // The chance check would not have passed if it weren't for the effects of lucky horseshoe
  //   if (not passesChanceCheck(chanceToRetrigger01, roll))
  //     displayMessageToPlayer(lootingUnit.getOwner(), "Lucky Horseshoe!".colorize(Colors.lightBlue) + " You found even more loot!")
  //     mutableLuckyHorseshoe = false // Lucky horseshoe can only fire once
  //     mutableRewardDueToLuckyHorseshoe = true

  //   // Give the player another reward and give it another shot to retrigger
  //   giveRewardsWithChanceToRetrigger(deckInstance, lootingUnit, chanceToRetrigger01 / 3.0, mutableLuckyHorseshoe, mutableRewardDueToLuckyHorseshoe)

// ============================================================================
public function IUnitMetadata.getLootableComponent() returns LootableComponent
  return this.getComponent(LootableComponent.typeId) castTo LootableComponent

// ============================================================================
public function IUnitMetadata.getOrAddLootableComponent() returns LootableComponent
  var component = this.getLootableComponent()
  if (component == null)
    component = this.addComponent(new LootableComponent(this)) castTo LootableComponent
  return component

// ============================================================================
function onDayStart()
  if (not g_lootDirectors.isEmpty() and g_lootDirectorJob.getThread() == null)
    g_lootDirectorJob.reset()
    g_lootThread.enqueue(g_lootDirectorJob)

// ============================================================================
function updateLootablesInRange(vec2 pos, real radius)
  let temp = getGroup()
  temp.enumUnitsInRange(pos, radius)
  for _unit in temp
    if (_unit.isLootable())
      updateLootablesNearCamps(_unit)
  temp.release()

// ============================================================================
function updateLootablesNearCamps(unit lootableUnit)

  let metadata = lootableUnit.getMetadata()
  if (metadata == null)
    return

  let comp = metadata.getLootableComponent()
  if (comp == null)
    return

  bool foundCooldownAffector = false
  let temp = getGroup()
  temp.enumUnitsInRange(lootableUnit.getPos(), LOOTABLE_CAMP_RANGE)
  for _unit in temp
    if (unitAffectsLootableCooldown(_unit))
      foundCooldownAffector = true
      break
  temp.release()

  comp.getDirector().setCreditMultiplier(foundCooldownAffector ? 0.5 : 1.0)

// ============================================================================
function unitAffectsLootableCooldown(unit _unit) returns bool
  return _unit.isBuilding() and
         not _unit.isLootable() and
         _unit.getOwner() != PLAYER_VILLAGERS and
         _unit.isAllyOf(PLAYER_VILLAGERS)

// ============================================================================
function onUnitIndexDeindexed()
  updateLootablesInRange(getIndexingUnit().getPos(), LOOTABLE_REFRESH_RANGE)

// ============================================================================
public class LootOperationComponent extends RealtimeUnitComponent
  private unit m_lootingUnit
  private WorldProgressBar m_worldProgressBar
  private Progress m_progress
  private Notification m_notification
  private real m_duration
  private timer m_timer
  private int m_secondsElapsed
  private real m_manaCost
  private bool m_isRunning
  private vec2 m_looterPos

  private Vector<timer> m_lootTimers = new Vector<timer>(MAX_LOOT_COUNT)

  // --------------------------------------------------------------------------
  construct(IUnitMetadata owner)
    super(owner)
    
    m_timer = getTimer()

    m_worldProgressBar = new WorldProgressBar()
    ..setHeight(128.0)
    ..setScale(16.0)

  // --------------------------------------------------------------------------
  ondestroy

    if (m_timer != null)
      m_timer.release()
      m_timer = null
    
    if (m_worldProgressBar != null)
      destroy m_worldProgressBar
      m_worldProgressBar = null

    if (m_notification != null)
      m_notification.close()
      m_notification.release()
      m_notification = null

    if (m_progress != null)
      destroy m_progress
      m_progress = null

    if (m_lootTimers != null)
      for t in m_lootTimers
        if (t != null)
          t.release()
      destroy m_lootTimers

  // --------------------------------------------------------------------------
  override function onEnabled()
    super.onEnabled()
    m_worldProgressBar..setPos(getOwnerUnit().getPos())

  // --------------------------------------------------------------------------
  override function onDisabled()
    super.onDisabled()
    if (getIsRunning())
      cancel()

  // --------------------------------------------------------------------------
  function getTimeRemaining() returns real
    return m_timer != null ? m_timer.getRemaining() : 0.0

  // --------------------------------------------------------------------------
  function getIsRunning() returns bool
    return m_isRunning

  // --------------------------------------------------------------------------
  function getLooter() returns unit
    return m_lootingUnit

  // --------------------------------------------------------------------------
  override function realtimeUpdate(real dt)
    super.realtimeUpdate(dt)

    if (getIsRunning() == false)
      return

    // Catch any edge-case order that would cause the looter to move while still looting
    if (m_lootingUnit.getPos().distanceToSq(m_looterPos) > LOOTER_STANDING_POS_THRESHOLD_SQ)
      cancel()
      return
    
    let percentage01 = parameterize01(m_duration, 0.0, m_timer.getRemaining())
    m_progress.report(percentage01)

    if (m_worldProgressBar != null)
      m_worldProgressBar.setPercentageNow(percentage01)

    // Remove mana per second
    let secondsElapsed = m_timer.getElapsed().floor()
    if (m_secondsElapsed != secondsElapsed)
      m_secondsElapsed = secondsElapsed
      m_lootingUnit.addMana(-m_manaCost)
      if (m_lootingUnit.getMana() == 0)
        FX.createOutOfManaTag(m_lootingUnit.getPos(), m_lootingUnit.getOwner())
        cancel()

  // --------------------------------------------------------------------------
  function start(unit looter, real duration, int lootCount)
    if (getIsRunning())
      return

    m_isRunning = true
    m_lootingUnit = looter
    m_duration = duration * lootCount

    // Avoid implicit capture of 'this' by caching the result of m_lootableUnit
    let lootableUnitCached = getOwnerUnit()

    m_lootTimers.resize(lootCount)
    let timeBetweenLoot = m_duration / lootCount
    for i = 1 to lootCount
      let lootTimer = getTimer()..doManual(timeBetweenLoot * i, true, () -> onAwardLoot(lootableUnitCached, i - 1))
      m_lootTimers.add(lootTimer)
    
    let lootingPlayer = looter.getOwner()
    let cameraPos = getOwnerUnit().getPos()
    m_looterPos = looter.getPos()

    m_timer.doManual(m_duration, true, () -> onOperationFinished(lootableUnitCached))

    m_progress = new Progress()
    m_progress.report("Looting {0}...".format(getOwnerUnit().getName()))

    m_worldProgressBar
    ..setPos(looter.getPos())
    ..setSpeed(1.0 / (m_duration != 0.0 ? m_duration : 1.0))
    ..fadeIn()

    m_notification = new Notification(m_duration)
    ..setProgress(m_progress)
    ..setIconPath(Icons.bTNTelescope)
    ..setMessage("Looting {0}...".format(getOwnerUnit().getName()))
    ..setCanClose(false)
    ..setClickCommand(new RoutedCommand(() -> begin
      if (localPlayer == lootingPlayer)
        PanCameraToTimedForPlayer(lootingPlayer, cameraPos.x, cameraPos.y, 0)
    end))
    ..show(lootingPlayer)
    ..acquire()

    g_looterToOperationMap.put(looter, this)

    m_manaCost = getUnitSearchManaCostPerSecond(m_lootingUnit)

    this.registerForRealtimeUpdate(RealtimeUpdatePriority.Fast)

  // --------------------------------------------------------------------------
  function cancel()
    let lootable = getOwner().getLootableComponent()
    if (lootable != null)
      lootable.onLootingCanceled(m_lootingUnit)
    cleanup()
  
  // --------------------------------------------------------------------------
  private static function onOperationFinished(unit lootable)
    let metadata = lootable.getMetadata()
    if (metadata == null)
      return
    let operation = metadata.getLootOperationComponent()
    if (operation == null or operation.getIsRunning() == false)
      return
    operation.onOperationFinished()

  // --------------------------------------------------------------------------
  private function onOperationFinished()
    cleanup()

  // ----------------------------------------------------------------------------
  private static function onAwardLoot(unit lootable, int index)
    let metadata = lootable.getMetadata()
    if (metadata == null)
      return
    let operation = metadata.getLootOperationComponent()
    if (operation == null or operation.getIsRunning() == false)
      return
    operation.onAwardLoot(index)

  // --------------------------------------------------------------------------
  private function onAwardLoot(int index)
    let lootable = getOwner().getLootableComponent()
    if (lootable != null)
      lootable.awardLoot(m_lootingUnit)

    let lootTimer = m_lootTimers.get(index)
    if (lootTimer != null)
      lootTimer.release()
      m_lootTimers.set(index, null)

  // --------------------------------------------------------------------------
  private function cleanup()
    m_isRunning = false
    m_duration = 0.
    m_manaCost = 0
    m_secondsElapsed = 0

    g_looterToOperationMap.remove(m_lootingUnit)
    m_lootingUnit = null

    m_timer.pause()
    m_worldProgressBar.fadeOut()
    
    if (m_notification != null)
      m_notification.close()
      m_notification.release()
      m_notification = null

    if (m_progress != null)
      destroy m_progress
      m_progress = null

    for t in m_lootTimers
      if (t != null)
        t.release()
    m_lootTimers.clear()

    this.unregisterForRealtimeUpdate()

// ============================================================================
public function IUnitMetadata.getLootOperationComponent() returns LootOperationComponent
  return this.getComponent(LootOperationComponent.typeId) castTo LootOperationComponent

// ============================================================================
public function IUnitMetadata.getOrAddLootOperationComponent() returns LootOperationComponent
  var component = this.getLootOperationComponent()
  if (component == null)
    component = this.addComponent(new LootOperationComponent(this)) castTo LootOperationComponent
  return component

// ============================================================================
function onSpellEndCast()
  if (GetSpellAbilityId() != ABILITY_ID_SEARCH)
    return
  
  let lootingUnit = GetSpellAbilityUnit()
  let lootingOperation = g_looterToOperationMap.get(lootingUnit)
  if (lootingOperation == null)
    return

  lootingUnit.resetAbilityCooldown(ABILITY_ID_SEARCH)

// ============================================================================
function resetUnitAnimationAfterRightClickingSameLootable(unit lootingUnit, LootOperationComponent lootOperation)
  // Stand 4 in HD
  lootingUnit.setAnimation(15)
  // Reset the cooldown and other stats since
  prepareSearchSpell(lootingUnit, lootOperation.getTimeRemaining())

// ============================================================================
function prepareSearchSpell(unit lootingUnit, unit lootableUnit, int lootCount)
  let lootableUnitMetadata = lootableUnit.getMetadata()
  if (lootableUnitMetadata == null)
    return
  let lootableComp = lootableUnitMetadata.getLootableComponent()
  if (lootableComp == null)
    return
  let adjustedSearchDurationPerLoot = getUnitSearchDuration(lootingUnit, lootableComp.getSearchDurationPerLoot())
  let totalSearchDuration = adjustedSearchDurationPerLoot * lootCount
  prepareSearchSpell(lootingUnit, totalSearchDuration)

// ============================================================================
function prepareSearchSpell(unit lootingUnit, real searchDuration)
  let searchAbility = lootingUnit.getAbility(ABILITY_ID_SEARCH)
  if (searchAbility != null)
    let lvl = 0
    lootingUnit.setAbilityLevel(ABILITY_ID_SEARCH, lvl + 1)
    searchAbility.setField(ABILITY_RLF_DURATION_NORMAL, lvl, searchDuration)
    searchAbility.setField(ABILITY_RLF_DURATION_HERO, lvl, searchDuration)
    searchAbility.setField(ABILITY_RLF_ART_DURATION, lvl, searchDuration)
    searchAbility.setField(ABILITY_RLF_FOLLOW_THROUGH_TIME, lvl, searchDuration)
    searchAbility.setField(ABILITY_RLF_COOLDOWN, lvl, searchDuration)
    lootingUnit.setAbilityLevel(ABILITY_ID_SEARCH, lvl)

// ============================================================================
function onSpellChannel()
  if (GetSpellAbilityId() != ABILITY_ID_SEARCH)
    return

  let lootingUnit = GetSpellAbilityUnit()
  let lootableUnit = GetSpellTargetUnit()
  let lootingPlayer = lootingUnit.getOwner()

  let looterMetadata = lootingUnit.getMetadata()
  if (looterMetadata == null)
    Log.debug("Searching unit has no metadata")
    lootingUnit.issueImmediateOrderById(Orders.stop)
    lootingUnit.resetAbilityCooldown(TlsAbilityIds.search)
    return
  
  let lootableMetadata = lootableUnit.getMetadata()
  if (lootableMetadata == null)
    Log.debug("Search target has no metadata")
    lootingUnit.issueImmediateOrderById(Orders.stop)
    lootingUnit.resetAbilityCooldown(TlsAbilityIds.search)
    return

  let lootable = lootableMetadata.getLootableComponent()
  if (lootable == null or not lootable.getEnabled())
    lootingUnit.issueImmediateOrderById(Orders.stop)
    lootingUnit.resetAbilityCooldown(TlsAbilityIds.search)
    displayMessageToPlayer(lootingPlayer, "Failed To Search".colorize(Colors.red) + " Must target a lootable unit to search")
    TlsSounds.errorSoundDef.playForPlayer(lootingPlayer)
    return

  var scaledSearchDuration = getUnitSearchDuration(lootingUnit, lootable.getSearchDurationPerLoot())
  scaledSearchDuration = max(scaledSearchDuration, 0.1)

  let manaRemainingAfterSearch = calculateManaRemainingAfterLootOperation(lootingUnit, scaledSearchDuration)
  if (manaRemainingAfterSearch < 0)
  //{
    lootingUnit.issueImmediateOrderById(Orders.stop)
    lootingUnit.resetAbilityCooldown(TlsAbilityIds.search)
    let manaNeeded = (lootingUnit.getMana() + manaRemainingAfterSearch.abs()).floor()
    displayMessageToPlayer(lootingPlayer, "Failed To Search".colorize(Colors.red) + " You need {0} mana to loot this structure.".format(manaNeeded.toString()))
    TlsSounds.errorSoundDef.playForPlayer(lootingPlayer)
    if (getRealTimeSeconds() - g_notEnoughManaLastPlayedTime[lootingPlayer.getId()] > 2)
      g_notEnoughManaLastPlayedTime[lootingPlayer.getId()] = getRealTimeSeconds()
      doAfter(0.5, () -> g_notEnoughManaSoundDef.playForPlayer(lootingPlayer))
    return
  //}

  let lootOperation = lootableMetadata.getLootOperationComponent()
  if (lootOperation != null and lootOperation.getIsRunning())
  //{
    if (lootOperation.getLooter() != lootingUnit)
      lootingUnit.issueImmediateOrderById(Orders.stop)
      lootingUnit.resetAbilityCooldown(TlsAbilityIds.search)
      displayMessageToPlayer(lootingPlayer, "Failed To Search".colorize(Colors.red) + " Lootable is already being looted")
      TlsSounds.errorSoundDef.playForPlayer(lootingPlayer)
      return
    else
      let activeLootingOperation = g_looterToOperationMap.get(lootingUnit)
      if (activeLootingOperation == null or activeLootingOperation != lootOperation)
        Log.error("Expected active looting operation to match")
      // Log.info("unit is actively looting -> resetting")
      resetUnitAnimationAfterRightClickingSameLootable(lootingUnit, activeLootingOperation)
  //}
  else
  //{
    let lootCountPossible = max(1, (manaRemainingAfterSearch / scaledSearchDuration).floor())
    let lootCountActual = clamp(lootCountPossible, 0, lootable.getLootCount())
    // Log.info("unit is starting to loot {0} times".format(lootCountActual.toString()))
    prepareSearchSpell(lootingUnit, lootableUnit, lootCountActual)
    lootable.startLooting(lootingUnit, lootCountActual)
  //}

// ============================================================================
function onUnitIssuedUnitOrder()
  let orderedUnit = GetOrderedUnit()
  let targetUnit = GetOrderTargetUnit()
  let issuedOrder = GetIssuedOrderId()

  let unitCanSearch = orderedUnit.hasAbility(TlsAbilityIds.search)

  // Stop and issue a search order instead
  if (issuedOrder == Orders.smart and targetUnit.isLootable() and unitCanSearch)
    // Log.info("ordered to search instead")
    if (not orderedUnit.issueTargetOrder(ABILITY_SEARCH_ORDER, targetUnit))
      Log.debug("Could not issue search order")
    return

  if (issuedOrder == OrderId(ABILITY_SEARCH_ORDER_HEROACTION) and targetUnit.isLootable() and unitCanSearch)
    if (not orderedUnit.issueTargetOrder(ABILITY_SEARCH_ORDER, targetUnit))
      Log.debug("Could not issue search order")
    return

  let lootingOperation = g_looterToOperationMap.get(orderedUnit) 
  if (lootingOperation == null)
    // Log.info("unit is not currently looting")
    return

  // If the order issued was search and its the same target lootable dont cancel the operation here.
  // Instead, we'll resume the loot operation as if nothing happened.
  if (issuedOrder == OrderId(ABILITY_SEARCH_ORDER) and lootingOperation.getOwnerUnit() == targetUnit)
    // Log.info("ordered to search same lootable")
    return

  // For any other case cancel the current operation
  // Log.info("issued target order cancels looting")
  lootingOperation.cancel()

// ============================================================================
function onUnitIssuedImmediateOrPointOrder()
  let orderedUnit = GetOrderedUnit()
  let lootingOperation = g_looterToOperationMap.get(orderedUnit)
  if (lootingOperation == null)
    return
  // Log.info("issued immediate or point order cancels looting")
  lootingOperation.cancel()

// ============================================================================
public class LootRewardNotification extends Notification
  private player m_player
  private vec2 m_cameraPos
  private SoundDefinition m_soundDef
  private bool m_dueToLuckyHorseshoe
  private bool m_affectedByLuckyPendant

  // --------------------------------------------------------------------------
  construct (int id, player p, vec2 cameraPos, SoundDefinition soundDef)
    super(id, LOOT_REWARD_NOTIFICATION_DURATION)

    m_player = p
    m_cameraPos = cameraPos
    m_soundDef = soundDef
    m_dueToLuckyHorseshoe = false
    m_affectedByLuckyPendant = false

    setClickCommand(new RoutedCommand(() -> onClick()))

  // --------------------------------------------------------------------------
  function getDueToLuckyHorseshoe() returns bool
    return m_dueToLuckyHorseshoe

  // --------------------------------------------------------------------------
  function setDueToLuckyHorseshoe(bool value)
    m_dueToLuckyHorseshoe = value

  // --------------------------------------------------------------------------
  function getAffectedByLuckyPendant() returns bool
    return m_affectedByLuckyPendant

  // --------------------------------------------------------------------------
  function setAffectedByLuckyPendant(bool value)
    m_affectedByLuckyPendant = value

  // --------------------------------------------------------------------------
  override function onShow()
    super.onShow()

    if (m_soundDef != null)
      doAfter(0.15, () -> m_soundDef.playForPlayer(m_player))      

  // --------------------------------------------------------------------------
  private function onClick()
    if (localPlayer == m_player)
      PanCameraToTimedForPlayer(m_player, m_cameraPos.x, m_cameraPos.y, 0)

// ============================================================================
public class LootRewardNotificationFrame extends TextSimpleNotificationFrame
  private framehandle m_luckyHorseshoeFrame
  private framehandle m_pendantFrame

  // --------------------------------------------------------------------------
  construct ()
    super (createFrame("LootRewardNotification", CONSOLE_UI_BACKDROP, 0, 0))

    m_luckyHorseshoeFrame = getFrame("HorseshoeFrame")
    ..onMouseEnter(() -> StandardTooltip.show(LUCKY_HORSHOE_TOOLTIP, LUCKY_HORSHOE_TOOLTIP_EXTENDED, GetTriggerPlayer()))
    ..onMouseLeave(() -> StandardTooltip.hide(GetTriggerPlayer()))
    ..hide()

    m_pendantFrame = getFrame("PendantFrame")
    ..onMouseEnter(() -> StandardTooltip.show(PENDANT_TOOLTIP, PENDANT_TOOLTIP_EXTENDED, GetTriggerPlayer()))
    ..onMouseLeave(() -> StandardTooltip.hide(GetTriggerPlayer()))
    ..hide()

  // --------------------------------------------------------------------------
  override protected function updateFrame()
    super.updateFrame()

    let lootRewardNotification = m_notification castTo LootRewardNotification
    var offset = vec2(-0.0025, -0.0025)

    let luckyHorseshoeVisible = lootRewardNotification != null and lootRewardNotification.getDueToLuckyHorseshoe()
    m_luckyHorseshoeFrame.setVisible(luckyHorseshoeVisible)
    if (luckyHorseshoeVisible)
      m_luckyHorseshoeFrame.setPoint(FRAMEPOINT_TOPRIGHT, m_frame, FRAMEPOINT_TOPRIGHT, offset.x, offset.y)
      offset.x -= m_luckyHorseshoeFrame.getWidth() + 0.0025

    let pendantFrameVisible = lootRewardNotification != null and lootRewardNotification.getAffectedByLuckyPendant()
    m_pendantFrame.setVisible(pendantFrameVisible)
    if (pendantFrameVisible)
      m_pendantFrame.setPoint(FRAMEPOINT_TOPRIGHT, m_frame, FRAMEPOINT_TOPRIGHT, offset.x, offset.y)

// ============================================================================
public function unit.isLootable() returns bool
  return g_LootableUnitTypes.has(this.getTypeId())

// ============================================================================
public function getUnitSearchDuration(unit looter, real unscaledSearchDuration) returns real
  var searchDuration = unscaledSearchDuration
  // Shapeshifting Key decreases duration by 50%
  let metadata = looter.getMetadata()
  if (metadata != null)
    let comp = metadata.getUnitPropertiesComponent()
    if (comp != null)
      searchDuration *= comp.getPropertyValue(UnitProperty.LOOT_DURATION_SCALE)
  return searchDuration

// ============================================================================
public function getUnitSearchManaCostPerSecond(unit looter) returns real  
  var manaCostPerSecond = looter.getAbility(ABILITY_ID_SEARCH).getField(ABILITY_ILF_MANA_COST, 0).toReal()
  let metadata = looter.getMetadata()
  if (metadata != null)
    let comp = metadata.getUnitPropertiesComponent()
    if (comp != null)
      manaCostPerSecond *= comp.getPropertyValue(UnitProperty.LOOT_MANA_COST_SCALE)
  return manaCostPerSecond

// ============================================================================
public function canUnitSearchForDuration(unit looter, real duration) returns bool
  return calculateManaRemainingAfterLootOperation(looter, duration) > 0

// ============================================================================
public function calculateManaRemainingAfterLootOperation(unit looter, real duration) returns int
  let manaCostPerSecond = getUnitSearchManaCostPerSecond(looter)
  let startingMana = looter.getMana()
  let manaRegenPerSecond = looter.getField(UNIT_RF_MANA_REGENERATION)
  let totalManaRegened = manaRegenPerSecond * duration
  let totalManaDrained = manaCostPerSecond * duration
  let manaAfterRegen = startingMana + totalManaRegened
  return (manaAfterRegen - totalManaDrained).floor()

// ============================================================================
init
  NotificationManager.notificationFrameFactory.registerFactory(LootRewardNotification.typeId, () -> new LootRewardNotificationFrame())

  g_lootItemRewardSound = new SoundDefinition("sound\\interface\\pickupitem.flac", false, false)
  g_lootItemRewardSound.volume = 126

  g_LootableUnitTypes = new HashList<int>()

  // Buildings
  g_LootableUnitTypes.add(UNIT_ID_LOOTABLE_BARN)
  g_LootableUnitTypes.add(UNIT_ID_LOOTABLE_BREWERY)
  g_LootableUnitTypes.add(UNIT_ID_LOOTABLE_BUILDING_HORIZONTAL_BLUE)
  g_LootableUnitTypes.add(UNIT_ID_LOOTABLE_BUILDING_HORIZONTAL_GREEN)
  g_LootableUnitTypes.add(UNIT_ID_LOOTABLE_BUILDING_HORIZONTAL_RED)
  g_LootableUnitTypes.add(UNIT_ID_LOOTABLE_BUILDING_LARGE_HORIZONTAL_GREEN)
  g_LootableUnitTypes.add(UNIT_ID_LOOTABLE_BUILDING_LARGE_VERTICAL_PURPLE)
  g_LootableUnitTypes.add(UNIT_ID_LOOTABLE_BUILDING_CHAPEL)
  g_LootableUnitTypes.add(UNIT_ID_LOOTABLE_BUILDING_GRANARY)
  g_LootableUnitTypes.add(UNIT_ID_LOOTABLE_HOUSE_LARGE_BLUE)
  g_LootableUnitTypes.add(UNIT_ID_LOOTABLE_HOUSE_LARGE_RED)
  g_LootableUnitTypes.add(UNIT_ID_LOOTABLE_HOUSE_SMALL_GREEN)
  g_LootableUnitTypes.add(UNIT_ID_LOOTABLE_INN)
  g_LootableUnitTypes.add(UNIT_ID_LOOTABLE_CATHEDRAL)
  g_LootableUnitTypes.add(UNIT_ID_LOOTABLE_MARKET)
  g_LootableUnitTypes.add(UNIT_ID_LOOTABLE_MINE)
  g_LootableUnitTypes.add(UNIT_ID_LOOTABLE_SHIPYARD)
  g_LootableUnitTypes.add(UNIT_ID_LOOTABLE_TAVERN)
  g_LootableUnitTypes.add(UNIT_ID_LOOTABLE_TENT)
  g_LootableUnitTypes.add(UNIT_ID_LOOTABLE_TOWER)
  g_LootableUnitTypes.add(UNIT_ID_LOOTABLE_WINDMILL)

  // Objects
  g_LootableUnitTypes.add(UNIT_ID_LOOTABLE_BARREL)
  g_LootableUnitTypes.add(UNIT_ID_LOOTABLE_CART)
  g_LootableUnitTypes.add(UNIT_ID_LOOTABLE_CRATES)
  g_LootableUnitTypes.add(UNIT_ID_LOOTABLE_MARKET_BAUBLES)
  g_LootableUnitTypes.add(UNIT_ID_LOOTABLE_MARKET_STALL)
  g_LootableUnitTypes.add(UNIT_ID_LOOTABLE_MARKET_TABLE)
  g_LootableUnitTypes.add(UNIT_ID_LOOTABLE_MARKET_MINECART)
  g_LootableUnitTypes.add(UNIT_ID_LOOTABLE_HAY)
  g_LootableUnitTypes.add(UNIT_ID_LOOTABLE_JUNK_1)
  g_LootableUnitTypes.add(UNIT_ID_LOOTABLE_JUNK_2)
  g_LootableUnitTypes.add(UNIT_ID_LOOTABLE_CAGE)

  g_activeOperations = new LinkedList<LootOperationComponent>()
  
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_CHANNEL, function onSpellChannel)
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_ENDCAST, function onSpellEndCast)
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_ISSUED_UNIT_ORDER, function onUnitIssuedUnitOrder)
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_ISSUED_ORDER, function onUnitIssuedImmediateOrPointOrder)
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER, function onUnitIssuedImmediateOrPointOrder)

  g_notEnoughManaSoundDef = new SoundDefinition("sound\\dialogue\\genericwarnings\\genericwarningnomana1.flac")

  registerDayEvent(function onDayStart)
  onUnitIndex(() -> onUnitIndexDeindexed())
  onUnitDeindex(() -> onUnitIndexDeindexed())
  
  for i = 0 to 2
    g_lootFinishedSound[i] = new SoundDefinition("sound\\interface\\goodjob.flac", false, false)
    g_lootFinishedSound[i].volume = 100
    g_lootFinishedSound[i].pitch += i * 0.1

  