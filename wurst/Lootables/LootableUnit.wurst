package LootableUnit
import WeightedSet
import GameConstants
import TextProgressBar
import TextProgressBarTag
import UnitMetadata
import ClosureTimers
import LootableReward
import ErrorHandling
import Events
import Vector
import Pool

constant int ABILITY_ID_LOOTABLE = 'A02C'
constant colorA LOOTABLE_COLOR = colorA(255, 255, 255, 255)
constant colorA LOOTED_COLOR = colorA(150, 150, 150, 150)

constant int PROGRESS_BAR_LENGTH = 20
constant colorA PROGRESS_BAR_FOREGROUND = colorA(0, 170, 0, 255)
constant colorA PROGRESS_BAR_BACKGROUND = colorA(0, 64, 0, 255)
constant real PROGRESS_BAR_UPDATE_PERIOD = 0.1

TextProgressBar g_LootOperationProgressBar
Vector<LootableUnit> g_lootableUnits
Pool<LootOperation> g_activeOperations

// ============================================================================
public class LootableUnit extends UnitMetadata
  private WeightedSet<ILootableReward> _rewards
  private real _searchDuration
  private bool _isBeingLooted
  private int _cooldown

  // --------------------------------------------------------------------------
  construct()
    super()

    this._searchDuration = 3.0
    this._isBeingLooted = false
    this._cooldown = 0
    this._rewards = new WeightedSet<ILootableReward>()

    g_lootableUnits.add(this)

  // --------------------------------------------------------------------------
  ondestroy
    for reward in _rewards
      destroy reward
    destroy _rewards
    _rewards = null
    
  // --------------------------------------------------------------------------
  override function onUnitChanged(unit oldUnit, unit newUnit)
    super.onUnitChanged(oldUnit, newUnit)

    // All lootables belong to the Villagers player
    getUnit().setOwner(PLAYER_VILLAGERS, true)

    this.onLootable()

  // --------------------------------------------------------------------------
  @inline
  override function getUnit() returns unit
    return super.getUnit()
    
  // --------------------------------------------------------------------------
  @inline
  override function addComponent(IComponent component) returns IComponent
    return super.addComponent(component)

  // --------------------------------------------------------------------------
  @inline
  override function getComponent(Type componentTypeId) returns IComponent
    return super.getComponent(componentTypeId)

  // --------------------------------------------------------------------------
  function getRewardsSet() returns WeightedSet<ILootableReward>
    return _rewards

  // --------------------------------------------------------------------------
  function getPos() returns vec2
    return getUnit().getPos()

  // --------------------------------------------------------------------------
  function getSearchDuration() returns real
    return _searchDuration

  // --------------------------------------------------------------------------
  function setSearchDuration(real duration)
    _searchDuration = duration

  // --------------------------------------------------------------------------
  function isBeingLooted() returns bool
    return _isBeingLooted

  // --------------------------------------------------------------------------
  function canLoot(IUnitMetadata _lootingUnit) returns bool
    return _cooldown == 0 and not _isBeingLooted

  // --------------------------------------------------------------------------
  function resetCooldown()
    if (this._cooldown == 0)
      return
    this._cooldown = 0
    this.onLootable()

  // --------------------------------------------------------------------------
  function decrementCooldown()
    if (this._cooldown == 0)
      return
    this._cooldown--
    if (this._cooldown == 0)
      onLootable()

  // --------------------------------------------------------------------------
  function startLooting(IUnitMetadata lootingUnit)
    if (not canLoot(lootingUnit))
      return
    this._cooldown = GetRandomInt(LOOTABLES_COOLDOWN_MIN, LOOTABLES_COOLDOWN_MAX)
    this._isBeingLooted = true
    lootingUnit.pause()
    startLootOperation(lootingUnit, this, _searchDuration)

  // --------------------------------------------------------------------------
  protected function onLootingFinished(IUnitMetadata lootingUnit)
    this._isBeingLooted = false
    lootingUnit.unpause()
    this.giveLoot(lootingUnit)
    this.onLooted()

  // --------------------------------------------------------------------------
  protected function giveLoot(IUnitMetadata lootingUnit)
    let reward = _rewards.getRandom()
    if (reward == null)
      error("No reward registered for lootable")
    reward.giveReward(this, lootingUnit)

  // --------------------------------------------------------------------------
  private function onLooted()
    this.getUnit().removeAbility(ABILITY_ID_LOOTABLE)
    this.getUnit().setVertexColor(LOOTED_COLOR)
    UnitRemoveType(this.getUnit(), UNIT_TYPE_ANCIENT)

  // --------------------------------------------------------------------------
  private function onLootable()
    this.getUnit().addAbility(ABILITY_ID_LOOTABLE)
    this.getUnit().setVertexColor(LOOTABLE_COLOR)
    // Makes the unit targettable by the search ability
    UnitAddType(this.getUnit(), UNIT_TYPE_ANCIENT)

// ============================================================================
public class EnterableLootable extends LootableUnit

  // --------------------------------------------------------------------------
  override function startLooting(IUnitMetadata lootingUnit)
    if (not canLoot(lootingUnit))
      return
    super.startLooting(lootingUnit)
    lootingUnit.hide()
    this.getUnit().shareVision(lootingUnit.getOwner(), true)

  // --------------------------------------------------------------------------
  override function onLootingFinished(IUnitMetadata lootingUnit)
    super.onLootingFinished(lootingUnit)
    this.getUnit().shareVision(lootingUnit.getOwner(), false)
    lootingUnit.show()
    lootingUnit.getOwner().selectSingle(lootingUnit.getUnit())

// ============================================================================
class LootOperation
  private IUnitMetadata _lootingUnit
  private LootableUnit _lootable
  private ProgressBarTag _progressBar
  private poolHandle _poolHandle
  private real _elapsed
  private real _duration

  // --------------------------------------------------------------------------
  construct(IUnitMetadata lootingUnit, LootableUnit lootable, real duration)
    _lootingUnit = lootingUnit
    _lootable = lootable
    _duration = duration
    _elapsed = 0.0

    if (_duration <= 0.0)
      error("Argument 'duration' must be greater than zero")
    
    _progressBar = new ProgressBarTag(g_LootOperationProgressBar, _lootable.getPos().withZ(0.0), 10.0)
    _progressBar.showForPlayer(_lootingUnit.getOwner())

    registerForUpdate()

  // --------------------------------------------------------------------------
  ondestroy
    unregisterForUpdate()
    
    if (_progressBar != null)
      destroy _progressBar
      _progressBar = null

  // --------------------------------------------------------------------------
  private function registerForUpdate()
    unregisterForUpdate()
    _poolHandle = g_activeOperations.reserve(this)

  // --------------------------------------------------------------------------
  private function unregisterForUpdate()
    if (_poolHandle == INVALID_POOL_HANDLE)
      return
    
    if (g_activeOperations.isHandleValid(_poolHandle))
      g_activeOperations.release(_poolHandle)
    
    _poolHandle = INVALID_POOL_HANDLE

  // --------------------------------------------------------------------------
  function update()
    _elapsed += PROGRESS_BAR_UPDATE_PERIOD

    if (_progressBar != null)
      _progressBar.update(_elapsed / _duration)

    if (_elapsed >= _duration)
      onOperationFinished()
  
  // --------------------------------------------------------------------------
  private function onOperationFinished()
    _lootable.onLootingFinished(_lootingUnit)
    destroy this

// ============================================================================
function startLootOperation(IUnitMetadata lootingUnit, LootableUnit lootable, real duration) returns LootOperation
  return new LootOperation(lootingUnit, lootable, duration)

// ============================================================================
function onDayStart()
  for lootableUnit in g_lootableUnits
    lootableUnit.decrementCooldown()

// ============================================================================
function updateProgressBars()
  for ph in g_activeOperations
    if (g_activeOperations.isHandleValid(ph))
      let lootOperation = g_activeOperations.get(ph)
      if(lootOperation != null)
        lootOperation.update()

// ============================================================================
init
  g_LootOperationProgressBar = new TextProgressBar(PROGRESS_BAR_LENGTH, PROGRESS_BAR_FOREGROUND, PROGRESS_BAR_BACKGROUND)
  g_lootableUnits = new Vector<LootableUnit>(256)
  g_activeOperations = new Pool<LootOperation>(32)

  registerDayEvent(function onDayStart)

  doPeriodically(PROGRESS_BAR_UPDATE_PERIOD, (cb) -> updateProgressBars())