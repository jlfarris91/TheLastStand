package LootableComponent
import UnitComponent
import GameConstants
import Range
import Lootables
import Math
import DisplayTextToPlayer
import ColorUtility
import ErrorHandling
import Time
import FX
import Vector
import initlater LootOperationComponent
import UnitPropertiesComponent
import SoundUtils
import ClosureTimers
import Optional
import GroupUtils
import UnitExtensions
import UnitIndexer
import Deck

constant colorA LOOTABLE_COLOR = colorA(255, 255, 255, 255)
constant colorA LOOTED_COLOR = colorA(150, 150, 150, 150)
constant colorA COUNTDOWN_COLOR = colorA(0, 170, 0, 255)
constant real LOOTABLE_REFRESH_RANGE = 512.0
constant real LOOTABLE_CAMP_RANGE = 512.0

Vector<LootableComponent> g_lootableUnits = null
SoundDefinition array[3] g_lootFinishedSound

// ============================================================================
public class LootableComponent extends UnitComponent
  private real m_searchDurationUnscaled
  private int m_cooldownDays
  private unit m_lootingUnit
  private texttag m_cooldownDayTextTag
  private real m_chanceToRetrigger01
  private rangeInt m_cooldownDaysRange
  private int m_lootRewardMultiplier = 1  
  private int m_dueToLuckyHorseshoe = 0
  private optionalVec2 m_spawnPosOverride = none_vec2()
  private bool m_destroyOnLoot = false
  private LootableDirector m_director

  // --------------------------------------------------------------------------
  construct(IUnitMetadata owner)
    super(owner)

    m_searchDurationUnscaled = 3.0
    m_cooldownDays = 0
    m_cooldownDaysRange = LOOTABLES_DEFAULT_COOLDOWN_RANGE

    m_director = new LootableDirector(getOwnerUnit())

    if (g_lootableUnits == null)
      g_lootableUnits = new Vector<LootableComponent>()

    g_lootableUnits.add(this)

  // --------------------------------------------------------------------------
  ondestroy

    if (m_cooldownDayTextTag != null)
      m_cooldownDayTextTag.destr()
      m_cooldownDayTextTag = null

  // --------------------------------------------------------------------------
  override function onEnabled()
    super.onEnabled()

    getOwnerUnit().setOwner(PLAYER_LOOTABLES, true)
    
    if (m_cooldownDayTextTag != null)
      m_cooldownDayTextTag.setPos(getOwnerUnit().getPos().withZ(20.0))

    resetCooldown()
    onLootable()

  // --------------------------------------------------------------------------
  function canLoot() returns bool
    return not getIsLooted() and not getIsBeingLooted()

  // --------------------------------------------------------------------------
  function getIsLooted() returns bool
    return m_cooldownDays > 0

  // --------------------------------------------------------------------------
  function getIsBeingLooted() returns bool
    return m_lootingUnit != null

  // --------------------------------------------------------------------------
  function getSearchDuration() returns real
    return m_searchDurationUnscaled

  // --------------------------------------------------------------------------
  function setSearchDuration(real duration)
    m_searchDurationUnscaled = duration

  // --------------------------------------------------------------------------
  function getChanceToRetrigger() returns real
    return m_chanceToRetrigger01

  // --------------------------------------------------------------------------
  function setChanceToRetrigger(real value)
    m_chanceToRetrigger01 = value

  // ----------------------------------------------------------------------------
  function getDirector() returns LootableDirector
    return m_director

  // --------------------------------------------------------------------------
  function getCooldownDaysRange() returns rangeInt
    return m_cooldownDaysRange

  function setCooldownDaysRange(rangeInt range)
    m_cooldownDaysRange = range

  // --------------------------------------------------------------------------
  function getCooldownDays() returns int
    return m_cooldownDays

  // --------------------------------------------------------------------------
  function setCooldownDays(int value)
    
    let oldValue = m_cooldownDays
    m_cooldownDays = value

    if (m_cooldownDays == 0 and m_cooldownDayTextTag != null)
      m_cooldownDayTextTag.destr()
      m_cooldownDayTextTag = null

    if (m_cooldownDays > 0)
    //{
      if (m_cooldownDayTextTag == null)
        m_cooldownDayTextTag = CreateTextTag()
      
      m_cooldownDayTextTag
        ..setVisibility(value > 0)
        ..setPermanent(true)
        ..setColor(COUNTDOWN_COLOR)
        ..setPos(getOwnerUnit().getPos().withZ(20.0))
        ..setVelocity(0, 0)

      if (m_cooldownDays == 1)
        m_cooldownDayTextTag.setText("{0} DAY".format(m_cooldownDays.toString()), 10.0)
      else
        m_cooldownDayTextTag.setText("{0} DAYS".format(m_cooldownDays.toString()), 10.0)
    //}

    if (oldValue != value and m_cooldownDays == 0)
      onLootable()

  // --------------------------------------------------------------------------
  function getSpawnPosition() returns vec2
    return m_spawnPosOverride.reduce(getOwnerUnit().getPos())

  // --------------------------------------------------------------------------
  function setSpawnPosition(vec2 value)
    m_spawnPosOverride = some(value)

  // --------------------------------------------------------------------------
  function setDestroyOnLoot(bool value)
    m_destroyOnLoot = value

  // --------------------------------------------------------------------------
  function resetCooldown()
    if (m_cooldownDays == 0)
      return
    setCooldownDays(0)

  // --------------------------------------------------------------------------
  function decrementCooldown()
    if (m_cooldownDays == 0)
      return
    setCooldownDays(m_cooldownDays - 1)

  // --------------------------------------------------------------------------
  function startLooting(unit looter)

    if (not canLoot() or getIsBeingLooted())
      return

    let scaledSearchDuration = getUnitSearchDuration(looter, m_searchDurationUnscaled)

    m_lootingUnit = looter

    // Stand 4 in HD
    m_lootingUnit.setAnimation(15)

    let operation = getOwner().getOrAddLootOperationComponent()
    operation.start(looter, scaledSearchDuration)

  // --------------------------------------------------------------------------
  function onLootingFinished(unit lootingUnit)
    if (lootingUnit == null)
      error("lootingUnit is null")
      return

    if (m_lootingUnit != lootingUnit)
      error("Not the same unit that started looting")
      return

    setCooldownDays(m_cooldownDaysRange.getRandom())

    m_lootingUnit.setAbilityCooldown(ABILITY_ID_SEARCH, 0, 0.0)

    m_lootingUnit = null
    giveRewards(lootingUnit)
    onLooted()

    if (m_destroyOnLoot)
      getOwnerUnit().remove()

  // --------------------------------------------------------------------------
  function onLootingCanceled(unit lootingUnit)    
    if (lootingUnit == null)
      return

    if (m_lootingUnit == null)
      return

    if (m_lootingUnit != lootingUnit)
      Log.debug("Not the same unit that started looting")
      resetCooldown()
      onLootable()
      return

    m_lootingUnit.resetAbilityCooldown(ABILITY_ID_SEARCH)

    FX.createLootingCanceledTag(getOwnerUnit().getPos())

    // reset state so it can be looted again
    m_lootingUnit = null
    resetCooldown()
    onLootable()

  // --------------------------------------------------------------------------
  function showLootRewardNotification(player _player, LootRewardNotification notification)

    let index = m_lootRewardMultiplier
    let delay = (index - 1) * 0.6
    let dueToLuckyHorseshoe = m_dueToLuckyHorseshoe > 0

    doAfter(delay) () ->
    //{
      notification
      ..setDueToLuckyHorseshoe(dueToLuckyHorseshoe)
      ..show(_player)

      g_lootFinishedSound[index.clamp(0, 2)].playForPlayer(_player)
    //"

    m_lootRewardMultiplier++

  // --------------------------------------------------------------------------
  protected function giveRewards(unit lootingUnit)
    m_lootRewardMultiplier = 1
    let deckInstance = m_director.getDeck().createInstance()
    giveRewardsWithChanceToRetrigger(deckInstance, lootingUnit, m_chanceToRetrigger01, true, false)
    destroy deckInstance

  // --------------------------------------------------------------------------
  private function giveRewardsWithChanceToRetrigger(
    DeckInstance deckInstance,
    unit lootingUnit,
    real chanceToRetrigger01,
    bool allowLuckyHorseshoe,
    bool rewardDueToLuckyHorseshoe)

    // No more rewards to give
    if (deckInstance.isEmpty())
      return

    let ownerUnit = getOwnerUnit()

    m_dueToLuckyHorseshoe += rewardDueToLuckyHorseshoe ? 1 : 0

    // Give the player their reward
    LootCard card = null
    while (not deckInstance.isEmpty())
    //{
      card = deckInstance.drawCard() castTo LootCard

      if (card == null)
        Log.debug("No reward registered for lootable")
        break

      if (card.giveReward(ownerUnit, lootingUnit))
        break
    //}

    m_dueToLuckyHorseshoe -= rewardDueToLuckyHorseshoe ? 1 : 0

    // Some rewards necessarily must stop the retrigger loop
    if (card == null or card.getStopsRetrigger())
      return

    var chanceToRetriggerWithHoreshoe01 = chanceToRetrigger01
    var mutableLuckyHorseshoe = allowLuckyHorseshoe
    var mutableRewardDueToLuckyHorseshoe = false

    // Lucky Horseshoe item grants a small chance to immediately loot a second time
    let metadata = lootingUnit.getMetadata()
    if (metadata != null)
      let comp = metadata.getUnitPropertiesComponent()
      if (comp != null)
        chanceToRetriggerWithHoreshoe01 = clamp01(chanceToRetriggerWithHoreshoe01 + comp.getPropertyValue(UnitProperty.LOOT_TWICE_CHANCE_01))
    
    let roll = GetRandomReal(0, 1)
    if (not passesChanceCheck(chanceToRetriggerWithHoreshoe01, roll))
      return

    // The chance check would not have passed if it weren't for the effects of lucky horseshoe
    if (not passesChanceCheck(chanceToRetrigger01, roll))
      displayMessageToPlayer(lootingUnit.getOwner(), "Lucky Horseshoe!".colorize(Colors.lightBlue) + " You found even more loot!")
      mutableLuckyHorseshoe = false // Lucky horseshoe can only fire once
      mutableRewardDueToLuckyHorseshoe = true

    // Give the player another reward and give it another shot to retrigger
    giveRewardsWithChanceToRetrigger(deckInstance, lootingUnit, chanceToRetrigger01 / 3.0, mutableLuckyHorseshoe, mutableRewardDueToLuckyHorseshoe)

  // --------------------------------------------------------------------------
  private function onLooted()
    getOwnerUnit().removeAbility(ABILITY_ID_LOOTABLE)
    getOwnerUnit().setVertexColor(LOOTED_COLOR)
    UnitRemoveType(getOwnerUnit(), UNIT_TYPE_ANCIENT)

  // --------------------------------------------------------------------------
  private function onLootable()
    getOwnerUnit().addAbility(ABILITY_ID_LOOTABLE)
    getOwnerUnit().setVertexColor(LOOTABLE_COLOR)
    // Makes the unit targettable by the search ability
    UnitAddType(getOwnerUnit(), UNIT_TYPE_ANCIENT)

// ============================================================================
public function IUnitMetadata.getLootableComponent() returns LootableComponent
  return this.getComponent(LootableComponent.typeId) castTo LootableComponent

// ============================================================================
public function IUnitMetadata.getOrAddLootableComponent() returns LootableComponent
  var component = this.getLootableComponent()
  if (component == null)
    component = this.addComponent(new LootableComponent(this)) castTo LootableComponent
  return component

// ============================================================================
function onDayStart()
  if (g_lootableUnits != null)
    for lootableUnit in g_lootableUnits
      lootableUnit.decrementCooldown()

// ============================================================================
function refreshLootablesInRange(vec2 pos, real radius)
  let temp = getGroup()
  temp.enumUnitsInRange(pos, radius)
  for _unit in temp
    if (_unit.isLootable())
      refreshLootable(_unit)
  temp.release()

// ============================================================================
function refreshLootable(unit lootableUnit)

  let metadata = lootableUnit.getMetadata()
  if (metadata == null)
    return

  let comp = metadata.getLootableComponent()
  if (comp == null)
    return

  bool foundCooldownAffector = false
  let temp = getGroup()
  temp.enumUnitsInRange(lootableUnit.getPos(), LOOTABLE_CAMP_RANGE)
  for _unit in temp
    if (unitAffectsLootableCooldown(_unit))
      foundCooldownAffector = true
      break
  temp.release()

  comp.setCooldownDaysRange(foundCooldownAffector ? LOOTABLES_NEARCAMP_COOLDOWN_RANGE : LOOTABLES_DEFAULT_COOLDOWN_RANGE)

// ============================================================================
function unitAffectsLootableCooldown(unit _unit) returns bool
  return _unit.isBuilding() and
         not _unit.isLootable() and
         _unit.getOwner() != PLAYER_VILLAGERS and
         _unit.isAllyOf(PLAYER_VILLAGERS)

// ============================================================================
function onUnitIndexDeindexed()
  refreshLootablesInRange(getIndexingUnit().getPos(), LOOTABLE_REFRESH_RANGE)

// ============================================================================
init
  registerDayEvent(function onDayStart)
  onUnitIndex(() -> onUnitIndexDeindexed())
  onUnitDeindex(() -> onUnitIndexDeindexed())
  
  for i = 0 to 2
    g_lootFinishedSound[i] = new SoundDefinition("sound\\interface\\goodjob.flac", false, false)
    g_lootFinishedSound[i].volume = 100
    g_lootFinishedSound[i].pitch += i * 0.1
