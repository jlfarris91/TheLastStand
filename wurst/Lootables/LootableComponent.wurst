package LootableComponent
import UnitMetadata
import GameConstants
import Range
import Lootables
import ErrorHandling
import Time
import FX
import Vector
import initlater LootOperationComponent
import SoundUtils
import ClosureTimers
import Optional
import GroupUtils
import UnitExtensions
import UnitIndexer
import Directors

constant colorA LOOTABLE_COLOR = colorA(255, 255, 255, 255)
constant colorA LOOTED_COLOR = colorA(150, 150, 150, 150)
constant colorA COUNTDOWN_COLOR = colorA(0, 170, 0, 255)
constant real LOOTABLE_REFRESH_RANGE = 512.0
constant real LOOTABLE_CAMP_RANGE = 512.0
public constant int MAX_LOOT_COUNT = 5

Vector<LootableComponent> g_lootableUnits = null
SoundDefinition array[3] g_lootFinishedSound

// ============================================================================
public class LootableComponent extends UnitComponent
  private real m_searchDurationUnscaled
  private int m_cooldownDays
  private unit m_lootingUnit
  private texttag m_cooldownDayTextTag
  private rangeInt m_cooldownDaysRange
  private int m_lootRewardMultiplier = 1  
  private int m_dueToLuckyHorseshoe = 0
  private optionalVec2 m_spawnPosOverride = none_vec2()
  private bool m_destroyOnLoot = false
  private LootableDirector m_director
  private int m_lootCount = 1
  private drawnCard array[MAX_LOOT_COUNT] m_lootCards
  private int m_lootCardIndex = 0

  // --------------------------------------------------------------------------
  construct(IUnitMetadata owner)
    super(owner)

    m_searchDurationUnscaled = 3.0
    m_cooldownDays = 0
    m_cooldownDaysRange = LOOTABLES_DEFAULT_COOLDOWN_RANGE

    m_director = new LootableDirector(getOwnerUnit())

    if (g_lootableUnits == null)
      g_lootableUnits = new Vector<LootableComponent>()

    g_lootableUnits.add(this)

  // --------------------------------------------------------------------------
  ondestroy

    if (m_cooldownDayTextTag != null)
      m_cooldownDayTextTag.destr()
      m_cooldownDayTextTag = null

  // --------------------------------------------------------------------------
  override function onEnabled()
    super.onEnabled()

    getOwnerUnit().setOwner(PLAYER_LOOTABLES, true)
    
    if (m_cooldownDayTextTag != null)
      m_cooldownDayTextTag.setPos(getOwnerUnit().getPos().withZ(20.0))

    resetCooldown()
    onLootable()

  // --------------------------------------------------------------------------
  function canLoot() returns bool
    return not getIsLooted() and not getIsBeingLooted()

  // --------------------------------------------------------------------------
  function getIsLooted() returns bool
    return m_cooldownDays > 0

  // --------------------------------------------------------------------------
  function getIsBeingLooted() returns bool
    return m_lootingUnit != null

  // --------------------------------------------------------------------------
  function getSearchDuration() returns real
    return m_searchDurationUnscaled

  // --------------------------------------------------------------------------
  function setSearchDuration(real duration)
    m_searchDurationUnscaled = duration

  // ----------------------------------------------------------------------------
  function getLootCount() returns int
    return m_lootCount
  
  // ----------------------------------------------------------------------------
  function setLootCount(int value)
    m_lootCount = min(value, MAX_LOOT_COUNT)

  // ----------------------------------------------------------------------------
  function getLootCard(int index) returns drawnCard
    return m_lootCards[index]

  // ----------------------------------------------------------------------------
  function getDirector() returns LootableDirector
    return m_director

  // --------------------------------------------------------------------------
  function getCooldownDaysRange() returns rangeInt
    return m_cooldownDaysRange

  function setCooldownDaysRange(rangeInt range)
    m_cooldownDaysRange = range

  // --------------------------------------------------------------------------
  function getCooldownDays() returns int
    return m_cooldownDays

  // --------------------------------------------------------------------------
  function setCooldownDays(int value)
    
    let oldValue = m_cooldownDays
    m_cooldownDays = value

    if (m_cooldownDays == 0 and m_cooldownDayTextTag != null)
      m_cooldownDayTextTag.destr()
      m_cooldownDayTextTag = null

    if (m_cooldownDays > 0)
    //{
      if (m_cooldownDayTextTag == null)
        m_cooldownDayTextTag = CreateTextTag()
      
      m_cooldownDayTextTag
        ..setVisibility(value > 0)
        ..setPermanent(true)
        ..setColor(COUNTDOWN_COLOR)
        ..setPos(getOwnerUnit().getPos().withZ(20.0))
        ..setVelocity(0, 0)

      if (m_cooldownDays == 1)
        m_cooldownDayTextTag.setText("{0} DAY".format(m_cooldownDays.toString()), 10.0)
      else
        m_cooldownDayTextTag.setText("{0} DAYS".format(m_cooldownDays.toString()), 10.0)
    //}

    if (oldValue != value and m_cooldownDays == 0)
      onLootable()

  // --------------------------------------------------------------------------
  function getSpawnPosition() returns vec2
    return m_spawnPosOverride.reduce(getOwnerUnit().getPos())

  // --------------------------------------------------------------------------
  function setSpawnPosition(vec2 value)
    m_spawnPosOverride = some(value)

  // --------------------------------------------------------------------------
  function setDestroyOnLoot(bool value)
    m_destroyOnLoot = value

  // --------------------------------------------------------------------------
  function resetCooldown()
    if (m_cooldownDays == 0)
      return
    setCooldownDays(0)

  // --------------------------------------------------------------------------
  function decrementCooldown()
    if (m_cooldownDays == 0)
      return
    setCooldownDays(m_cooldownDays - 1)

  // --------------------------------------------------------------------------
  function startLooting(unit looter)

    if (not canLoot() or getIsBeingLooted())
      return

    let scaledSearchDuration = getUnitSearchDuration(looter, m_searchDurationUnscaled)

    m_lootingUnit = looter

    // Stand 4 in HD
    m_lootingUnit.setAnimation(15)

    resetLootAwards()

    let operation = getOwner().getOrAddLootOperationComponent()
    operation.start(looter, scaledSearchDuration, m_lootCount)

  // --------------------------------------------------------------------------
  function onLootingFinished(unit lootingUnit)
    if (lootingUnit == null)
      error("lootingUnit is null")
      return

    if (m_lootingUnit != lootingUnit)
      error("Not the same unit that started looting")
      return

    setCooldownDays(m_cooldownDaysRange.getRandom())

    m_lootingUnit.setAbilityCooldown(ABILITY_ID_SEARCH, 0, 0.0)

    m_lootingUnit = null
    // giveRewards(lootingUnit)
    onLooted()

    if (m_destroyOnLoot)
      getOwnerUnit().remove()

  // --------------------------------------------------------------------------
  function onLootingCanceled(unit lootingUnit)    
    if (lootingUnit == null)
      return

    if (m_lootingUnit == null)
      return

    if (m_lootingUnit != lootingUnit)
      Log.debug("Not the same unit that started looting")
      resetCooldown()
      onLootable()
      return

    m_lootingUnit.resetAbilityCooldown(ABILITY_ID_SEARCH)

    FX.createLootingCanceledTag(getOwnerUnit().getPos())

    // reset state so it can be looted again
    m_lootingUnit = null
    resetCooldown()
    onLootable()

  // --------------------------------------------------------------------------
  function showLootRewardNotification(player _player, LootRewardNotification notification)

    let index = m_lootRewardMultiplier
    let delay = (index - 1) * 0.6
    let dueToLuckyHorseshoe = m_dueToLuckyHorseshoe > 0

    doAfter(delay) () ->
    //{
      notification
      ..setDueToLuckyHorseshoe(dueToLuckyHorseshoe)
      ..show(_player)

      g_lootFinishedSound[index.clamp(0, 2)].playForPlayer(_player)
    //"

    m_lootRewardMultiplier++

  // ----------------------------------------------------------------------------
  function resetLootAwards()
    m_lootCardIndex = 0

  // ----------------------------------------------------------------------------
  function canAwardLoot() returns bool
    return m_lootCardIndex < m_lootCount

  // ----------------------------------------------------------------------------
  function awardNextLoot(unit lootingUnit)

    let lootCard = m_lootCards[m_lootCardIndex]
    m_lootCardIndex++

    if (lootCard == INVALID_CARD)
      error("Invalid loot card at index "+ (m_lootCardIndex-1).toString())
      return

    LootCard.s_lootable = getOwnerUnit()
    LootCard.s_looter = lootingUnit
    
    m_director.activateCard(lootCard)

    LootCard.s_lootable = null
    LootCard.s_looter = null

  // // --------------------------------------------------------------------------
  // protected function giveRewards(unit lootingUnit)
  //   m_lootRewardMultiplier = 1
  //   let deckInstance = m_director.getDeck().createInstance()
  //   giveRewardsWithChanceToRetrigger(deckInstance, lootingUnit, m_chanceToRetrigger01, true, false)
  //   destroy deckInstance

  // // --------------------------------------------------------------------------
  // private function giveRewardsWithChanceToRetrigger(
  //   DeckInstance deckInstance,
  //   unit lootingUnit,
  //   real chanceToRetrigger01,
  //   bool allowLuckyHorseshoe,
  //   bool rewardDueToLuckyHorseshoe)

  //   // No more rewards to give
  //   if (deckInstance.isEmpty())
  //     return

  //   let ownerUnit = getOwnerUnit()

  //   m_dueToLuckyHorseshoe += rewardDueToLuckyHorseshoe ? 1 : 0

  //   // Give the player their reward
  //   LootCard card = null
  //   while (not deckInstance.isEmpty())
  //   //{
  //     card = deckInstance.drawCard() castTo LootCard

  //     if (card == null)
  //       Log.debug("No reward registered for lootable")
  //       break

  //     if (card.giveReward(ownerUnit, lootingUnit))
  //       break
  //   //}

  //   m_dueToLuckyHorseshoe -= rewardDueToLuckyHorseshoe ? 1 : 0

  //   // Some rewards necessarily must stop the retrigger loop
  //   if (card == null or card.getStopsRetrigger())
  //     return

  //   var chanceToRetriggerWithHoreshoe01 = chanceToRetrigger01
  //   var mutableLuckyHorseshoe = allowLuckyHorseshoe
  //   var mutableRewardDueToLuckyHorseshoe = false

  //   // Lucky Horseshoe item grants a small chance to immediately loot a second time
  //   let metadata = lootingUnit.getMetadata()
  //   if (metadata != null)
  //     let comp = metadata.getUnitPropertiesComponent()
  //     if (comp != null)
  //       chanceToRetriggerWithHoreshoe01 = clamp01(chanceToRetriggerWithHoreshoe01 + comp.getPropertyValue(UnitProperty.LOOT_TWICE_CHANCE_01))
    
  //   let roll = GetRandomReal(0, 1)
  //   if (not passesChanceCheck(chanceToRetriggerWithHoreshoe01, roll))
  //     return

  //   // The chance check would not have passed if it weren't for the effects of lucky horseshoe
  //   if (not passesChanceCheck(chanceToRetrigger01, roll))
  //     displayMessageToPlayer(lootingUnit.getOwner(), "Lucky Horseshoe!".colorize(Colors.lightBlue) + " You found even more loot!")
  //     mutableLuckyHorseshoe = false // Lucky horseshoe can only fire once
  //     mutableRewardDueToLuckyHorseshoe = true

  //   // Give the player another reward and give it another shot to retrigger
  //   giveRewardsWithChanceToRetrigger(deckInstance, lootingUnit, chanceToRetrigger01 / 3.0, mutableLuckyHorseshoe, mutableRewardDueToLuckyHorseshoe)

  // --------------------------------------------------------------------------
  private function onLooted()
    getOwnerUnit().removeAbility(ABILITY_ID_LOOTABLE)
    getOwnerUnit().setVertexColor(LOOTED_COLOR)
    UnitRemoveType(getOwnerUnit(), UNIT_TYPE_ANCIENT)

  // --------------------------------------------------------------------------
  private function onLootable()
    getOwnerUnit().addAbility(ABILITY_ID_LOOTABLE)
    getOwnerUnit().setVertexColor(LOOTABLE_COLOR)
    // Makes the unit targettable by the search ability
    UnitAddType(getOwnerUnit(), UNIT_TYPE_ANCIENT)

    drawLootCards()
    m_lootCardIndex = 0

  // ----------------------------------------------------------------------------
  private function drawLootCards()

    m_director.activate()

    for i = (m_lootCount - 1) downto 0
      if (m_director.canDrawCard())
        m_lootCards[i] = m_director.drawCard()
        m_director.setCredits(m_director.getCredits() - m_lootCards[i].cost) 

// ============================================================================
public function IUnitMetadata.getLootableComponent() returns LootableComponent
  return this.getComponent(LootableComponent.typeId) castTo LootableComponent

// ============================================================================
public function IUnitMetadata.getOrAddLootableComponent() returns LootableComponent
  var component = this.getLootableComponent()
  if (component == null)
    component = this.addComponent(new LootableComponent(this)) castTo LootableComponent
  return component

// ============================================================================
function onDayStart()
  if (g_lootableUnits != null)
    for lootableUnit in g_lootableUnits
      lootableUnit.decrementCooldown()

// ============================================================================
function refreshLootablesInRange(vec2 pos, real radius)
  let temp = getGroup()
  temp.enumUnitsInRange(pos, radius)
  for _unit in temp
    if (_unit.isLootable())
      refreshLootable(_unit)
  temp.release()

// ============================================================================
function refreshLootable(unit lootableUnit)

  let metadata = lootableUnit.getMetadata()
  if (metadata == null)
    return

  let comp = metadata.getLootableComponent()
  if (comp == null)
    return

  bool foundCooldownAffector = false
  let temp = getGroup()
  temp.enumUnitsInRange(lootableUnit.getPos(), LOOTABLE_CAMP_RANGE)
  for _unit in temp
    if (unitAffectsLootableCooldown(_unit))
      foundCooldownAffector = true
      break
  temp.release()

  comp.setCooldownDaysRange(foundCooldownAffector ? LOOTABLES_NEARCAMP_COOLDOWN_RANGE : LOOTABLES_DEFAULT_COOLDOWN_RANGE)

// ============================================================================
function unitAffectsLootableCooldown(unit _unit) returns bool
  return _unit.isBuilding() and
         not _unit.isLootable() and
         _unit.getOwner() != PLAYER_VILLAGERS and
         _unit.isAllyOf(PLAYER_VILLAGERS)

// ============================================================================
function onUnitIndexDeindexed()
  refreshLootablesInRange(getIndexingUnit().getPos(), LOOTABLE_REFRESH_RANGE)

// ============================================================================
init
  registerDayEvent(function onDayStart)
  onUnitIndex(() -> onUnitIndexDeindexed())
  onUnitDeindex(() -> onUnitIndexDeindexed())
  
  for i = 0 to 2
    g_lootFinishedSound[i] = new SoundDefinition("sound\\interface\\goodjob.flac", false, false)
    g_lootFinishedSound[i].volume = 100
    g_lootFinishedSound[i].pitch += i * 0.1
