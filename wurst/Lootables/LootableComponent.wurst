package LootableComponent
import GameConstants
import Range
import Lootables
import ErrorHandling
import Time
import FX
import Vector
import SoundUtils
import ClosureTimers
import Optional
import GroupUtils
import UnitExtensions
import UnitIndexer
import Directors
import Math
import LinkedList
import RealtimeUnitComponent
import HashMap
import TimerUtils
import Orders
import ColorUtility
import RegisterEvents
import WorldProgressBar
import Ability_Search
import RealTime
import Notifications
import Icons
import Command
import TlsSounds
import IProgress
import DisplayTextToPlayer
import TlsAbilityIds

constant colorA LOOTABLE_COLOR = colorA(255, 255, 255, 255)
constant colorA LOOTED_COLOR = colorA(150, 150, 150, 150)
constant colorA COUNTDOWN_COLOR = colorA(0, 170, 0, 255)
constant real LOOTABLE_REFRESH_RANGE = 512.0
constant real LOOTABLE_CAMP_RANGE = 512.0
public constant int MAX_LOOT_COUNT = 5

Vector<LootableComponent> g_lootableUnits = null
SoundDefinition array[3] g_lootFinishedSound

constant int PROGRESS_BAR_LENGTH = 20
constant colorA PROGRESS_BAR_FOREGROUND = colorA(0, 170, 0, 255)
constant colorA PROGRESS_BAR_BACKGROUND = colorA(0, 64, 0, 255)
constant real PROGRESS_BAR_UPDATE_PERIOD = 0.1
constant real LOOTER_STANDING_POS_THRESHOLD_SQ = 64.0 * 64.0

LinkedList<LootOperationComponent> g_activeOperations
HashMap<unit, LootOperationComponent> g_looterToOperationMap = new HashMap<unit, LootOperationComponent>()

SoundDefinition g_notEnoughManaSoundDef
int array g_notEnoughManaLastPlayedTime

// ============================================================================
public class LootableComponent extends UnitComponent
  private real m_searchDurationUnscaled
  private int m_cooldownDays
  private unit m_lootingUnit
  private texttag m_cooldownDayTextTag
  private rangeInt m_cooldownDaysRange
  private int m_lootRewardMultiplier = 1  
  private int m_dueToLuckyHorseshoe = 0
  private optionalVec2 m_spawnPosOverride = none_vec2()
  private bool m_destroyOnLoot = false
  private LootableDirector m_director
  private int m_maxLootCount = 1
  private LinkedList<DrawnCard> m_lootCards = new LinkedList<DrawnCard>()

  // --------------------------------------------------------------------------
  construct(IUnitMetadata owner)
    super(owner)

    m_searchDurationUnscaled = 3.0
    m_cooldownDays = 0
    m_cooldownDaysRange = LOOTABLES_DEFAULT_COOLDOWN_RANGE

    m_director = new LootableDirector(getOwnerUnit())

    if (g_lootableUnits == null)
      g_lootableUnits = new Vector<LootableComponent>()

    g_lootableUnits.add(this)

  // --------------------------------------------------------------------------
  ondestroy

    destroy m_lootCards
    m_lootCards = null

    if (m_cooldownDayTextTag != null)
      m_cooldownDayTextTag.destr()
      m_cooldownDayTextTag = null

  // --------------------------------------------------------------------------
  override function onEnabled()
    super.onEnabled()

    getOwnerUnit().setOwner(PLAYER_LOOTABLES, true)
    
    if (m_cooldownDayTextTag != null)
      m_cooldownDayTextTag.setPos(getOwnerUnit().getPos().withZ(20.0))

    resetCooldown()
    drawLootCards()
    onLootable()

  // --------------------------------------------------------------------------
  function canLoot() returns bool
    return not getIsLooted() and not getIsBeingLooted()

  // --------------------------------------------------------------------------
  function getIsLooted() returns bool
    return m_cooldownDays > 0

  // --------------------------------------------------------------------------
  function getIsBeingLooted() returns bool
    return m_lootingUnit != null

  // --------------------------------------------------------------------------
  function getSearchDuration() returns real
    return m_searchDurationUnscaled

  // --------------------------------------------------------------------------
  function setSearchDuration(real duration)
    m_searchDurationUnscaled = duration

  // ----------------------------------------------------------------------------
  function getLootCount() returns int
    return m_maxLootCount
  
  // ----------------------------------------------------------------------------
  function setLootCount(int value)
    m_maxLootCount = min(value, MAX_LOOT_COUNT)

  // ----------------------------------------------------------------------------
  function getLootCard(int index) returns DrawnCard
    return m_lootCards.get(index)

  // ----------------------------------------------------------------------------
  function getLootCardCount() returns int
    return m_lootCards.size()

  // ----------------------------------------------------------------------------
  function hasLoot() returns bool
    return not m_lootCards.isEmpty()

  // ----------------------------------------------------------------------------
  function getDirector() returns LootableDirector
    return m_director

  // --------------------------------------------------------------------------
  function getCooldownDaysRange() returns rangeInt
    return m_cooldownDaysRange

  // --------------------------------------------------------------------------
  function setCooldownDaysRange(rangeInt range)
    m_cooldownDaysRange = range

  // --------------------------------------------------------------------------
  function getCooldownDays() returns int
    return m_cooldownDays

  // --------------------------------------------------------------------------
  function setCooldownDays(int value)
    
    let oldValue = m_cooldownDays
    m_cooldownDays = value

    if (m_cooldownDays == 0 and m_cooldownDayTextTag != null)
      m_cooldownDayTextTag.destr()
      m_cooldownDayTextTag = null

    if (m_cooldownDays > 0)
    //{
      if (m_cooldownDayTextTag == null)
        m_cooldownDayTextTag = CreateTextTag()
      
      m_cooldownDayTextTag
        ..setVisibility(value > 0)
        ..setPermanent(true)
        ..setColor(COUNTDOWN_COLOR)
        ..setPos(getOwnerUnit().getPos().withZ(20.0))
        ..setVelocity(0, 0)

      if (m_cooldownDays == 1)
        m_cooldownDayTextTag.setText("{0} DAY".format(m_cooldownDays.toString()), 10.0)
      else
        m_cooldownDayTextTag.setText("{0} DAYS".format(m_cooldownDays.toString()), 10.0)
    //}

    if (oldValue != value and m_cooldownDays == 0)
      onLootable()

  // --------------------------------------------------------------------------
  function getSpawnPosition() returns vec2
    return m_spawnPosOverride.reduce(getOwnerUnit().getPos())

  // --------------------------------------------------------------------------
  function setSpawnPosition(vec2 value)
    m_spawnPosOverride = some(value)

  // --------------------------------------------------------------------------
  function setDestroyOnLoot(bool value)
    m_destroyOnLoot = value

  // --------------------------------------------------------------------------
  function resetCooldown()
    if (m_cooldownDays == 0)
      return
    setCooldownDays(0)

  // --------------------------------------------------------------------------
  function decrementCooldown()
    if (m_cooldownDays == 0)
      return
    setCooldownDays(m_cooldownDays - 1)

  // --------------------------------------------------------------------------
  function startLooting(unit looter)

    if (not canLoot() or getIsBeingLooted())
      return

    let scaledSearchDuration = getUnitSearchDuration(looter, m_searchDurationUnscaled)

    m_lootingUnit = looter

    // Stand 4 in HD
    m_lootingUnit.setAnimation(15)

    let operation = getOwner().getOrAddLootOperationComponent()
    operation.start(looter, scaledSearchDuration, getLootCardCount())

  // --------------------------------------------------------------------------
  function onLootingFinished(unit lootingUnit)
    if (lootingUnit == null)
      error("lootingUnit is null")
      return

    if (m_lootingUnit != lootingUnit)
      error("Not the same unit that started looting")
      return

    m_lootingUnit.setAbilityCooldown(ABILITY_ID_SEARCH, 0, 0.0)
    m_lootingUnit = null

    if (m_destroyOnLoot)
      getOwnerUnit().remove()

    if (m_lootCards.isEmpty())
      setCooldownDays(m_cooldownDaysRange.getRandom())
      onLooted()

  // --------------------------------------------------------------------------
  function onLootingCanceled(unit lootingUnit)    
    if (lootingUnit == null)
      return

    if (m_lootingUnit == null)
      return

    if (m_lootingUnit != lootingUnit)
      Log.debug("Not the same unit that started looting")
      resetCooldown()
      onLootable()
      return

    m_lootingUnit.resetAbilityCooldown(ABILITY_ID_SEARCH)

    FX.createLootingCanceledTag(getOwnerUnit().getPos())

    // reset state so it can be looted again
    m_lootingUnit = null
    resetCooldown()
    onLootable()

  // --------------------------------------------------------------------------
  function showLootRewardNotification(player _player, LootRewardNotification notification)

    let index = m_lootRewardMultiplier
    let delay = (index - 1) * 0.6
    let dueToLuckyHorseshoe = m_dueToLuckyHorseshoe > 0

    doAfter(delay) () ->
    //{
      notification
      ..setDueToLuckyHorseshoe(dueToLuckyHorseshoe)
      ..show(_player)

      g_lootFinishedSound[index.clamp(0, 2)].playForPlayer(_player)
    //"

    m_lootRewardMultiplier++

  // ----------------------------------------------------------------------------
  function awardLoot(unit lootingUnit)

    if (m_lootCards.isEmpty())
      error("No loot cards available")
      return

    let lootCard = m_lootCards.dequeue()

    if (lootCard == null)
      error("Invalid loot card at index 0")
      return

    LootCard.s_lootable = getOwnerUnit()
    LootCard.s_looter = lootingUnit
    
    m_director.activateCard(lootCard)

    LootCard.s_lootable = null
    LootCard.s_looter = null

    destroy lootCard

  // // --------------------------------------------------------------------------
  // protected function giveRewards(unit lootingUnit)
  //   m_lootRewardMultiplier = 1
  //   let deckInstance = m_director.getDeck().createInstance()
  //   giveRewardsWithChanceToRetrigger(deckInstance, lootingUnit, m_chanceToRetrigger01, true, false)
  //   destroy deckInstance

  // // --------------------------------------------------------------------------
  // private function giveRewardsWithChanceToRetrigger(
  //   DeckInstance deckInstance,
  //   unit lootingUnit,
  //   real chanceToRetrigger01,
  //   bool allowLuckyHorseshoe,
  //   bool rewardDueToLuckyHorseshoe)

  //   // No more rewards to give
  //   if (deckInstance.isEmpty())
  //     return

  //   let ownerUnit = getOwnerUnit()

  //   m_dueToLuckyHorseshoe += rewardDueToLuckyHorseshoe ? 1 : 0

  //   // Give the player their reward
  //   LootCard card = null
  //   while (not deckInstance.isEmpty())
  //   //{
  //     card = deckInstance.drawCard() castTo LootCard

  //     if (card == null)
  //       Log.debug("No reward registered for lootable")
  //       break

  //     if (card.giveReward(ownerUnit, lootingUnit))
  //       break
  //   //}

  //   m_dueToLuckyHorseshoe -= rewardDueToLuckyHorseshoe ? 1 : 0

  //   // Some rewards necessarily must stop the retrigger loop
  //   if (card == null or card.getStopsRetrigger())
  //     return

  //   var chanceToRetriggerWithHoreshoe01 = chanceToRetrigger01
  //   var mutableLuckyHorseshoe = allowLuckyHorseshoe
  //   var mutableRewardDueToLuckyHorseshoe = false

  //   // Lucky Horseshoe item grants a small chance to immediately loot a second time
  //   let metadata = lootingUnit.getMetadata()
  //   if (metadata != null)
  //     let comp = metadata.getUnitPropertiesComponent()
  //     if (comp != null)
  //       chanceToRetriggerWithHoreshoe01 = clamp01(chanceToRetriggerWithHoreshoe01 + comp.getPropertyValue(UnitProperty.LOOT_TWICE_CHANCE_01))
    
  //   let roll = GetRandomReal(0, 1)
  //   if (not passesChanceCheck(chanceToRetriggerWithHoreshoe01, roll))
  //     return

  //   // The chance check would not have passed if it weren't for the effects of lucky horseshoe
  //   if (not passesChanceCheck(chanceToRetrigger01, roll))
  //     displayMessageToPlayer(lootingUnit.getOwner(), "Lucky Horseshoe!".colorize(Colors.lightBlue) + " You found even more loot!")
  //     mutableLuckyHorseshoe = false // Lucky horseshoe can only fire once
  //     mutableRewardDueToLuckyHorseshoe = true

  //   // Give the player another reward and give it another shot to retrigger
  //   giveRewardsWithChanceToRetrigger(deckInstance, lootingUnit, chanceToRetrigger01 / 3.0, mutableLuckyHorseshoe, mutableRewardDueToLuckyHorseshoe)

  // --------------------------------------------------------------------------
  private function onLooted()
    getOwnerUnit().removeAbility(ABILITY_ID_LOOTABLE)
    getOwnerUnit().setVertexColor(LOOTED_COLOR)
    UnitRemoveType(getOwnerUnit(), UNIT_TYPE_ANCIENT)

  // --------------------------------------------------------------------------
  private function onLootable()
    getOwnerUnit().addAbility(ABILITY_ID_LOOTABLE)
    getOwnerUnit().setVertexColor(LOOTABLE_COLOR)
    // Makes the unit targettable by the search ability
    UnitAddType(getOwnerUnit(), UNIT_TYPE_ANCIENT)

  // ----------------------------------------------------------------------------
  private function drawLootCards()

    let numCards = m_maxLootCount - m_lootCards.size()
    if (numCards == 0)
      return

    let deck = m_director.getDeck()
    if (deck == null)
      error("Lootable deck is null!")
      return

    m_director.activate()

    var credits = m_director.getCredits()
    let deckInstance = deck.createInstance()

    // Draw one card for each loot reward, regardless of cost
    for i = 0 to numCards - 1
      let card = deckInstance.drawCard() castTo LootCard
      if (card != null)
        m_lootCards.push(new DrawnCard(card, 0, card.getCost()))
        credits -= card.getCost()
        if (not card.getDiscardOnActivate())
          deckInstance.add(card)

    credits = max(credits, 0)

    if (credits > 0)
    //{
      // Then loop through each loot reward and try to upgrade its tier using remaining credits.
      // Upgrade in reverse order so that the better loot is at the end of the loot operation.
      // Stop after making a full loop without upgrading any cards.
      let lootCardCount = m_lootCards.size()
      var index = lootCardCount
      var upgradedCard = false
      while (true)
      //{
        let drawnCard = m_lootCards.get(index)

        let card = drawnCard.card castTo TieredCard
        let currTier = drawnCard.tier
        let currTierCost = drawnCard.cost

        if (card != null and currTier < card.getTierCount())
          let nextTier = currTier + 1
          let nextTierCost = card.getCost(nextTier)
          let costToUpgrade = nextTierCost - currTierCost
          if (credits > costToUpgrade)
            drawnCard.tier = nextTier
            drawnCard.cost = nextTierCost
            credits -= costToUpgrade
            upgradedCard = true

        index = wrap(index - 1, 0, lootCardCount - 1)

        // Completed a full loop and wrapped around 
        if (index == lootCardCount - 1)
          if (not upgradedCard)
            break
          upgradedCard = false
      //}
    //}

    destroy deckInstance

    m_director.setCredits(credits)

// ============================================================================
public function IUnitMetadata.getLootableComponent() returns LootableComponent
  return this.getComponent(LootableComponent.typeId) castTo LootableComponent

// ============================================================================
public function IUnitMetadata.getOrAddLootableComponent() returns LootableComponent
  var component = this.getLootableComponent()
  if (component == null)
    component = this.addComponent(new LootableComponent(this)) castTo LootableComponent
  return component

// ============================================================================
function onDayStart()
  if (g_lootableUnits != null)
    for lootableUnit in g_lootableUnits
      lootableUnit.decrementCooldown()

// ============================================================================
function refreshLootablesInRange(vec2 pos, real radius)
  let temp = getGroup()
  temp.enumUnitsInRange(pos, radius)
  for _unit in temp
    if (_unit.isLootable())
      refreshLootable(_unit)
  temp.release()

// ============================================================================
function refreshLootable(unit lootableUnit)

  let metadata = lootableUnit.getMetadata()
  if (metadata == null)
    return

  let comp = metadata.getLootableComponent()
  if (comp == null)
    return

  bool foundCooldownAffector = false
  let temp = getGroup()
  temp.enumUnitsInRange(lootableUnit.getPos(), LOOTABLE_CAMP_RANGE)
  for _unit in temp
    if (unitAffectsLootableCooldown(_unit))
      foundCooldownAffector = true
      break
  temp.release()

  comp.setCooldownDaysRange(foundCooldownAffector ? LOOTABLES_NEARCAMP_COOLDOWN_RANGE : LOOTABLES_DEFAULT_COOLDOWN_RANGE)

// ============================================================================
function unitAffectsLootableCooldown(unit _unit) returns bool
  return _unit.isBuilding() and
         not _unit.isLootable() and
         _unit.getOwner() != PLAYER_VILLAGERS and
         _unit.isAllyOf(PLAYER_VILLAGERS)

// ============================================================================
function onUnitIndexDeindexed()
  refreshLootablesInRange(getIndexingUnit().getPos(), LOOTABLE_REFRESH_RANGE)

// ============================================================================
public class LootOperationComponent extends RealtimeUnitComponent
  private unit m_lootingUnit
  private WorldProgressBar m_worldProgressBar
  private Progress m_progress
  private Notification m_notification
  private real m_duration
  private timer m_timer
  private int m_secondsElapsed
  private real m_manaCost
  private bool m_isRunning
  private vec2 m_looterPos

  private Vector<timer> m_lootTimers = new Vector<timer>(MAX_LOOT_COUNT)

  // --------------------------------------------------------------------------
  construct(IUnitMetadata owner)
    super(owner)
    
    m_timer = getTimer()

    m_worldProgressBar = new WorldProgressBar()
    ..setHeight(128.0)
    ..setScale(16.0)

  // --------------------------------------------------------------------------
  ondestroy

    if (m_timer != null)
      m_timer.release()
      m_timer = null
    
    if (m_worldProgressBar != null)
      destroy m_worldProgressBar
      m_worldProgressBar = null

    if (m_notification != null)
      m_notification.close()
      m_notification.release()
      m_notification = null

    if (m_progress != null)
      destroy m_progress
      m_progress = null

    if (m_lootTimers != null)
      for t in m_lootTimers
        if (t != null)
          t.release()
      destroy m_lootTimers

  // --------------------------------------------------------------------------
  override function onEnabled()
    super.onEnabled()
    m_worldProgressBar..setPos(getOwnerUnit().getPos())

  // --------------------------------------------------------------------------
  override function onDisabled()
    super.onDisabled()
    if (getIsRunning())
      cancel()

  // --------------------------------------------------------------------------
  function getTimeRemaining() returns real
    return m_timer != null ? m_timer.getRemaining() : 0.0

  // --------------------------------------------------------------------------
  function getIsRunning() returns bool
    return m_isRunning

  // --------------------------------------------------------------------------
  function getLooter() returns unit
    return m_lootingUnit

  // --------------------------------------------------------------------------
  override function realtimeUpdate(real dt)
    super.realtimeUpdate(dt)

    if (getIsRunning() == false)
      return

    // Catch any edge-case order that would cause the looter to move while still looting
    if (m_lootingUnit.getPos().distanceToSq(m_looterPos) > LOOTER_STANDING_POS_THRESHOLD_SQ)
      cancel()
      return
    
    let percentage01 = parameterize01(m_duration, 0.0, m_timer.getRemaining())
    m_progress.report(percentage01)

    if (m_worldProgressBar != null)
      m_worldProgressBar.setPercentageNow(percentage01)

    // Remove mana per second
    let secondsElapsed = m_timer.getElapsed().floor()
    if (m_secondsElapsed != secondsElapsed)
      m_secondsElapsed = secondsElapsed
      m_lootingUnit.addMana(-m_manaCost)
      if (m_lootingUnit.getMana() == 0)
        FX.createOutOfManaTag(m_lootingUnit.getPos(), m_lootingUnit.getOwner())
        cancel()

  // --------------------------------------------------------------------------
  function start(unit looter, real duration, int lootCount)
    if (getIsRunning())
      return

    m_isRunning = true
    m_lootingUnit = looter
    m_duration = duration * lootCount

    // Avoid implicit capture of 'this' by caching the result of m_lootableUnit
    let lootableUnitCached = getOwnerUnit()

    m_lootTimers.resize(lootCount)
    let timeBetweenLoot = m_duration / lootCount
    for i = 1 to lootCount
      let lootTimer = getTimer()..doManual(timeBetweenLoot * i, true, () -> onAwardLoot(lootableUnitCached, i - 1))
      m_lootTimers.add(lootTimer)
    
    let lootingPlayer = looter.getOwner()
    let cameraPos = getOwnerUnit().getPos()
    m_looterPos = looter.getPos()

    m_timer.doManual(m_duration, true, () -> onOperationFinished(lootableUnitCached))

    m_progress = new Progress()
    m_progress.report("Looting {0}...".format(getOwnerUnit().getName()))

    m_worldProgressBar
    ..setPos(looter.getPos())
    ..setSpeed(1.0 / (m_duration != 0.0 ? m_duration : 1.0))
    ..fadeIn()

    m_notification = new Notification(m_duration)
    ..setProgress(m_progress)
    ..setIconPath(Icons.bTNTelescope)
    ..setMessage("Looting {0}...".format(getOwnerUnit().getName()))
    ..setCanClose(false)
    ..setClickCommand(new RoutedCommand(() -> begin
      if (localPlayer == lootingPlayer)
        PanCameraToTimedForPlayer(lootingPlayer, cameraPos.x, cameraPos.y, 0)
    end))
    ..show(lootingPlayer)
    ..acquire()

    g_looterToOperationMap.put(looter, this)

    m_manaCost = getUnitSearchManaCostPerSecond(m_lootingUnit)

    this.registerForRealtimeUpdate(RealtimeUpdatePriority.Fast)

  // --------------------------------------------------------------------------
  function cancel()
    let lootable = getOwner().getLootableComponent()
    if (lootable != null)
      lootable.onLootingCanceled(m_lootingUnit)
    cleanup()
  
  // --------------------------------------------------------------------------
  private static function onOperationFinished(unit lootable)
    let metadata = lootable.getMetadata()
    if (metadata == null)
      return
    let operation = metadata.getLootOperationComponent()
    if (operation == null or operation.getIsRunning() == false)
      return
    operation.onOperationFinished()

  // --------------------------------------------------------------------------
  private function onOperationFinished()
    let lootable = getOwner().getLootableComponent()
    if (lootable != null)
      lootable.onLootingFinished(m_lootingUnit)
    cleanup()

  // ----------------------------------------------------------------------------
  private static function onAwardLoot(unit lootable, int index)
    let metadata = lootable.getMetadata()
    if (metadata == null)
      return
    let operation = metadata.getLootOperationComponent()
    if (operation == null or operation.getIsRunning() == false)
      return
    operation.onAwardLoot(index)

  // --------------------------------------------------------------------------
  private function onAwardLoot(int index)
    let lootable = getOwner().getLootableComponent()
    if (lootable != null)
      lootable.awardLoot(m_lootingUnit)

    let lootTimer = m_lootTimers.get(index)
    if (lootTimer != null)
      lootTimer.release()
      m_lootTimers.set(index, null)

  // --------------------------------------------------------------------------
  private function cleanup()
    m_isRunning = false
    m_duration = 0.
    m_manaCost = 0
    m_secondsElapsed = 0

    g_looterToOperationMap.remove(m_lootingUnit)
    m_lootingUnit = null

    m_timer.pause()
    m_worldProgressBar.fadeOut()
    
    if (m_notification != null)
      m_notification.close()
      m_notification.release()
      m_notification = null

    if (m_progress != null)
      destroy m_progress
      m_progress = null

    for t in m_lootTimers
      if (t != null)
        t.release()
    m_lootTimers.clear()

    this.unregisterForRealtimeUpdate()

// ============================================================================
public function IUnitMetadata.getLootOperationComponent() returns LootOperationComponent
  return this.getComponent(LootOperationComponent.typeId) castTo LootOperationComponent

// ============================================================================
public function IUnitMetadata.getOrAddLootOperationComponent() returns LootOperationComponent
  var component = this.getLootOperationComponent()
  if (component == null)
    component = this.addComponent(new LootOperationComponent(this)) castTo LootOperationComponent
  return component

// ============================================================================
function onSpellEndCast()
  if (GetSpellAbilityId() != ABILITY_ID_SEARCH)
    return
  
  let lootingUnit = GetSpellAbilityUnit()
  let lootingOperation = g_looterToOperationMap.get(lootingUnit)
  if (lootingOperation == null)
    return

  lootingUnit.resetAbilityCooldown(ABILITY_ID_SEARCH)

// ============================================================================
function resetUnitAnimationAfterRightClickingSameLootable(unit lootingUnit, LootOperationComponent lootOperation)
  // Stand 4 in HD
  lootingUnit.setAnimation(15)
  // Reset the cooldown and other stats since
  prepareSearchSpell(lootingUnit, lootOperation.getTimeRemaining())

// ============================================================================
function prepareSearchSpell(unit lootingUnit, unit lootableUnit)
  let lootableUnitMetadata = lootableUnit.getMetadata()
  if (lootableUnitMetadata == null)
    return
  let lootableComp = lootableUnitMetadata.getLootableComponent()
  if (lootableComp == null)
    return
  let searchDuration = getUnitSearchDuration(lootingUnit, lootableComp.getSearchDuration())
  prepareSearchSpell(lootingUnit, searchDuration)

// ============================================================================
function prepareSearchSpell(unit lootingUnit, real searchDuration)
  let searchAbility = lootingUnit.getAbility(ABILITY_ID_SEARCH)
  if (searchAbility != null)
    let lvl = 0
    lootingUnit.setAbilityLevel(ABILITY_ID_SEARCH, lvl + 1)
    searchAbility.setField(ABILITY_RLF_DURATION_NORMAL, lvl, searchDuration)
    searchAbility.setField(ABILITY_RLF_DURATION_HERO, lvl, searchDuration)
    searchAbility.setField(ABILITY_RLF_ART_DURATION, lvl, searchDuration)
    searchAbility.setField(ABILITY_RLF_FOLLOW_THROUGH_TIME, lvl, searchDuration)
    searchAbility.setField(ABILITY_RLF_COOLDOWN, lvl, searchDuration)
    lootingUnit.setAbilityLevel(ABILITY_ID_SEARCH, lvl)

// ============================================================================
function onSpellChannel()
  if (GetSpellAbilityId() != ABILITY_ID_SEARCH)
    return

  let lootingUnit = GetSpellAbilityUnit()
  let lootableUnit = GetSpellTargetUnit()
  let lootingPlayer = lootingUnit.getOwner()

  let looterMetadata = lootingUnit.getMetadata()
  if (looterMetadata == null)
    Log.debug("Searching unit has no metadata")
    lootingUnit.issueImmediateOrderById(Orders.stop)
    lootingUnit.resetAbilityCooldown(TlsAbilityIds.search)
    return
  
  let lootableMetadata = lootableUnit.getMetadata()
  if (lootableMetadata == null)
    Log.debug("Search target has no metadata")
    lootingUnit.issueImmediateOrderById(Orders.stop)
    lootingUnit.resetAbilityCooldown(TlsAbilityIds.search)
    return

  let lootable = lootableMetadata.getLootableComponent()
  if (lootable == null or not lootable.getEnabled())
    lootingUnit.issueImmediateOrderById(Orders.stop)
    lootingUnit.resetAbilityCooldown(TlsAbilityIds.search)
    displayMessageToPlayer(lootingPlayer, "Failed To Search".colorize(Colors.red) + " Must target a lootable unit to search")
    TlsSounds.errorSoundDef.playForPlayer(lootingPlayer)
    return

  let scaledSearchDuration = getUnitSearchDuration(lootingUnit, lootable.getSearchDuration())
  let manaRemainingAfterSearch = calculateManaRemainingAfterLootOperation(lootingUnit, scaledSearchDuration)
  if (manaRemainingAfterSearch < 0)
  //{
    lootingUnit.issueImmediateOrderById(Orders.stop)
    lootingUnit.resetAbilityCooldown(TlsAbilityIds.search)
    let manaNeeded = (lootingUnit.getMana() + manaRemainingAfterSearch.abs()).floor()
    displayMessageToPlayer(lootingPlayer, "Failed To Search".colorize(Colors.red) + " You need {0} mana to loot this structure.".format(manaNeeded.toString()))
    TlsSounds.errorSoundDef.playForPlayer(lootingPlayer)
    if (getRealTimeSeconds() - g_notEnoughManaLastPlayedTime[lootingPlayer.getId()] > 2)
      g_notEnoughManaLastPlayedTime[lootingPlayer.getId()] = getRealTimeSeconds()
      doAfter(0.5, () -> g_notEnoughManaSoundDef.playForPlayer(lootingPlayer))
    return
  //}

  let lootOperation = lootableMetadata.getLootOperationComponent()
  if (lootOperation != null and lootOperation.getIsRunning())
  //{
    if (lootOperation.getLooter() != lootingUnit)
      lootingUnit.issueImmediateOrderById(Orders.stop)
      lootingUnit.resetAbilityCooldown(TlsAbilityIds.search)
      displayMessageToPlayer(lootingPlayer, "Failed To Search".colorize(Colors.red) + " Lootable is already being looted")
      TlsSounds.errorSoundDef.playForPlayer(lootingPlayer)
      return
    else
      let activeLootingOperation = g_looterToOperationMap.get(lootingUnit)
      if (activeLootingOperation == null or activeLootingOperation != lootOperation)
        Log.error("Expected active looting operation to match")
      // Log.info("unit is actively looting -> resetting")
      resetUnitAnimationAfterRightClickingSameLootable(lootingUnit, activeLootingOperation)
  //}
  else
    // Log.info("unit is starting to loot")
    prepareSearchSpell(lootingUnit, lootableUnit)
    lootable.startLooting(lootingUnit)

// ============================================================================
function onUnitIssuedUnitOrder()
  let orderedUnit = GetOrderedUnit()
  let targetUnit = GetOrderTargetUnit()
  let issuedOrder = GetIssuedOrderId()

  let unitCanSearch = orderedUnit.hasAbility(TlsAbilityIds.search)

  // Stop and issue a search order instead
  if (issuedOrder == Orders.smart and targetUnit.isLootable() and unitCanSearch)
    // Log.info("ordered to search instead")
    if (not orderedUnit.issueTargetOrder(ABILITY_SEARCH_ORDER, targetUnit))
      Log.debug("Could not issue search order")
    return

  if (issuedOrder == OrderId(ABILITY_SEARCH_ORDER_HEROACTION) and targetUnit.isLootable() and unitCanSearch)
    if (not orderedUnit.issueTargetOrder(ABILITY_SEARCH_ORDER, targetUnit))
      Log.debug("Could not issue search order")
    return

  let lootingOperation = g_looterToOperationMap.get(orderedUnit) 
  if (lootingOperation == null)
    // Log.info("unit is not currently looting")
    return

  // If the order issued was search and its the same target lootable dont cancel the operation here.
  // Instead, we'll resume the loot operation as if nothing happened.
  if (issuedOrder == OrderId(ABILITY_SEARCH_ORDER) and lootingOperation.getOwnerUnit() == targetUnit)
    // Log.info("ordered to search same lootable")
    return

  // For any other case cancel the current operation
  // Log.info("issued target order cancels looting")
  lootingOperation.cancel()

// ============================================================================
function onUnitIssuedImmediateOrPointOrder()
  let orderedUnit = GetOrderedUnit()
  let lootingOperation = g_looterToOperationMap.get(orderedUnit)
  if (lootingOperation == null)
    return
  // Log.info("issued immediate or point order cancels looting")
  lootingOperation.cancel()

// ============================================================================
init

  g_activeOperations = new LinkedList<LootOperationComponent>()
  
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_CHANNEL, function onSpellChannel)
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_ENDCAST, function onSpellEndCast)
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_ISSUED_UNIT_ORDER, function onUnitIssuedUnitOrder)
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_ISSUED_ORDER, function onUnitIssuedImmediateOrPointOrder)
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER, function onUnitIssuedImmediateOrPointOrder)

  g_notEnoughManaSoundDef = new SoundDefinition("sound\\dialogue\\genericwarnings\\genericwarningnomana1.flac")

// ============================================================================
init
  registerDayEvent(function onDayStart)
  onUnitIndex(() -> onUnitIndexDeindexed())
  onUnitDeindex(() -> onUnitIndexDeindexed())
  
  for i = 0 to 2
    g_lootFinishedSound[i] = new SoundDefinition("sound\\interface\\goodjob.flac", false, false)
    g_lootFinishedSound[i].volume = 100
    g_lootFinishedSound[i].pitch += i * 0.1
