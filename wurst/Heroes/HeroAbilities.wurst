package HeroAbilities
import TechAvailabilityGroup
import HashMap
import ErrorHandling
import LinkedList
import SmartValue
import ClosureEvents
import ColorUtility
import ChannelAbilityPreset
import public UnitMetadata
import HashList

@configurable colorA HERO_ABILITY_COLOR = Colors.gold
@configurable colorA HERO_ABILITY_OVER_LEVELED_COLOR = Colors.green

HashMap<int, int> g_abilityIdToComponentTypeMap = new HashMap<int, int>()
HashList<int> g_allHeroAbilityComponentTypeIds = new HashList<int>()

// ============================================================================
public enum HeroAbilityGroup
  Q
  W
  E
  R
  UNKNOWN

// ============================================================================
function HeroAbilityGroup.toString() returns string
  return this == Q ? "Q" : (this == W ? "W" : (this == E ? "E" : (this == R ? "R" : "<Unknown>")))

// ============================================================================
public class HeroAbilities

  static HeroAbilities scout = new HeroAbilities()
  static HeroAbilities mountaineer = new HeroAbilities()
  static HeroAbilities captain = new HeroAbilities()
  static HeroAbilities tinkerer = new HeroAbilities()

  private TechAvailabilityGroup array[4] m_abilityGroup = [ new TechAvailabilityGroup(), new TechAvailabilityGroup(), new TechAvailabilityGroup(), new TechAvailabilityGroup() ]
  private int array[4] m_abilityGroupDefault = [ 0, 0, 0, 0 ]
  private HashMap<int, HeroAbilityGroup> m_abilIdToGroup = new HashMap<int, HeroAbilityGroup>()

  // --------------------------------------------------------------------------
  private construct()
    skip

  // --------------------------------------------------------------------------
  function hasAbility(int abilId) returns bool
    return m_abilIdToGroup.has(abilId)

  // --------------------------------------------------------------------------
  function getHeroAbilityGroup(int abilId) returns HeroAbilityGroup
    return m_abilIdToGroup.has(abilId) ? m_abilIdToGroup.get(abilId) : HeroAbilityGroup.UNKNOWN

  // --------------------------------------------------------------------------
  function setHeroAbilityGroup(int abilId, HeroAbilityGroup heroAbilityGroup)
    setHeroAbilityGroup(abilId, heroAbilityGroup, false)

  // --------------------------------------------------------------------------
  function setHeroAbilityGroup(int abilId, HeroAbilityGroup heroAbilityGroup, bool isGroupDefault)
    let existingHeroAbilityGroup = getHeroAbilityGroup(abilId)
    if (existingHeroAbilityGroup != UNKNOWN)
      error("Ability " + AbilityId2String(abilId) + " already registered with group " + existingHeroAbilityGroup.toString())
    if (heroAbilityGroup == UNKNOWN)
      error("Argument 'heroAbilityGroup' cannot be value 'UNKNOWN'")
    m_abilIdToGroup.put(abilId, heroAbilityGroup)
    m_abilityGroup[heroAbilityGroup castTo int].add(abilId)
    if (isGroupDefault)
      m_abilityGroupDefault[heroAbilityGroup castTo int] = abilId

  // --------------------------------------------------------------------------
  function getHeroAbilityGroupDefault(HeroAbilityGroup heroAbilityGroup) returns int
    return m_abilityGroupDefault[heroAbilityGroup castTo int]

  // --------------------------------------------------------------------------
  function getHeroAbilitiesDefinitionString() returns string
    let list = new LinkedList<int>()
    for i = 0 to 3
      for abilId in m_abilityGroup[i]
        list.add(abilId)
    let result = list.joinBy((int i) -> i.toRawCode(), ",")
    destroy list
    return result

  // --------------------------------------------------------------------------
  function disableAllHeroAbilities(player _player)
    for i = 0 to 3
      m_abilityGroup[i].disable(_player)

// ============================================================================
public abstract class HeroAbilityComponent extends UnitComponent
  private int m_abilityId
  private int m_abilityLearnId

  SmartValue abilityLevel = new SmartValue()

  // --------------------------------------------------------------------------
  construct (IUnitMetadata owner, int abilityId, int abilityLearnId)
    super(owner)

    setDisableOnDeath(false)

    m_abilityId = abilityId
    m_abilityLearnId = abilityLearnId

    abilityLevel.onValueChanged().registerDispatched(this) () ->
      // Log.info("Ability level: " + abilityLevel.getIntValue().toString())
      updateAbilityState()

  // --------------------------------------------------------------------------
  ondestroy
    destroy abilityLevel

  // --------------------------------------------------------------------------
  function getAbilityLevel() returns int
    return getOwnerUnit().getAbilityLevel(m_abilityId)

  // --------------------------------------------------------------------------
  function getEffectiveAbilityLevel() returns int
    return abilityLevel.getIntValue()

  // --------------------------------------------------------------------------
  function getLearnedAbilityLevel() returns int
    return getOwnerUnit().getAbilityLevel(m_abilityLearnId)

  // --------------------------------------------------------------------------
  override function onEnabled()
    super.onEnabled()
    updateAbilityState()

  // --------------------------------------------------------------------------
  protected function onCast(int _abilityId)
    skip

  // --------------------------------------------------------------------------
  protected function onEffect(int _abilityId)
    skip

  // --------------------------------------------------------------------------
  protected function onChannel(int _abilityIdS)
    skip

  // --------------------------------------------------------------------------
  protected function onFinishCast(int _abilityId)
    skip

  // --------------------------------------------------------------------------
  protected function onEndCast(int _abilityId)
    skip

  // --------------------------------------------------------------------------
  protected function updateAbilityState()
    let ownerUnit = getOwnerUnit()
    
    let learnedAbilityLevel = getLearnedAbilityLevel()
    let effectiveAbilityLevel = getEffectiveAbilityLevel()

    if (effectiveAbilityLevel == 0)
      if (ownerUnit.hasAbility(m_abilityId))
        ownerUnit.removeAbility(m_abilityId)
        if (ownerUnit.hasAbility(m_abilityId))
          Log.error("Failed to remove ability " + m_abilityId.toRawCode())
    else
      if (not ownerUnit.hasAbility(m_abilityId))
        ownerUnit.addAbility(m_abilityId)
        if (ownerUnit.hasAbility(m_abilityId) == false)
          Log.error("Unable to add hero ability " + m_abilityId.toRawCode())

      let abil = ownerUnit.getAbility(m_abilityId)
      if (abil != null)
        ownerUnit.setAbilityLevel(m_abilityId, effectiveAbilityLevel + 1)
        ownerUnit.getOwner().setAbilityTooltip(m_abilityId, getTooltipNormal(effectiveAbilityLevel, learnedAbilityLevel), effectiveAbilityLevel - 1)
        ownerUnit.getOwner().setAbilityExtendedTooltip(m_abilityId, getTooltipNormalExtended(effectiveAbilityLevel, learnedAbilityLevel), effectiveAbilityLevel - 1)
        ownerUnit.setAbilityLevel(m_abilityId, effectiveAbilityLevel)

  // --------------------------------------------------------------------------
  protected function onUnitLearnedSkill()
    abilityLevel.setBase(getOwnerUnit().getAbilityLevel(m_abilityLearnId))

  // --------------------------------------------------------------------------
  protected override function onOwnerRevived()
    super.onOwnerRevived()
    abilityLevel.setBase(getOwnerUnit().getAbilityLevel(m_abilityLearnId))

  // --------------------------------------------------------------------------
  protected abstract function getTooltipNormal(int effectiveAbilityLevel, int learnedAbilityLevel) returns string

  // --------------------------------------------------------------------------
  protected abstract function getTooltipNormalExtended(int effectiveAbilityLevel, int learnedAbilityLevel) returns string

// ============================================================================
public function registerHeroAbilityComponentType(int componentTypeId, int abilityId)
  if (g_abilityIdToComponentTypeMap.has(abilityId))
    error("Hero ability id {0} already registered to {1}".format(abilityId.toRawCode(), componentTypeId.toString()))
  g_abilityIdToComponentTypeMap.put(abilityId, componentTypeId)
  g_allHeroAbilityComponentTypeIds.add(componentTypeId)

// ============================================================================
function IUnitMetadata.getHeroAbilityComponent(int abilityId) returns HeroAbilityComponent
  if (not g_abilityIdToComponentTypeMap.has(abilityId))
    return null
  let componentTypeId = g_abilityIdToComponentTypeMap.get(abilityId)
  if (componentTypeId == 0)
    return null
  return this.getComponent(componentTypeId) castTo HeroAbilityComponent

// ============================================================================
function onUnitLearnedSkill()
  let learnedSkill = GetLearnedSkill()
  let learningUnit = GetLearningUnit()

  let abilityComp = learningUnit.getMetadata().getHeroAbilityComponent(learnedSkill)
  if (abilityComp == null or not abilityComp.getEnabled())
    return

  abilityComp.onUnitLearnedSkill()

// ============================================================================
function onHeroReviveFinish()

  let revivedHero = GetRevivingUnit()

  let metadata = revivedHero.getMetadata()
  if (metadata == null)
    return

  for heroAbilityComponentTypeId in g_allHeroAbilityComponentTypeIds
    let comp = metadata.getComponent(heroAbilityComponentTypeId) castTo HeroAbilityComponent
    if (comp != null)
      comp.updateAbilityState()

// ============================================================================
function onHeroAbilityCast(unit caster, int componentTypeId)
  let comp = caster.getComponent(componentTypeId) castTo HeroAbilityComponent
  if (comp != null and comp.getEnabled())
    comp.onCast(GetSpellAbilityId())

// ============================================================================
public function string.colorizeTooltipForHeroAbility(int effectiveAbilityLevel, int maxLearnedAbilityLevel) returns string
  return this.colorize(effectiveAbilityLevel > maxLearnedAbilityLevel ? HERO_ABILITY_OVER_LEVELED_COLOR : HERO_ABILITY_COLOR)

// ============================================================================
public class HeroLearnAbilityDefinition extends ChannelAbilityPreset

  // --------------------------------------------------------------------------
  construct(int learnAbilityId, int levels)
    super(learnAbilityId, levels, true)
    presetOption(Option.VISIBLE, true)
    setHeroAbility(true)
    setButtonPositionNormalX(0)
    setButtonPositionNormalY(-11)

// ============================================================================
public function AbilityDefinition.setupHeroAbilityGroup(HeroAbilityGroup heroAbilityGroup)
  this.setHotkeyTurnOff("")
  this.setHotkeyLearn("")
  switch (heroAbilityGroup)
    case HeroAbilityGroup.Q
      this.setButtonPositionNormalX(0)
      this.setButtonPositionNormalY(2)
      this.setButtonPositionTurnOffX(0)
      this.setButtonPositionTurnOffY(2)
      this.setHotkeyNormal("Q")
      this.setHotkeyTurnOff("Q")
    case HeroAbilityGroup.W
      this.setButtonPositionNormalX(1)
      this.setButtonPositionNormalY(2)
      this.setButtonPositionTurnOffX(1)
      this.setButtonPositionTurnOffY(2)
      this.setHotkeyNormal("W")
      this.setHotkeyTurnOff("W")
    case HeroAbilityGroup.E
      this.setButtonPositionNormalX(2)
      this.setButtonPositionNormalY(2)
      this.setButtonPositionTurnOffX(2)
      this.setButtonPositionTurnOffY(2)
      this.setHotkeyNormal("E")
      this.setHotkeyTurnOff("E")
    case HeroAbilityGroup.R
      this.setButtonPositionNormalX(3)
      this.setButtonPositionNormalY(2)
      this.setButtonPositionTurnOffX(3)
      this.setButtonPositionTurnOffY(2)
      this.setHotkeyNormal("R")
      this.setHotkeyTurnOff("R")
    default
      error("Invalid argument heroAbilityGroup " + (heroAbilityGroup castTo int).toString())

// ============================================================================
public function HeroLearnAbilityDefinition.setupHeroAbilityGroup(HeroAbilityGroup heroAbilityGroup, int row)
  this.setButtonPositionNormalX(0)
  this.setButtonPositionNormalY(-11)
  this.setHotkeyNormal("")
  this.setHotkeyTurnOff("")
  switch (heroAbilityGroup)
    case HeroAbilityGroup.Q
      this.setButtonPositionResearchX(0)
      this.setButtonPositionResearchY(row)
      this.setHotkeyLearn("Q")
    case HeroAbilityGroup.W
      this.setButtonPositionResearchX(1)
      this.setButtonPositionResearchY(row)
      this.setHotkeyLearn("W")
    case HeroAbilityGroup.E
      this.setButtonPositionResearchX(2)
      this.setButtonPositionResearchY(row)
      this.setHotkeyLearn("E")
    case HeroAbilityGroup.R
      this.setButtonPositionResearchX(3)
      this.setButtonPositionResearchY(row)
      this.setHotkeyLearn("R")
    default
      error("Invalid argument heroAbilityGroup " + (heroAbilityGroup castTo int).toString())

// ============================================================================
function onSpellCast()
  let castingUnit = GetSpellAbilityUnit()
  let abilityId = GetSpellAbilityId()

  let abilityComp = castingUnit.getMetadata().getHeroAbilityComponent(abilityId)
  if (abilityComp == null or not abilityComp.getEnabled())
    return

  abilityComp.onCast(abilityId)

// ============================================================================
function onSpellEffect()
  let castingUnit = GetSpellAbilityUnit()
  let abilityId = GetSpellAbilityId()

  let abilityComp = castingUnit.getMetadata().getHeroAbilityComponent(abilityId)
  if (abilityComp == null or not abilityComp.getEnabled())
    return

  abilityComp.onEffect(abilityId)

// ============================================================================
function onSpellChannel()
  let castingUnit = GetSpellAbilityUnit()
  let abilityId = GetSpellAbilityId()

  let abilityComp = castingUnit.getMetadata().getHeroAbilityComponent(abilityId)
  if (abilityComp == null or not abilityComp.getEnabled())
    return

  abilityComp.onChannel(abilityId)

// ============================================================================
function onSpellEndCast()
  let castingUnit = GetSpellAbilityUnit()
  let abilityId = GetSpellAbilityId()

  let abilityComp = castingUnit.getMetadata().getHeroAbilityComponent(abilityId)
  if (abilityComp == null or not abilityComp.getEnabled())
    return

  abilityComp.onEndCast(abilityId)

// ============================================================================
function onSpellFinish()
  let castingUnit = GetSpellAbilityUnit()
  let abilityId = GetSpellAbilityId()

  let abilityComp = castingUnit.getMetadata().getHeroAbilityComponent(abilityId)
  if (abilityComp == null or not abilityComp.getEnabled())
    return

  abilityComp.onFinishCast(abilityId)

// ============================================================================
init
  registerPlayerUnitEvent(EVENT_PLAYER_HERO_SKILL, function onUnitLearnedSkill)
  registerPlayerUnitEvent(EVENT_PLAYER_HERO_REVIVE_FINISH, function onHeroReviveFinish)

  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_CHANNEL, function onSpellChannel)
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_CAST, function onSpellCast)
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_EFFECT, function onSpellEffect)
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_ENDCAST, function onSpellEndCast)
  registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_FINISH, function onSpellFinish)