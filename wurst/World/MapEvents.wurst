package MapEvents
import Transform
import HashMap
import Quaternion
import TerrainUtils
import Vector
import Preload
import GroupUtils
import LinkedList
import LootableTypes
import ClosureTimers
import Predicate
import TlsMapEventIds
import Runnable
import Func
import Jobs
import UnitRecycler
import UnitExtensions
import ErrorHandling
import Bounds
import CancellationToken

import initlater MapEventsInit

HashMap<string, Func<MapEventTemplate>> g_mapEventTemplateFactories = new HashMap<string, Func<MapEventTemplate>>()
HashMap<string, Func<MapEvent>> g_mapEventFactories = new HashMap<string, Func<MapEvent>>()
LinkedList<MapEventTemplate> g_mapEventTemplates = new LinkedList<MapEventTemplate>()
LinkedList<MapEventInstance> g_mapEventInstances = new LinkedList<MapEventInstance>()
LinkedList<MapEvent> g_mapEvents = new LinkedList<MapEvent>()
LinkedList<MapEvent> g_runningMapEvents = new LinkedList<MapEvent>()
location g_tempLoc = Location(0, 0)
destructable array g_enumDestructables
int g_enumDestructablesCount
boolexpr g_filterUnitIsLootable = Condition(function filterUnitIsLootable)

// ============================================================================
public class MapEventTemplate

  private string m_id
  private IterableMap<int, Vector<MapEventUnitSpawner>> m_unitSpawnersByTypeId = new IterableMap<int, Vector<MapEventUnitSpawner>>()
  private Vector<MapEventUnitSpawner> m_unitSpawners
  private Vector<MapEventDestructableSpawner> m_destructableSpawners
  private Vector<MapEventAreaCleanerSpawner> m_areaCleaners
  private Vector<MapEventTileSpawner> m_tileSpawners

  // --------------------------------------------------------------------------
  construct(string id)
    m_id = id
    m_unitSpawners = new Vector<MapEventUnitSpawner>()
    m_destructableSpawners = new Vector<MapEventDestructableSpawner>()
    m_areaCleaners = new Vector<MapEventAreaCleanerSpawner>()
    m_tileSpawners = new Vector<MapEventTileSpawner>()

    g_mapEventTemplates.add(this)

  // --------------------------------------------------------------------------
  ondestroy

    g_mapEventTemplates.remove(this)
    
    for spawner in m_unitSpawners
      destroy spawner
    destroy m_unitSpawners
    m_unitSpawners = null
    
    for spawner in m_destructableSpawners
      destroy spawner
    destroy m_destructableSpawners
    m_destructableSpawners = null
    
    for spawner in m_tileSpawners
      destroy spawner
    destroy m_tileSpawners
    m_tileSpawners = null

    for key in m_unitSpawnersByTypeId
      destroy m_unitSpawnersByTypeId.get(key)
    destroy m_unitSpawnersByTypeId
    m_unitSpawnersByTypeId = null

  // --------------------------------------------------------------------------
  static function getTemplate(string id) returns MapEventTemplate
    for met in g_mapEventTemplates
      if (met.m_id == id)
        return met
    return null

  // --------------------------------------------------------------------------
  static function createMapEventTemplate(string id) returns MapEventTemplate
    let factory = g_mapEventTemplateFactories.get(id)
    return factory != null ? factory.call() : new MapEventTemplate(id)

  // --------------------------------------------------------------------------
  static function registerMapEventTemplateFactory(string id, Func<MapEventTemplate> factory)
    g_mapEventTemplateFactories.put(id, factory.acquire())

  // --------------------------------------------------------------------------
  function getId() returns string
    return m_id

  // --------------------------------------------------------------------------
  function registerUnitSpawner(int unitTypeId, vec3 localPos, angle localYaw) returns MapEventUnitSpawner
    let localTransform = transform(localPos, ZERO3, eulerToQuat(localYaw.radians(), 0.0, 0.0), 1.0)
    return registerUnitSpawner(unitTypeId, localTransform)

  // --------------------------------------------------------------------------
  function registerUnitSpawner(int unitTypeId, transform localTransform) returns MapEventUnitSpawner

    if (unitTypeId == TlsMapEventIds.areaCleaner128)
      registerAreaCleaner(128.0, localTransform)
      return null

    if (unitTypeId == TlsMapEventIds.areaCleaner256)
      registerAreaCleaner(256.0, localTransform)
      return null

    let unitSpawner = new MapEventUnitSpawner(unitTypeId, localTransform)

    var unitSpawners = m_unitSpawnersByTypeId.get(unitTypeId)
    if (unitSpawners == null)
      unitSpawners = new Vector<MapEventUnitSpawner>()
      m_unitSpawnersByTypeId.put(unitTypeId, unitSpawners)

    unitSpawners.add(unitSpawner)

    m_unitSpawners.add(unitSpawner)

    // Add to preloader so we don't get a hitch when spawning the map event
    Preload.registerUnitTypeId(unitTypeId)

    return unitSpawner

  // --------------------------------------------------------------------------
  function registerDestSpawner(int destructableTypeId, int variation, vec3 localPos, angle localYaw, real localScale)
    let localTransform = transform(localPos, ZERO3, eulerToQuat(localYaw.radians(), 0.0, 0.0), localScale)
    registerDestSpawner(destructableTypeId, variation, localTransform)

  // --------------------------------------------------------------------------
  function registerDestSpawner(int destructableTypeId, int variation, transform localTransform)
    m_destructableSpawners.add(new MapEventDestructableSpawner(destructableTypeId, variation, localTransform))
    
    // Add to preloader so we don't get a hitch when spawning the map event
    Preload.registerDestructableTypeId(destructableTypeId, variation)

  // --------------------------------------------------------------------------
  function registerAreaCleaner(real radius, vec2 localPos)
    let localTransform = transform(localPos.toVec3(), ZERO3, IDENTITYQ, 1.0)
    registerAreaCleaner(radius, localTransform)

  // --------------------------------------------------------------------------
  function registerAreaCleaner(real radius, transform localTransform)
    m_areaCleaners.add(new MapEventAreaCleanerSpawner(radius, localTransform))

  // --------------------------------------------------------------------------
  function registerTileSpawner(int tilesetId, int variation, int localTileCornerX, int localTileCornerY)
    let localPos = vec3(localTileCornerX * 128.0, localTileCornerY * 128.0, 0.0)
    let localTransform = transform(localPos, ZERO3, IDENTITYQ, 1.0)
    registerTileSpawner(tilesetId, variation, localTransform)

  // --------------------------------------------------------------------------
  function registerTileSpawner(int tilesetId, int variation, transform localTransform)
    m_tileSpawners.add(new MapEventTileSpawner(tilesetId, variation, localTransform))

  // --------------------------------------------------------------------------
  function getUnitSpawnerCount() returns int
    return m_unitSpawners.size()

  // --------------------------------------------------------------------------
  function getUnitSpawner(int index) returns MapEventUnitSpawner
    return m_unitSpawners.get(index)

  // --------------------------------------------------------------------------
  function getUnitSpawnerByTypeIdCount(int unitTypeId) returns int
    let unitSpawners = m_unitSpawnersByTypeId.get(unitTypeId)
    return unitSpawners != null ? unitSpawners.size() : 0

  // --------------------------------------------------------------------------
  function getUnitSpawnerByTypeId(int unitTypeId, int index) returns MapEventUnitSpawner
    let unitSpawners = m_unitSpawnersByTypeId.get(unitTypeId)
    return unitSpawners != null ? unitSpawners.get(index) : null

  // --------------------------------------------------------------------------
  function getDestSpawnerCount() returns int
    return m_destructableSpawners.size()

  // --------------------------------------------------------------------------
  function getDestSpawner(int index) returns MapEventDestructableSpawner
    return m_destructableSpawners.get(index)

  // --------------------------------------------------------------------------
  function getAreaCleanerCount() returns int
    return m_areaCleaners.size()

  // --------------------------------------------------------------------------
  function getAreaCleaner(int index) returns MapEventAreaCleanerSpawner
    return m_areaCleaners.get(index)

  // --------------------------------------------------------------------------
  function getTileSpawnerCount() returns int
    return m_tileSpawners.size()

  // --------------------------------------------------------------------------
  function getTileSpawner(int index) returns MapEventTileSpawner
    return m_tileSpawners.get(index)

  // --------------------------------------------------------------------------
  function createInstance() returns MapEventInstance
    return new MapEventInstance(this)

// ============================================================================
public class MapEventInstance

  static JobThread cleanerThread = new JobThread("me_clnr")
    ..setMaxWorkPerTick(1)
    ..setEnabled(true)

  static JobThread unitThread = new JobThread("me_unit")
    ..setMaxWorkPerTick(1)
    ..setEnabled(true)
    ..setDependsOnThread(cleanerThread)

  static JobThread destThread = new JobThread("me_dest")
    ..setMaxWorkPerTick(1)
    ..setEnabled(true)
    ..setDependsOnThread(unitThread)

  static JobThread tileThread = new JobThread("me_tile")
    ..setMaxWorkPerTick(1)
    ..setEnabled(true)

  private player m_owner = null
  private transform m_worldTransform = IDENTITYT
  private MapEventTemplate m_template = null
  private group m_spawnedUnits = null
  private IterableMap<MapEventUnitSpawner, group> m_spawnerToSpawnedUnits = null
  private HashMap<unit, MapEventUnitSpawner> m_spawnedUnitToSpawner = null
  private Vector<destructable> m_spawnedDestructables = null
  private Vector<MapEventAreaCleanerInstance> m_cleaners = null
  private Vector<MapEventTileInstance> m_spawnedTiles = null
  private Predicate<MapEventUnitSpawner> m_unitFilter = null
  private Predicate<MapEventDestructableSpawner> m_destructableFilter = null
  private CancellationToken m_ct

  private JobThread m_cleanerThread = cleanerThread
  private JobThread m_unitThread = unitThread
  private JobThread m_destThread = destThread
  private JobThread m_tileThread = tileThread

  // --------------------------------------------------------------------------
  construct(MapEventTemplate template)
    m_template = template
    m_ct = new CancellationToken().acquire()

    g_mapEventInstances.add(this)

  // --------------------------------------------------------------------------
  ondestroy

    g_mapEventInstances.remove(this)
    
    m_ct.cancelAndRelease()
    m_ct = null

    unspawnAll()

    if (m_destructableFilter != null)
      m_destructableFilter.release()
      m_destructableFilter = null

    if (m_unitFilter != null)
      m_unitFilter.release()
      m_unitFilter = null

  // --------------------------------------------------------------------------
  function getTemplate() returns MapEventTemplate
    return m_template

  // --------------------------------------------------------------------------
  function getWorldTransform() returns transform
    return m_worldTransform

  // --------------------------------------------------------------------------
  function setWorldTransform(transform value)
    m_worldTransform = value

  // --------------------------------------------------------------------------
  function setUnitFilter(Predicate<MapEventUnitSpawner> filter)
    if (m_unitFilter != null)
      m_unitFilter.release()
    m_unitFilter = filter.acquire()

  // --------------------------------------------------------------------------
  function setDestructableFilter(Predicate<MapEventDestructableSpawner> filter)
    if (m_destructableFilter != null)
      m_destructableFilter.release()
    m_destructableFilter = filter.acquire()

  // --------------------------------------------------------------------------
  function setOwner(player owner)
    m_owner = owner

  // --------------------------------------------------------------------------
  function getOwner() returns player
    return m_owner

  // --------------------------------------------------------------------------
  function getSpawnedUnits() returns group
    return m_spawnedUnits

  // --------------------------------------------------------------------------
  function getUnitSpawnThread() returns JobThread
    return m_unitThread

  // --------------------------------------------------------------------------
  function setUnitSpawnThread(JobThread value)
    m_unitThread = value

  // --------------------------------------------------------------------------
  function getDestSpawnThread() returns JobThread
    return m_destThread

  // --------------------------------------------------------------------------
  function setDestSpawnThread(JobThread value)
    m_destThread = value

  // --------------------------------------------------------------------------
  function getTileSpawnThread() returns JobThread
    return m_tileThread

  // --------------------------------------------------------------------------
  function setTileSpawnThread(JobThread value)
    m_tileThread = value

  // --------------------------------------------------------------------------
  function getCleanerSpawnThread() returns JobThread
    return m_cleanerThread

  // --------------------------------------------------------------------------
  function setCleanerSpawnThread(JobThread value)
    m_cleanerThread = value

  // --------------------------------------------------------------------------
  function spawn()
    spawnCleaners()
    spawnTiles()
    if (m_owner != null)
      spawnUnits(m_owner)
    spawnDestructables()

  // --------------------------------------------------------------------------
  function spawnUnitNow(MapEventUnitSpawner spawner, player owner) returns unit
    if (m_spawnedUnits == null)
      m_spawnedUnits = getGroup()

    let spawnedUnit = spawner.spawn(owner, m_worldTransform)
    if (spawnedUnit != null)
    //{
      m_spawnedUnits.addUnit(spawnedUnit)

      if (m_spawnerToSpawnedUnits == null)
        m_spawnerToSpawnedUnits = new IterableMap<MapEventUnitSpawner, group>()

      var spawnedUnitsBySpawner = m_spawnerToSpawnedUnits.get(spawner)
      if (spawnedUnitsBySpawner == null)
        spawnedUnitsBySpawner = getGroup()
        m_spawnerToSpawnedUnits.put(spawner, spawnedUnitsBySpawner)

      spawnedUnitsBySpawner.addUnit(spawnedUnit)

      if (m_spawnedUnitToSpawner == null)
        m_spawnedUnitToSpawner = new HashMap<unit, MapEventUnitSpawner>()

      m_spawnedUnitToSpawner.put(spawnedUnit, spawner)
    //}

    return spawnedUnit

  // --------------------------------------------------------------------------
  function spawnUnitNow(MapEventUnitSpawner spawner, player owner, int unitTypeIdOverride) returns unit
    if (m_spawnedUnits == null)
      m_spawnedUnits = getGroup()

    let spawnedUnit = spawner.spawn(owner, unitTypeIdOverride, m_worldTransform)
    if (spawnedUnit != null)
      m_spawnedUnits.addUnit(spawnedUnit)

    return spawnedUnit

  // --------------------------------------------------------------------------
  function spawnUnit(MapEventUnitSpawner spawner, player owner) returns FuncJob<unit>
    return m_unitThread.invokeFunc(m_ct, () -> spawnUnitNow(spawner, owner))

  // --------------------------------------------------------------------------
  function spawnUnit(MapEventUnitSpawner spawner, player owner, int unitTypeIdOverride) returns FuncJob<unit>
    return m_unitThread.invokeFunc(m_ct, () -> spawnUnitNow(spawner, owner, unitTypeIdOverride))

  // --------------------------------------------------------------------------
  function spawnUnits(player owner) returns Job
    let unitSpawnerCount = m_template.getUnitSpawnerCount()
    return m_unitThread.repeat(m_ct, unitSpawnerCount) (integer i) ->
    //{
      let spawner = m_template.getUnitSpawner(i)
      if (m_unitFilter == null or m_unitFilter.call(spawner))
        spawnUnitNow(spawner, owner)
    //}

  // --------------------------------------------------------------------------
  function spawnUnits(player owner, int spawnerUnitTypeId, int actualUnitTypeId) returns Job
    let unitSpawnerCount = m_template.getUnitSpawnerByTypeIdCount(spawnerUnitTypeId)
    return m_unitThread.repeat(m_ct, unitSpawnerCount) (integer i) ->
    //{
      let spawner = m_template.getUnitSpawnerByTypeId(spawnerUnitTypeId, i)
      if (m_unitFilter == null or m_unitFilter.call(spawner))
        spawnUnitNow(spawner, owner, actualUnitTypeId)
    //}

  // --------------------------------------------------------------------------
  function unspawnUnitNow(unit spawnedUnit)
    
    let spawner = m_spawnedUnitToSpawner.get(spawnedUnit)
    if (spawner == null)
      error("Unit is not registered with map event instance")

    let spawnedUnits = m_spawnerToSpawnedUnits.get(spawner)
    if (spawnedUnits == null)
      error("No spawned unit group for unit spawner")

    unspawnUnitNow(
      m_spawnedUnits,
      m_spawnerToSpawnedUnits,
      m_spawnedUnitToSpawner,
      spawner,
      spawnedUnits,
      spawnedUnit)

  // --------------------------------------------------------------------------
  function unspawnUnit(unit spawnedUnit) returns Job
    return m_unitThread.invoke(m_ct, () -> unspawnUnitNow(spawnedUnit))

  // --------------------------------------------------------------------------
  function unspawnUnits() returns Job

    let whenAllJob = new WhenAllJob()

    let spawnerToSpawnedUnits = m_spawnerToSpawnedUnits
    m_spawnerToSpawnedUnits = null

    let spawnedUnitToSpawner = m_spawnedUnitToSpawner
    m_spawnedUnitToSpawner = null
    
    let allSpawnedUnits = m_spawnedUnits
    m_spawnedUnits = null

    for spawner in spawnerToSpawnedUnits
    //{
      let spawnedUnitsBySpawner = spawnerToSpawnedUnits.get(spawner)
      for spawnedUnit in spawnedUnitsBySpawner
      //{
        let unspawnUnitJob = m_unitThread.invoke(() -> unspawnUnitNow(allSpawnedUnits, spawnerToSpawnedUnits, spawnedUnitToSpawner, spawner, spawnedUnitsBySpawner, spawnedUnit))
        whenAllJob.addJob(unspawnUnitJob)
      //}
    //}

    m_unitThread.enqueue(whenAllJob)

    return whenAllJob

  // --------------------------------------------------------------------------
  private static function unspawnUnitNow(
    group spawnedUnits,
    IterableMap<MapEventUnitSpawner, group> spawnerToSpawnedUnits,
    HashMap<unit, MapEventUnitSpawner> spawnedUnitToSpawner,
    MapEventUnitSpawner spawner,
    group spawnedUnitsBySpawner,
    unit spawnedUnit)
    
    spawner.unspawnUnit(spawnedUnit)
    
    spawnedUnits.removeUnit(spawnedUnit)
    
    spawnedUnitsBySpawner.removeUnit(spawnedUnit)
    if (spawnedUnitsBySpawner.isEmpty())
      spawnedUnitsBySpawner.release()
      spawnerToSpawnedUnits.remove(spawner)

    spawnedUnitToSpawner.remove(spawnedUnit)

  // --------------------------------------------------------------------------
  function spawnDestructableNow(MapEventDestructableSpawner spawner) returns destructable
    if (m_spawnedDestructables == null)
      m_spawnedDestructables = new Vector<destructable>()

    let spawnedDest = spawner.spawn(m_worldTransform)
    if (spawnedDest != null)
      m_spawnedDestructables.add(spawnedDest)

    return spawnedDest

  // --------------------------------------------------------------------------
  function spawnDestructable(MapEventDestructableSpawner spawner) returns FuncJob<destructable>
    return m_destThread.invokeFunc(m_ct, () -> spawnDestructableNow(spawner))
  
  // --------------------------------------------------------------------------
  function spawnDestructables() returns Job
    let destSpawnerCount = m_template.getDestSpawnerCount()
    return m_destThread.repeat(m_ct, destSpawnerCount) (integer i) ->
    //{
      if (m_spawnedDestructables == null)
        m_spawnedDestructables = new Vector<destructable>(destSpawnerCount)

      let spawner = m_template.getDestSpawner(i)
      if (m_destructableFilter == null or m_destructableFilter.call(spawner))
        spawnDestructableNow(spawner)
    //}

  // --------------------------------------------------------------------------
  function unspawnDestructables() returns Job

    let spawnedDestructables = m_spawnedDestructables
    m_spawnedDestructables = null

    let job = m_destThread.repeatWhile(
      (_) -> spawnedDestructables.pop().remove(),
      () -> not spawnedDestructables.isEmpty())

    job.onCompleted().register() (Job _) ->
      destroy spawnedDestructables

    return job
  
  // --------------------------------------------------------------------------
  function spawnTileNow(MapEventTileSpawner spawner) returns MapEventTileInstance
    if (m_spawnedTiles == null)
      m_spawnedTiles = new Vector<MapEventTileInstance>()
    
    let spawnedTile = spawner.spawn(m_worldTransform)
    if (spawnedTile != null)
      m_spawnedTiles.add(spawnedTile)
    
    return spawnedTile
  
  // --------------------------------------------------------------------------
  function spawnTile(MapEventTileSpawner spawner) returns FuncJob<MapEventTileInstance>
    return m_tileThread.invokeFunc(m_ct, () -> spawnTileNow(spawner))

  // --------------------------------------------------------------------------
  function spawnTiles() returns Job
    let tileSpawnerCount = m_template.getTileSpawnerCount()
    return m_tileThread.repeat(m_ct, tileSpawnerCount) (integer i) ->
    //{
      if (m_spawnedTiles == null)
        m_spawnedTiles = new Vector<MapEventTileInstance>(tileSpawnerCount)

      let spawner = m_template.getTileSpawner(i)
      spawnTileNow(spawner)
    //}

  // --------------------------------------------------------------------------
  function unspawnTiles() returns Job

    let spawnedTiles = m_spawnedTiles
    m_spawnedTiles = null

    let job = m_tileThread.repeatWhile(
      (_) -> destroy spawnedTiles.pop(),
      () -> not spawnedTiles.isEmpty())
    
    job.onCompleted().register() (Job _) ->
      destroy spawnedTiles

    return job

  // --------------------------------------------------------------------------
  function spawnCleanerNow(MapEventAreaCleanerSpawner spawner) returns MapEventAreaCleanerInstance
    if (m_cleaners == null)
      m_cleaners = new Vector<MapEventAreaCleanerInstance>()

    let instance = spawner.spawn(m_worldTransform)
    if (instance != null)
      m_cleaners.add(instance)

    return instance

  // --------------------------------------------------------------------------
  function spawnCleaner(MapEventAreaCleanerSpawner spawner) returns FuncJob<MapEventAreaCleanerInstance>
    return m_cleanerThread.invokeFunc(m_ct, () -> spawnCleanerNow(spawner))

  // --------------------------------------------------------------------------
  function spawnCleaners() returns Job
    let cleanerCount = m_template.getAreaCleanerCount()
    return m_cleanerThread.repeat(m_ct, cleanerCount) (integer i) ->
    //{
      if (m_cleaners == null)
        m_cleaners = new Vector<MapEventAreaCleanerInstance>(cleanerCount)

      let cleaner = m_template.getAreaCleaner(i)
      spawnCleanerNow(cleaner)
    //}

  // --------------------------------------------------------------------------
  function unspawnCleaners() returns Job

    let cleaners = m_cleaners
    m_cleaners = null

    let job = m_cleanerThread.repeatWhile(
      (_) -> destroy cleaners.pop(),
      () -> not cleaners.isEmpty())
    
    job.onCompleted().register() (Job _) ->
      destroy cleaners

    return job

  // --------------------------------------------------------------------------
  function unspawnAll()
    unspawnUnits()
    unspawnDestructables()
    unspawnTiles()
    unspawnCleaners()

// ============================================================================
public class MapEventUnitSpawner
  private int m_unitTypeId
  private transform m_localTransform
  private real m_fadeInDuration
  private real m_fadeOutDuration
  private int m_fadeOutMove
  private vec2 m_fadeOutMoveToPos
  private bool m_useRecycler

  // --------------------------------------------------------------------------
  construct(int unitTypeId, transform localTransform)
    m_unitTypeId = unitTypeId
    m_localTransform = localTransform

  // --------------------------------------------------------------------------
  function getFadeInDuration() returns real
    return m_fadeInDuration

  // --------------------------------------------------------------------------
  function setFadeInDuration(real value)
    m_fadeInDuration = value

  // --------------------------------------------------------------------------
  function getFadeOutDuration() returns real
    return m_fadeOutDuration

  // --------------------------------------------------------------------------
  function setFadeOutDuration(real value)
    m_fadeOutDuration = value
    m_fadeOutMove = 0

  // --------------------------------------------------------------------------
  function setFadeOutToPos(real duration, vec2 moveToPos)
    m_fadeOutDuration = duration
    m_fadeOutMove = 1
    m_fadeOutMoveToPos = moveToPos

  // --------------------------------------------------------------------------
  function setFadeOutToRandomPos(real duration)
    m_fadeOutDuration = duration
    m_fadeOutMove = 2

  // --------------------------------------------------------------------------
  function getUseRecycler() returns bool
    return m_useRecycler

  // --------------------------------------------------------------------------
  function setUseRecycler(bool value)
    m_useRecycler = value

  // --------------------------------------------------------------------------
  function getUnitTypeId() returns int
    return m_unitTypeId

  // --------------------------------------------------------------------------
  function getLocalTransform() returns transform
    return m_localTransform

  // --------------------------------------------------------------------------
  function spawn(player owner, transform parentTransform) returns unit
    let worldTransform = parentTransform.concat(m_localTransform)
    return spawnUnit(owner, m_unitTypeId, worldTransform)

  // --------------------------------------------------------------------------
  function spawn(player owner, int unitTypeIdOverride, transform parentTransform) returns unit
    let worldTransform = parentTransform.concat(m_localTransform)
    return spawnUnit(owner, unitTypeIdOverride, worldTransform)

  // --------------------------------------------------------------------------
  private function spawnUnit(player owner, int unitTypeId, transform worldTransform) returns unit
    let pos = worldTransform.pos.toVec2()
    let facingAngle = worldTransform.rot.getEulerYaw().asAngleRadians()
    
    unit spawnedUnit
    if (m_useRecycler)
      spawnedUnit = createUnitRecycled(owner, unitTypeId, pos, facingAngle)
    else
      spawnedUnit = createUnit(owner, unitTypeId, pos, facingAngle)

    if (m_fadeInDuration > 0.0)
      spawnedUnit.setInvulnerable(true)
      spawnedUnit.fadeIn(m_fadeInDuration)
      doAfter(m_fadeInDuration, () -> spawnedUnit.setInvulnerable(false))

    return spawnedUnit

  // --------------------------------------------------------------------------
  function unspawnUnit(unit spawnedUnit)

    if (m_fadeOutDuration == 0.0 or spawnedUnit.isAlive())
      removeOrRecycleUnit(spawnedUnit)
      return

    spawnedUnit.setInvulnerable(true)
    spawnedUnit.fadeOut()
    
    if (m_fadeOutMove == 1)
      spawnedUnit.issuePointOrder("move", m_fadeOutMoveToPos)
    else if (m_fadeOutMove == 2)
      spawnedUnit.issuePointOrder("move", playableBounds.getRandomPoint())

    doAfter(m_fadeOutDuration) () ->
      removeOrRecycleUnit(spawnedUnit)
      if (m_useRecycler)
        if (spawnedUnit.isAlive() and not spawnedUnit.isStocked())
          spawnedUnit.stock()
      else
        spawnedUnit.remove()

  // --------------------------------------------------------------------------
  private function removeOrRecycleUnit(unit spawnedUnit)
    if (m_useRecycler)
      if (spawnedUnit.isAlive() and not spawnedUnit.isStocked())
        spawnedUnit.stock()
    else
      spawnedUnit.remove()

// ============================================================================
class MapEventDestructableSpawner
  private int m_destructableTypeId
  private int m_variation
  private transform m_localTransform

  // --------------------------------------------------------------------------
  construct(int destructableTypeId, int variation, transform localTransform)
    m_destructableTypeId = destructableTypeId
    m_variation = variation
    m_localTransform = localTransform

  // --------------------------------------------------------------------------
  function getDestructableTypeId() returns int
    return m_destructableTypeId

  // --------------------------------------------------------------------------
  function getVariation() returns int
    return m_variation

  // --------------------------------------------------------------------------
  function getLocalTransform() returns transform
    return m_localTransform

  // --------------------------------------------------------------------------
  function spawn(transform parentTransform) returns destructable
    let worldTransform = parentTransform.concat(m_localTransform)
    return createDestructable(m_destructableTypeId, m_variation, worldTransform)

// ============================================================================
function enumDestructablesInCircle()
  let enumDest = GetEnumDestructable()
  if (enumDest.isAliveTrick())
    g_enumDestructables[g_enumDestructablesCount] = enumDest
    g_enumDestructablesCount++

// ============================================================================
function filterUnitIsLootable() returns bool
  let filterUnit = GetFilterUnit()
  return filterUnit.isLootable()

// ============================================================================
class MapEventAreaCleanerSpawner
  private real m_radius
  private transform m_localTransform

  // --------------------------------------------------------------------------
  construct(real radius, transform localTransform)
    m_radius = radius
    m_localTransform = localTransform

  // --------------------------------------------------------------------------
  function getRadius() returns real
    return m_radius

  // --------------------------------------------------------------------------
  function getLocalTransform() returns transform
    return m_localTransform

  // --------------------------------------------------------------------------
  function spawn(transform parentTransform) returns MapEventAreaCleanerInstance
    let worldTransform = parentTransform.concat(m_localTransform)
    let instance =  new MapEventAreaCleanerInstance(m_radius, worldTransform)
    instance.redo()
    return instance

// ============================================================================
class MapEventAreaCleanerInstance
  private real m_radius
  private transform m_worldTransform
  private LinkedList<destructable> m_destructables
  private group m_units

  // --------------------------------------------------------------------------
  construct(real radius, transform worldTransform)
    m_radius = radius
    m_worldTransform = worldTransform

  // --------------------------------------------------------------------------
  ondestroy
    undo()

  // --------------------------------------------------------------------------
  function redo()

    // Enum destructables in radius
    MoveLocation(g_tempLoc, m_worldTransform.pos.x, m_worldTransform.pos.y)
    g_enumDestructablesCount = 0
    EnumDestructablesInCircleBJ(m_radius, g_tempLoc, function enumDestructablesInCircle)

    if (g_enumDestructablesCount > 0)
    //{
      m_destructables = new LinkedList<destructable>()

      for i = 0 to g_enumDestructablesCount - 1
        let dest = g_enumDestructables[i]
        dest.show(false)
        m_destructables.add(dest)
    //}

    m_units = getGroup()
    m_units.enumUnitsInRange(m_worldTransform.pos.toVec2(), m_radius, g_filterUnitIsLootable)
    for u in m_units
      u.hide()

  // --------------------------------------------------------------------------
  function undo()
    if (m_destructables != null)
      for dest in m_destructables
        dest.show(true)
      destroy m_destructables
      m_destructables = null

    if (m_units != null)
      for u in m_units
        u.show()
      m_units.release()
      m_units = null

// ============================================================================
class MapEventTileSpawner
  private int m_tilesetId
  private int m_variation
  private transform m_localTransform

  // --------------------------------------------------------------------------
  construct(int tilesetId, int variation, transform localTransform)
    m_tilesetId = tilesetId
    m_variation = variation
    m_localTransform = localTransform

  // --------------------------------------------------------------------------
  function getTilesetId() returns int
    return m_tilesetId

  // --------------------------------------------------------------------------
  function getVariation() returns int
    return m_variation

  // --------------------------------------------------------------------------
  function getLocalTransform() returns transform
    return m_localTransform

  // --------------------------------------------------------------------------
  function spawn(transform parentTransform) returns MapEventTileInstance
    let worldTransform = parentTransform.concat(m_localTransform)
    let tile = worldTransform.pos.toVec2().getTile()
    let tileInstance = new MapEventTileInstance(tile, m_tilesetId, m_variation)
    tileInstance.redo()
    return tileInstance

// ============================================================================
public class MapEventTileInstance
  private tile m_tile
  private int m_tilesetId
  private int m_variation
  private int m_prevTilesetId
  private int m_prevVariation

  // --------------------------------------------------------------------------
  construct(tile tile, int tilesetId, int variation)
    m_tile = tile
    m_tilesetId = tilesetId
    m_variation = variation

  // --------------------------------------------------------------------------
  ondestroy
    undo()

  // --------------------------------------------------------------------------
  function redo()
    m_prevTilesetId = m_tile.getType()
    m_prevVariation = m_tile.getVariance()
    m_tile.setType(m_tilesetId, m_variation)

  // --------------------------------------------------------------------------
  function undo()
    m_tile.setType(m_prevTilesetId, m_prevVariation)

// ============================================================================
public class MapEvent extends Runnable
  private string m_id
  private transform m_worldTransform

  // --------------------------------------------------------------------------
  construct(string id)
    m_id = id
    g_mapEvents.add(this)

  // --------------------------------------------------------------------------
  ondestroy
    g_mapEvents.remove(this)

  // --------------------------------------------------------------------------
  static function registerMapEventFactory(string id, Func<MapEvent> factory)
    g_mapEventFactories.put(id, factory.acquire())

  // --------------------------------------------------------------------------
  static function createMapEvent(string id) returns MapEvent
    let factory = g_mapEventFactories.get(id)
    return factory != null ? factory.call() : null

  // --------------------------------------------------------------------------
  function getId() returns string
    return m_id

  // --------------------------------------------------------------------------
  function getWorldTransform() returns transform
    return m_worldTransform

  // --------------------------------------------------------------------------
  function setWorldTransform(transform worldTransform)
    m_worldTransform = worldTransform

  // --------------------------------------------------------------------------
  override protected function onStarted()
    g_runningMapEvents.add(this)
  
  // --------------------------------------------------------------------------
  override protected function onPaused()
    g_runningMapEvents.remove(this)
  
  // --------------------------------------------------------------------------
  override protected function onResumed()
    g_runningMapEvents.add(this)

  // --------------------------------------------------------------------------
  override protected function onCompleted()
    g_runningMapEvents.remove(this)

// ============================================================================
init

  // This comes from the generated MapEventsInit.wurst file
  nullTimer(() -> registerMapEventTemplates())