package BehaviorLibrary
import Behaviors
import Table
import Orders

// ==========================================================================
public class MoveToPoint extends BehaviorBase
  constant real s_arrivalDistanceSq = 32.0 * 32.0
  int _targetXKey
  int _targetYKey

  construct(int targetXKey, int targetYKey)
    _targetXKey = targetXKey
    _targetYKey = targetYKey

  construct(MoveToPoint other)
    super(other)
    _targetXKey = other._targetXKey
    _targetYKey = other._targetYKey

  override function getName() returns string
    return "MoveToPoint"

  override function clone() returns IBehavior
    return new MoveToPoint(this)

  override function onEnter(IBehaviorTreeContext context)
    Log.info("MoveToPoint::onEnter")
    let u = context.getUnit()
    let t = context.getTable()
    let targetPoint = getTargetPoint(t)
    u.issuePointOrderById(OrderIds.move, targetPoint)
    
  override function onUpdate(IBehaviorTreeContext context) returns BehaviorState
    let u = context.getUnit()
    let t = context.getTable()
    let targetPoint = getTargetPoint(t)
    let dist = u.getPos().distanceToSq(targetPoint)

    if (u.getCurrentOrder() != OrderIds.move)
      Log.info("MoveToPoint::onUpdate FAILURE Order was different than move")
      return BehaviorState.FAILURE

    if (dist < s_arrivalDistanceSq)
      Log.info("MoveToPoint::onUpdate SUCCESS Arrived at target location")
      return BehaviorState.SUCCESS
    
    return BehaviorState.RUNNING

  override function onExit(IBehaviorTreeContext context)
    Log.info("MoveToPoint::onExit")
    let u = context.getUnit()
    u.issueImmediateOrderById(OrderIds.stop)
    
  private function getTargetPoint(Table table) returns vec2
    let targetX = table.loadReal(_targetXKey)
    let targetY = table.loadReal(_targetYKey)
    return vec2(targetX, targetY)
    

